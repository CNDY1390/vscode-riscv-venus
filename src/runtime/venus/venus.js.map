{"version":3,"file":"venus.js","sources":["kotlin/collections.kt","../../../src/main/kotlin/venus/IRenderer.kt","text/Strings.kt","collections/Maps.kt","util/Preconditions.kt","generated/_Collections.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/utils.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/utils.kt","kotlin/math.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fclass.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/s/fsd.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ecall/ecall.kt","kotlin/ULong.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/div.kt","../../../src/main/kotlin/venusbackend/riscv/utils.kt","generated/_Strings.kt","arrayUtils.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorState64.kt","../../../src/main/kotlin/venus/api/API.kt","../../../src/main/kotlin/venus/api/FunctionsList.kt","kotlin/jsTypeOf.kt","../../../src/main/kotlin/venus/api/ScriptManager.kt","org.w3c/org.w3c.dom.kt","collections/Collections.kt","../../../src/main/kotlin/venus/api/venusbackend/simulator/Simulator.kt","../../../src/main/kotlin/venus/CookieJar.kt","../../../src/main/kotlin/venus/Driver.kt","../../../src/main/kotlin/venus/ErrorHandler.kt","util/Standard.kt","text/Char.kt","../../../src/main/kotlin/venus/LocalStorage.kt","../../../src/main/kotlin/venus/Renderer.kt","../../../src/main/kotlin/venus/RendererOriginal.kt","../../../src/main/kotlin/venus/terminal/cmds/assemble.kt","../../../src/main/kotlin/venus/terminal/cmds/cat.kt","../../../src/main/kotlin/venus/terminal/cmds/cd.kt","../../../src/main/kotlin/venus/terminal/cmds/cp.kt","../../../src/main/kotlin/venus/terminal/cmds/download.kt","../../../src/main/kotlin/venus/terminal/cmds/edit.kt","../../../src/main/kotlin/venus/terminal/cmds/help.kt","../../../src/main/kotlin/venus/terminal/cmds/link.kt","../../../src/main/kotlin/venus/terminal/cmds/ls.kt","../../../src/main/kotlin/venus/terminal/cmds/mkdir.kt","../../../src/main/kotlin/venus/terminal/cmds/mv.kt","../../../src/main/kotlin/venus/terminal/cmds/pwd.kt","../../../src/main/kotlin/venus/terminal/cmds/rm.kt","../../../src/main/kotlin/venus/terminal/cmds/run.kt","../../../src/main/kotlin/venus/terminal/cmds/save.kt","../../../src/main/kotlin/venus/terminal/cmds/touch.kt","../../../src/main/kotlin/venus/terminal/cmds/tree.kt","../../../src/main/kotlin/venus/terminal/cmds/unzip.kt","../../../src/main/kotlin/venus/terminal/cmds/upload.kt","org.w3c/org.w3c.files.kt","../../../src/main/kotlin/venus/terminal/cmds/vdb.kt","../../../src/main/kotlin/venus/terminal/cmds/xxd.kt","../../../src/main/kotlin/venus/terminal/cmds/zip.kt","../../../src/main/kotlin/venus/terminal/Command.kt","../../../src/main/kotlin/venus/terminal/CommandNotFoundError.kt","../../../src/main/kotlin/venus/terminal/CommandNotImplementedError.kt","../../../src/main/kotlin/venus/terminal/Terminal.kt","kotlin/text/string.kt","../../../src/main/kotlin/venus/vfs/JsonContainer.kt","../../../src/main/kotlin/venus/vfs/VFSDrive.kt","../../../src/main/kotlin/venus/vfs/VFSDummy.kt","../../../src/main/kotlin/venus/vfs/VFSFile.kt","../../../src/main/kotlin/venus/vfs/VFSFolder.kt","../../../src/main/kotlin/venus/vfs/VFSLinkedProgram.kt","../../../src/main/kotlin/venus/vfs/VFSObject.kt","../../../src/main/kotlin/venus/vfs/VFSPermissions.kt","../../../src/main/kotlin/venus/vfs/VFSProgram.kt","../../../src/main/kotlin/venus/vfs/VFSType.kt","../../../src/main/kotlin/venus/vfs/VirtualFileSystem.kt","../../../src/main/kotlin/venus/zip/zip.kt","../../../src/main/kotlin/venusbackend/assembler/Assembler.kt","generated/_Maps.kt","../../../src/main/kotlin/venusbackend/assembler/AssemblerError.kt","../../../src/main/kotlin/venusbackend/assembler/AssemblerWarning.kt","../../../src/main/kotlin/venusbackend/assembler/Lexer.kt","collections/MutableCollections.kt","../../../src/main/kotlin/venusbackend/assembler/Linter.kt","../../../src/main/kotlin/venusbackend/assembler/PseudoDispatcher.kt","../../../src/main/kotlin/venusbackend/assembler/PseudoDispatcherError.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BEQZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BGEZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BGT.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BGTU.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BGTZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BLE.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BLEU.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BLEZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BLTZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/BNEZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/CALL.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FABSD.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FABSS.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FMVD.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FMVS.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FNEGD.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/FNEGS.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/J.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/JAL.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/JALR.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/JR.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/LA.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/LI.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/Load.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/MV.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/NEG.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/NEGW.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/NOP.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/NOT.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/RET.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SEQ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SEQZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SEXTW.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SGE.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SGT.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SGTZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SLE.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SLTZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SNE.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/SNEZ.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/Store.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/TAIL.kt","../../../src/main/kotlin/venusbackend/assembler/pseudos/utils.kt","../../../src/main/kotlin/venusbackend/assembler/PseudoWriter.kt","../../../src/main/kotlin/venusbackend/cli/Actions.kt","../../../src/main/kotlin/venusbackend/cli/CommandLineException.kt","../../../src/main/kotlin/venusbackend/cli/CommandLineInterface.kt","../../../src/main/kotlin/venusbackend/cli/CommandLineParser.kt","../../../src/main/kotlin/venusbackend/cli/Events.kt","../../../src/main/kotlin/venusbackend/cli/FlagArguments.kt","../../../src/main/kotlin/venusbackend/cli/FlagValueArguments.kt","../../../src/main/kotlin/venusbackend/cli/HelpEntriesGroup.kt","../../../src/main/kotlin/venusbackend/cli/HelpPrinter.kt","../../../src/main/kotlin/venusbackend/cli/parse.kt","../../../src/main/kotlin/venusbackend/cli/PositionalArguments.kt","../../../src/main/kotlin/venusbackend/cli/SharedOption.kt","../../../src/main/kotlin/venusbackend/cli/Subcommands.kt","../../../src/main/kotlin/venusbackend/cli/util.kt","../../../src/main/kotlin/venusbackend/linker/ImportProgramData.kt","../../../src/main/kotlin/venusbackend/linker/LinkedProgram.kt","../../../src/main/kotlin/venusbackend/linker/Linker.kt","../../../src/main/kotlin/venusbackend/linker/ProgramAndLibraries.kt","../../../src/main/kotlin/venusbackend/numbers/DoubleQuadWord.kt","../../../src/main/kotlin/venusbackend/numbers/QuadWord.kt","../../../src/main/kotlin/venusbackend/Operations.kt","../../../src/main/kotlin/venusbackend/riscv/Address.kt","../../../src/main/kotlin/venusbackend/riscv/InitInstructions.kt","../../../src/main/kotlin/venusbackend/riscv/InstructionField.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/BTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/ITypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/LoadDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/RTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/ShiftImmediateDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/STypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/base/UTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/atomic/AMORTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/compressed/CATypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/compressed/CRTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FFRRTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FITypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FR4TypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FRRTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FRTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/FSTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/extensions/floating/RFRTypeDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/disasms/RawDisassembler.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/base/BTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/base/ITypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/base/RTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/base/STypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/base/UTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/atomic/AMORTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/compressed/CATypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/compressed/CRTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/floating/FRTypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/floating/FSRS2TypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/extensions/floating/R4TypeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/InstructionFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/OpcodeCFunct3Format.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/OpcodeFormat.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/formats/OpcodeFunct3Format.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/BTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/ITypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/LoadImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/RTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/ShiftImmediateImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b32/STypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/BTypeImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/ITypeImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/LoadImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/RTypeImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/ShiftImmediateImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/base/b64/STypeImplementation64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/atomic/b32/AMORTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/compressed/b32/CATypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/compressed/b32/CRTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/FFRRTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/FITypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/FR4TypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/FRTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/FSTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/extensions/floating/b32/RtFTypeImplementation32.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/NoImplementation.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/impls/RawImplementation.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/BTypeParser.kt","generated/_Ranges.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/CSRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/ITypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/LoadParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/RTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/ShiftImmediateParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/STypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/base/UTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/DoNothingParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/atomic/AMORTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/compressed/CATypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/compressed/CRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FFRRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FITypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FR4TypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FRRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/FSTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/extensions/floating/RFRTypeParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/ParserError.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/RawParser.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/parsers/utils.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/ImmAbsRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/ImmAbsStoreRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/JALRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/NoRelocator64.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/PCRelHiRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/PCRelLoRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/PCRelLoStoreRelocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/relocators/Relocator.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/BTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/ITypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/LoadTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/RTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/ShiftImmediateInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/ShiftWImmediateInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/STypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/base/UTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/atomic/AMORTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/compressed/CATypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/compressed/CRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/F3RTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FclassRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FFRRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FITypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FR4TypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FRRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FSTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/FtRTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/extensions/floating/RtFTypeInstruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/dsl/types/Instruction.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/Decimal.kt","kotlin/numbers_js-v1.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/i/fld.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fadd.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fcvt.d.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fcvt.d.wu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fcvt.w.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fcvt.wu.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/feq.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fle.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/flt.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmadd.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmax.d.kt","generated/_ComparisonsJs.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmin.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmsub.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmul.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmv.d.x.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fmv.x.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fnmadd.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fnmsub.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fsgnj.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fsgnjn.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fsgnjx.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fsqrt.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/double/r/fsub.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/fcvt.d.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/fcvt.s.d.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/i/flw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fadd.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fclass.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fcvt.s.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fcvt.s.wu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fcvt.w.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fcvt.wu.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fdiv.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/feq.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fle.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/flt.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmadd.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmax.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmin.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmsub.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmul.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmv.s.x.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fmv.x.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fnmadd.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fnmsub.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fsgnj.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fsgnjn.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fsgnjx.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fsqrt.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/r/fsub.s.kt","../../../src/main/kotlin/venusbackend/riscv/insts/floating/single/s/fsw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/InstructionNotFoundError.kt","../../../src/main/kotlin/venusbackend/riscv/insts/InstructionNotSupportedError.kt","../../../src/main/kotlin/venusbackend/riscv/insts/InstructionReservedError.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/addi.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/addiw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/andi.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrc.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrci.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrs.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrsi.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/csrrwi.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ebreak.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ecall/clib.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ecall/malloc.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/fence.i.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/fence.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/jalr.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lb.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lbu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ld.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lh.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lhu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/lwu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/ori.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/slli.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/slliw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/slti.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/sltiu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/srai.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/sraiw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/srli.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/srliw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/i/xori.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/add.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/addw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/and.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/or.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sll.kt","experimental/bitwiseOperations.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sllw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/slt.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sltu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sra.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sraw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/srl.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/srlw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/sub.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/subw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/r/xor.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/s/sb.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/s/sd.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/s/sh.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/s/sw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/beq.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/bge.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/bgeu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/blt.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/bltu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/sb/bne.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/u/auipc.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/u/lui.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/base/uj/jal.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amoadd.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amoand.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amomax.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amomaxu.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amomin.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amominu.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amoor.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amoswap.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/amoxor.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/lr.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/atomic/r/sc.w.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.addw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.and.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.or.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.sub.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.subw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ca/c.xor.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ci/caddi.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ci/clwsp.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/ci/cnop.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/cr/c.add.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/cr/c.ebreak.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/compressed/cr/c.mv.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/divu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/divw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/mul.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/mulh.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/mulhsu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/mulhu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/mulw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/rem.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/remu.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/remuw.kt","../../../src/main/kotlin/venusbackend/riscv/insts/integer/extensions/multiply/r/remw.kt","../../../src/main/kotlin/venusbackend/riscv/MachineCode.kt","../../../src/main/kotlin/venusbackend/riscv/MemorySegments.kt","../../../src/main/kotlin/venusbackend/riscv/MemSize.kt","../../../src/main/kotlin/venusbackend/riscv/Program.kt","text/regex/MatchResult.kt","../../../src/main/kotlin/venusbackend/riscv/Registers.kt","../../../src/main/kotlin/venusbackend/riscv/Settings.kt","kotlin/text/numberConversions.kt","../../../src/main/kotlin/venusbackend/simulator/AlignmentError.kt","../../../src/main/kotlin/venusbackend/simulator/cache/Block.kt","../../../src/main/kotlin/venusbackend/simulator/cache/Cache.kt","../../../src/main/kotlin/venusbackend/simulator/cache/CacheError.kt","../../../src/main/kotlin/venusbackend/simulator/cache/CacheHandler.kt","../../../src/main/kotlin/venusbackend/simulator/cache/CacheState.kt","../../../src/main/kotlin/venusbackend/simulator/cache/Set.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/CacheDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/FRegisterDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/HeapSpaceDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/InstructionDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/MemoryDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/PCDiff.kt","../../../src/main/kotlin/venusbackend/simulator/diffs/RegisterDiff.kt","../../../src/main/kotlin/venusbackend/simulator/ExceededAllowedCyclesError.kt","../../../src/main/kotlin/venusbackend/simulator/FileDescriptor.kt","../../../src/main/kotlin/venusbackend/simulator/FilesHandler.kt","../../../src/main/kotlin/venusbackend/simulator/History.kt","../../../src/main/kotlin/venusbackend/simulator/Memory.kt","../../../src/main/kotlin/venusbackend/simulator/Simulator.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorError.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorSettings.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorState128.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorState16.kt","../../../src/main/kotlin/venusbackend/simulator/SimulatorState32.kt","../../../src/main/kotlin/venusbackend/simulator/StoreError.kt","../../../src/main/kotlin/venusbackend/simulator/Trace.kt","generated/_ArraysJs.kt","../../../src/main/kotlin/venusbackend/simulator/Tracer.kt","../../../src/main/kotlin/venusbackend/utils.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n","package venus\r\n/* ktlint-disable no-wildcard-imports */\r\n\r\nimport org.w3c.dom.*\r\nimport venus.vfs.*\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.Simulator\r\nimport venusbackend.simulator.SimulatorError\r\nimport venusbackend.simulator.cache.BlockState\r\nimport venusbackend.simulator.cache.ChangedBlockState\r\nimport venusbackend.simulator.diffs.*\r\n//import kotlin.browser.document\r\n//import kotlin.browser.window\r\n//import kotlin.dom.addClass\r\nimport kotlin.dom.removeClass\r\n\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n/**\r\n * This singleton is used to render different parts of the screen, it serves as an interface between the UI and the\r\n * internal simulator.\r\n *\r\n * @todo break this up into multiple objects\r\n */\r\ninterface IRenderer {\r\n    // TODO: maybe need to declare in Renderer as const\r\n    val MEMORY_CONTEXT: Int\r\n    // TODO: Can I delete this?\r\n    var pkgmsgTimeout: Int?\r\n    /** a map from integers to the corresponding hex digits */\r\n    val hexMap: List<Char>\r\n    /** The register currently being highlighted */\r\n    var activeRegister: HTMLElement?\r\n    /** The instruction currently being highlighted */\r\n    var activeInstruction: HTMLElement?\r\n    /** The memory location currently centered */\r\n    var activeMemoryAddress: Int\r\n    /** The simulator being rendered */\r\n    var sim: Simulator\r\n    /* The way the information in the registers is displayed*/\r\n    var displayType: String\r\n\r\n    var mainTabs: ArrayList<String>\r\n\r\n    @JsName(\"renderTab\") fun renderTab(tab: String, tabs: List<String>) {\r\n    }\r\n\r\n    @JsName(\"addTab\") fun addTab(tabName: String, tabList: ArrayList<String>): Boolean {\r\n        return true;\r\n    }\r\n\r\n    @JsName(\"removeTab\") fun removeTab(tabName: String, tabList: ArrayList<String>): Boolean  {\r\n        return true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Shows the simulator tab and hides other tabs\r\n     *\r\n     * @param displaySim the simulator to show\r\n     */\r\n    fun renderSimulator(){\r\n        \r\n    }\r\n\r\n    fun loadSimulator(displaySim: Simulator) {\r\n        sim = displaySim\r\n        setRunButtonSpinning(false)\r\n        renderProgramListing()\r\n        clearConsole()\r\n        updateAll()\r\n        renderSimButtons()\r\n    }\r\n\r\n    fun renderSimButtons() {\r\n    }\r\n\r\n    fun renderAssembleButtons() {\r\n    }\r\n\r\n    /** Shows the editor tab and hides other tabs */\r\n    fun renderEditor() {\r\n    }\r\n\r\n    fun renderVenus() {\r\n    }\r\n\r\n    fun renderURLMaker() {\r\n    }\r\n\r\n    /**\r\n     * Sets the tab to the desired visiblity.\r\n     *\r\n     * Also updates the highlighted tab at the top.\r\n     *\r\n     * @param tab the name of the tab (currently \"editor\" or \"simulator\")\r\n     */\r\n    @JsName(\"tabSetVisibility\") private fun tabSetVisibility(tab: String, display: String) {\r\n        \r\n    }\r\n\r\n    fun displayWarning(w: String) {\r\n        \r\n    }\r\n\r\n    /** Display a given ERROR */\r\n    fun displayError(thing: Any) {\r\n        \r\n    }\r\n\r\n    fun stdout(thing: Any) {\r\n        \r\n    }\r\n\r\n    fun stderr(thing: Any) {\r\n        displayError(thing)\r\n    }\r\n\r\n    /** Display a given [AssemblerError] */\r\n    @Suppress(\"UNUSED_PARAMETER\") fun displayAssemblerError(e: AssemblerError) {\r\n//        if (e.line !== null) {\r\n//            js(\"alert('[ERROR]\\\\n(Line: ' + e.line + ') ' + e.message)\")\r\n//        } else {\r\n            js(\"alert('[ERROR]\\\\n' + e.message)\")\r\n//        }\r\n    }\r\n\r\n    /**\r\n     * Renders the program listing under the debugger\r\n     */\r\n    private fun renderProgramListing() {\r\n        \r\n    }\r\n\r\n    /**\r\n     * Refresh all of the simulator tab's content\r\n     *\r\n     * @todo refactor this into a \"reset\" and \"update\" all function\r\n     */\r\n    fun updateAll() {\r\n        \r\n    }\r\n\r\n    /**\r\n     * Updates the view by applying each individual diff.\r\n     *\r\n     * @param diffs the list of diffs to apply\r\n     */\r\n    fun updateFromDiffs(diffs: List<Diff>) {\r\n        \r\n    }\r\n\r\n    /**\r\n     * Clears the current program listing.\r\n     *\r\n     * @todo find a less hacky way to do this?\r\n     */\r\n    fun clearProgramListing() {    \r\n    }\r\n\r\n    /**\r\n     * Adds an instruction with the given index to the program listing.\r\n     *\r\n     * @param idx the pc of the instruction\r\n     * @param mcode the machine code representation of the instruction\r\n     * @param progLine the original assembly code\r\n     */\r\n    fun addToProgramListing(pcx: Int, mcode: MachineCode, progLine: String, invalidInst: Boolean = false) {\r\n        \r\n    }\r\n\r\n    fun updateProgramListing(idx: Number, inst: Int, orig: String? = null): InstructionDiff {\r\n        return InstructionDiff(0, 0, \"\")\r\n    }\r\n\r\n    /**\r\n     * Gets the element with a given ID\r\n     *\r\n     * @param id the id of the desired element\r\n     *\r\n     * @returns the HTML element corresponding to the given ID\r\n     * @throws ClassCastException if the element is not an [HTMLElement] or does not exist\r\n     */\r\n    fun getElement(id: String): HTMLElement {\r\n        return HTMLDivElement as HTMLElement\r\n    }\r\n\r\n    /**\r\n     * Updates the register with the given id and value.\r\n     *\r\n     * @param id the ID of the register (e.g., x13 has ID 13)\r\n     * @param value the new value of the register\r\n     * @param setActive whether the register should be set to the active register (i.e., highlighted for the user)\r\n     */\r\n    fun updateRegister(id: Int, value: Number, setActive: Boolean = false) {\r\n    }\r\n\r\n    /**\r\n     * Updates the register with the given id and value.\r\n     *\r\n     * @param id the ID of the floating register (e.g., f13 has ID 13)\r\n     * @param value the new value of the register\r\n     * @param setActive whether the register should be set to the active register (i.e., highlighted for the user)\r\n     */\r\n    fun updateFRegister(id: Int, v: Decimal, setActive: Boolean = false) {\r\n    }\r\n\r\n    fun intToString(value: Int): String {\r\n        var v = when (displayType) {\r\n            \"Hex\" -> toHex(value)\r\n            \"Decimal\" -> value.toString()\r\n            \"Unsigned\" -> toUnsigned(value)\r\n            \"ASCII\" -> toAscii(value)\r\n            else -> toHex(value)\r\n        }\r\n        return v\r\n    }\r\n\r\n    /*@TODO make it so I can detect between if I am continuing or not so I do not have to be too wasteful.*/\r\n    fun updateCache(a: Address) {\r\n    }\r\n\r\n    fun renderSetCacheLevel(i: Int) {\r\n    }\r\n\r\n    fun renderAddCacheLevel() {\r\n    }\r\n\r\n    fun renderRemoveCacheLevel() {\r\n    }\r\n\r\n    fun makeCacheBlocks() {\r\n    }\r\n\r\n    //TODO: Can I get rid of optional parameter\r\n    fun updateCacheBlocks(b: ChangedBlockState = ChangedBlockState(0, BlockState.MISS)) {\r\n        \r\n    }\r\n\r\n    fun updateAllCacheBlocks() {\r\n    }\r\n\r\n    /**\r\n     * Updates the PC to the given value. It also highlights the to-be-executed instruction.\r\n     *\r\n     * @param pc the new PC\r\n     * @todo abstract away instruction length\r\n     */\r\n    fun updatePC(pc: Number) {\r\n    }\r\n\r\n    /**\r\n     * Prints the given thing to the console as a string.\r\n     *\r\n     * @param thing the thing to print\r\n     */\r\n    fun printConsole(thing: Any) {\r\n    }\r\n\r\n    /**\r\n     * Clears the console\r\n     */\r\n    fun clearConsole() {\r\n    }\r\n\r\n    /**\r\n     * Sets whether the run button is spinning.\r\n     *\r\n     * @param spinning whether the button should be spin\r\n     */\r\n    fun setRunButtonSpinning(spinning: Boolean) {\r\n    }\r\n\r\n    /**\r\n     * Sets whether the name button is spinning.\r\n     *\r\n     * @param spinning whether the button should be spin\r\n     */\r\n    fun setNameButtonSpinning(name: String, spinning: Boolean) {\r\n    }\r\n    /**\r\n     * Sets whether a button is disabled.\r\n     *\r\n     * @param id the id of the button to change\r\n     * @param disabled whether or not to disable the button\r\n     */\r\n    private fun setButtonDisabled(id: String, disabled: Boolean) {\r\n    }\r\n\r\n    /**\r\n     * Renders the control buttons to be enabled / disabled appropriately.\r\n     */\r\n    fun updateControlButtons() {\r\n    }\r\n\r\n    /**\r\n     * Disables the step, undo and reset buttons.\r\n     *\r\n     * Used while running, see [Driver.runStart].\r\n     */\r\n    fun disableControlButtons() {\r\n    }\r\n\r\n    /**\r\n     * Renders a change in breakpoint status\r\n     *\r\n     * @param idx the index to render\r\n     * @param state whether or not there is a breakpoint\r\n     */\r\n    fun renderBreakpointAt(idx: Int, state: Boolean) {\r\n    }\r\n\r\n    /**\r\n     * Number of rows to show around the current address\r\n     */\r\n   \r\n\r\n    /** Show the memory sidebar tab */\r\n    fun renderMemoryTab() {\r\n    }\r\n\r\n    /** Show the register sidebar tab */\r\n    fun renderRegisterTab() {\r\n    }\r\n\r\n    fun renderCacheTab() {\r\n    }\r\n\r\n    fun renderSettingsTab() {\r\n    }\r\n\r\n    fun renderGeneralSettingsTab() {\r\n    }\r\n\r\n    /**\r\n     * Show the tracer settings tab\r\n     */\r\n    fun renderTracerSettingsTab() {\r\n    }\r\n\r\n    fun renderPackagesTab() {\r\n    }\r\n\r\n    fun renderRegsTab() {\r\n    }\r\n\r\n    fun renderFRegsTab() {\r\n    }\r\n\r\n    fun rendererAddPackage(pid: String, enabled: Boolean, removable: Boolean = true) {\r\n    }\r\n\r\n    fun rendererRemovePackage(pid: String) {\r\n    }\r\n\r\n    fun rendererUpdatePackage(pid: String, state: Boolean) {\r\n    }\r\n\r\n    fun pkgMsg(m: String) {\r\n    }\r\n\r\n    fun clearPkgMsg() {\r\n    }\r\n\r\n    /**\r\n     * Update the [MEMORY_CONTEXT] words above and below the given address.\r\n     *\r\n     * Does not shift the memory display if it can be avoided\r\n     *\r\n     * @param addr the address to update around\r\n     */\r\n    fun updateMemory(addr: Int) {\r\n    }\r\n\r\n    /**\r\n     * Determines if we need to move the memory display to show the address\r\n     *\r\n     * @param wordAddress the address we want to show\r\n     * @return true if we need to move the display\r\n     */\r\n    private fun mustMoveMemoryDisplay(wordAddress: Int) = true\r\n\r\n    /**\r\n     * Renders a row of the memory.\r\n     *\r\n     * @param row the HTML element of the row to render\r\n     * @param rowAddr the new address of that row\r\n     */\r\n    private fun renderMemoryRow(urow: HTMLElement, rowAddr: Int) {\r\n    }\r\n\r\n    private fun cleanTableRow(row: HTMLElement): HTMLElement {\r\n        return row\r\n    }\r\n\r\n    \r\n\r\n    /**\r\n     * Convert a certain byte to hex\r\n     *\r\n     * @param b the byte to convert\r\n     * @return a hex string for the byte\r\n     *\r\n     * @throws IndexOutOfBoundsException if b is not in -127..255\r\n     */\r\n    private fun byteToHex(b: Int): String {\r\n        val leftNibble = hexMap[b ushr 4]\r\n        val rightNibble = hexMap[b and 15]\r\n        return \"$leftNibble$rightNibble\"\r\n    }\r\n\r\n    private fun byteToDec(b: Int): String = b.toByte().toString()\r\n\r\n    private fun byteToUnsign(b: Int): String = b.toString()\r\n\r\n    /**\r\n     * Converts a value to a two's complement hex number.\r\n     *\r\n     * By two's complement, I mean that -1 becomes 0xFFFFFFFF not -0x1.\r\n     *\r\n     * @param value the value to convert\r\n     * @return the hexadecimal string corresponding to that value\r\n     * @todo move this?\r\n     */\r\n    fun toHex(value: Int, num_nibbles: Int = 8, add_prefix: Boolean = true): String {\r\n        var remainder = value.toLong()\r\n        var suffix = \"\"\r\n\r\n        repeat(num_nibbles) {\r\n            val hexDigit = hexMap[(remainder and 15).toInt()]\r\n            suffix = hexDigit + suffix\r\n            remainder = remainder ushr 4\r\n        }\r\n\r\n        if (add_prefix) {\r\n            suffix = \"0x\" + suffix\r\n        }\r\n\r\n        return suffix\r\n    }\r\n\r\n    fun toHex(value: Number): String {\r\n        return toHex(value.toInt())\r\n    }\r\n\r\n    private fun toUnsigned(value: Int): String =\r\n            if (value >= 0) value.toString() else (value + 0x1_0000_0000L).toString()\r\n\r\n    private fun toAscii(value: Int, num_nibbles: Int = 8): String {\r\n        var s = \"\"\r\n//        for (i in 0..3) {\r\n//            val v = (value shr i * 8) and 0xFF\r\n            val v = value\r\n            s += when (v) {\r\n                !in 0..255 -> toHex(v, num_nibbles = num_nibbles)\r\n//                !in 32..126 -> \"\\uFFFD\"\r\n                !in 32..126 -> toHex(v, num_nibbles = num_nibbles)\r\n                else -> \"${v.toChar()}\"\r\n            }\r\n//        }\r\n        return s\r\n    }\r\n\r\n    /**\r\n     * Sets the display type for all of the registers and memory\r\n     * Rerenders after\r\n     */\r\n    fun updateRegMemDisplay() {\r\n    }\r\n\r\n    fun moveMemoryJump() {\r\n    }\r\n\r\n    private fun moveMemoryBy(rows: Int) {\r\n    }\r\n\r\n    fun moveMemoryUp() = moveMemoryBy(MEMORY_CONTEXT)\r\n    fun moveMemoryDown() = moveMemoryBy(-MEMORY_CONTEXT)\r\n\r\n    fun updateText() {\r\n    }\r\n\r\n    fun renderButton(e: HTMLButtonElement, b: Boolean) {\r\n    }\r\n\r\n    fun addObjectToDisplay(obj: VFSObject, special: String = \"\") {\r\n    }\r\n\r\n    fun addFilePWD(obj: VFSObject) {\r\n    }\r\n\r\n    fun clearObjectsFromDisplay() {\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package venusbackend.riscv.insts.dsl.impls\r\n\r\n/**\r\n * Sign extends v of sz bits to a 32 bit integer\r\n *\r\n * @param v the number to sign extend\r\n * @param sz the number of bits that v takes\r\n */\r\ninternal fun signExtend(v: Int, sz: Int): Int = v shl (32 - sz) shr (32 - sz)\r\n\r\ninternal fun setBitslice(x: Int, y: Int, start: Int, end: Int): Int {\r\n    val mask: Int = ((1L shl end) - (1L shl start)).inv().toInt()\r\n    return (mask and x) or (y shl start)\r\n}\r\n","package venusbackend.riscv.insts.dsl\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.userStringToInt\r\nimport kotlin.math.ceil\r\nimport kotlin.math.log2\r\n\r\n/**\r\n * Gets the immediate from a string, checking if it is in range.\r\n *\r\n * @param str the immediate as a string\r\n * @param min the minimum allowable value of the immediate\r\n * @param max the maximum allowable value of the immediate\r\n * @return the immediate, as an integer\r\n *\r\n * @throws IllegalArgumentException if the wrong number of arguments is given\r\n */\r\nvar getImmWarning = \"\"\r\ninternal fun getImmediate(str: String, min: Int, max: Int, dbg: DebugInfo): Int {\r\n    var imm = try {\r\n        userStringToInt(str)\r\n    } catch (e: NumberFormatException) {\r\n        val hint = when {\r\n            str.length > 4 -> \" (might be too large)\"\r\n            else -> \"\"\r\n        }\r\n        throw AssemblerError(\"invalid number, got $str$hint\", dbg)\r\n    }\r\n\r\n    if (imm !in min..max) {\r\n        val imm_range = max - min + 1\r\n        if (min < 0 && imm > 0 && imm < imm_range) {\r\n            val topbit = imm and (1 shl (ceil(log2(imm_range.toDouble())).toInt() - 1))\r\n            val mask = topbit.inv()\r\n            imm = imm and mask\r\n            imm -= topbit\r\n            getImmWarning = \"\"\"The value that was given was larger than the max allowed value ($max) but within a valid unsigned range (0 to ${imm_range - 1}) so it will be interpreted just as two's complement bits ($imm).\"\"\"\r\n        } else {\r\n            val largeimm = if (min < 0 && imm > 0) \" or between 0 and $imm_range to fill the bits using two's complement\" else \"\"\r\n            throw AssemblerError(\"immediate $str (= $imm) out of range (should be between $min and $max$largeimm)\", dbg)\r\n        }\r\n    }\r\n\r\n    return imm\r\n}\r\n\r\ninternal fun compareUnsignedShort(v1: Short, v2: Short): Short {\r\n    return ((v1.toInt() xor Short.MIN_VALUE.toInt()).toShort()).compareTo((v2.toInt() xor Short.MIN_VALUE.toInt()).toShort()).toShort()\r\n}\r\n\r\ninternal fun compareUnsigned(v1: Int, v2: Int): Int {\r\n    return (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\r\n}\r\n\r\ninternal fun compareUnsignedLong(v1: Long, v2: Long): Int {\r\n    return (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\r\n}\r\n\r\ninternal fun compareUnsignedQuadWord(v1: QuadWord, v2: QuadWord): Int {\r\n    return (v1 xor QuadWord.MIN_VALUE).compareTo(v2 xor QuadWord.MIN_VALUE)\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FclassRTypeInstruction\r\n\r\n/*TODO fix so this is better.*/\r\nval fclassd = FclassRTypeInstruction(\r\n        name = \"fclass.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b1110000,\r\n        eval32 = { a, b ->\r\n            var bits = 0b0\r\n            if (a.getCurrentDouble() == Double.NEGATIVE_INFINITY) bits = bits or 0b0000000001\r\n            if (a.getCurrentDouble() < 0 && a.getCurrentDouble() >= (-1.17549435e-38).toFloat()) bits = bits or 0b0000000010\r\n            if (a.getCurrentDouble() < 0 && a.getCurrentDouble() < (-1.17549435e-38).toFloat()) bits = bits or 0b0000000100\r\n            if (a.getCurrentDouble().toRawBits() == 0L) bits = bits or 0b0000001000\r\n            if (a.getCurrentDouble().toRawBits() == 0x800000000000000L) bits = bits or 0b0000010000\r\n            if (a.getCurrentDouble() > 0 && a.getCurrentDouble() >= (1.17549435e-38).toFloat()) bits = bits or 0b0000100000\r\n            if (a.getCurrentDouble() > 0 && a.getCurrentDouble() < (1.17549435e-38).toFloat()) bits = bits or 0b0001000000\r\n            if (a.getCurrentDouble() == Double.POSITIVE_INFINITY) bits = bits or 0b0010000000\r\n            if (Double.NaN.equals(a.getCurrentDouble())) bits = bits or 0b0100000000\r\n            if (Double.NaN.equals(a.getCurrentDouble())) bits = bits or 0b1000000000\r\n            bits\r\n        }\r\n)","package venusbackend.riscv.insts.floating.double.s\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FSTypeInstruction\r\n\r\nval fsd = FSTypeInstruction(\r\n        name = \"fsd\",\r\n        opcode = 0b0100111,\r\n        funct3 = 0b011,\r\n//        store16 = NoImplementation,\r\n        store32 = { sim, address, value ->\r\n            sim.storeWordwCache(address, (value.getCurrentDouble().toRawBits() and 0xFFFFFFFF).toInt())\r\n            sim.storeWordwCache(address + 4, ((value.getCurrentDouble().toRawBits() shr 32) and 0xFFFFFFFF).toInt())\r\n        }\r\n//        store64 = NoImplementation,\r\n//        store128 = NoImplementation\r\n)"," package venusbackend.riscv.insts.integer.base.i.ecall\r\n\r\nimport venus.Renderer\r\nimport venusbackend.compareTo\r\nimport venusbackend.inc\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.Registers\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.DoNothingParser\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.simulator.FilesHandler\r\nimport venusbackend.simulator.Simulator\r\n\r\nval ecall = Instruction(\r\n    // Fixme The long and quadword are only build for a 32 bit system!\r\n        name = \"ecall\",\r\n        format = InstructionFormat(4,\r\n                listOf(FieldEqual(InstructionField.ENTIRE, 0b000000000000_00000_000_00000_1110011))\r\n        ),\r\n        parser = DoNothingParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val whichCall = sim.getReg(Registers.a0)\r\n            when (whichCall) {\r\n                1 -> printInteger(sim)\r\n                4 -> printString(sim)\r\n                5 -> atoi(sim)\r\n                9 -> sbrk(sim)\r\n                10 -> exit(sim)\r\n                11 -> printChar(sim)\r\n                13 -> openFile(sim)\r\n                14 -> readFile(sim)\r\n                15 -> writeFile(sim)\r\n                16 -> closeFile(sim)\r\n                17 -> exitWithCode(sim)\r\n                18 -> fflush(sim)\r\n                19 -> feof(sim)\r\n                20 -> ferror(sim)\r\n                34 -> printHex(sim)\r\n                0x3CC -> clib(sim)\r\n                else -> Renderer.printConsole(\"Invalid ecall $whichCall\")\r\n            }\r\n            if (!(whichCall == 10 || whichCall == 17)) {\r\n                sim.incrementPC(mcode.length)\r\n            }\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val whichCall = sim.getReg(10).toLong()\r\n            when (whichCall) {\r\n                1L -> printInteger(sim)\r\n                4L -> printString(sim)\r\n                5L -> atoi(sim)\r\n                9L -> sbrk(sim)\r\n                10L -> exit(sim)\r\n                11L -> printChar(sim)\r\n                13L -> openFile(sim)\r\n                14L -> readFile(sim)\r\n                15L -> writeFile(sim)\r\n                16L -> closeFile(sim)\r\n                17L -> exitWithCode(sim)\r\n                18L -> fflush(sim)\r\n                19L -> feof(sim)\r\n                20L -> ferror(sim)\r\n                34L -> printHex(sim)\r\n                else -> Renderer.printConsole(\"Invalid ecall $whichCall\")\r\n            }\r\n            if (!(whichCall == 10L || whichCall == 17L)) {\r\n                sim.incrementPC(mcode.length)\r\n            }\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val whichCall = sim.getReg(10).toQuadWord()\r\n            when (whichCall) {\r\n                QuadWord(1) -> printInteger(sim)\r\n                QuadWord(4) -> printString(sim)\r\n                QuadWord(5) -> atoi(sim)\r\n                QuadWord(9) -> sbrk(sim)\r\n                QuadWord(10) -> exit(sim)\r\n                QuadWord(11) -> printChar(sim)\r\n                QuadWord(13) -> openFile(sim)\r\n                QuadWord(14) -> readFile(sim)\r\n                QuadWord(15) -> writeFile(sim)\r\n                QuadWord(16) -> closeFile(sim)\r\n                QuadWord(17) -> exitWithCode(sim)\r\n                QuadWord(18) -> fflush(sim)\r\n                QuadWord(19) -> feof(sim)\r\n                QuadWord(20) -> ferror(sim)\r\n                QuadWord(34) -> printHex(sim)\r\n                else -> Renderer.printConsole(\"Invalid ecall $whichCall\")\r\n            }\r\n            if (!(whichCall == QuadWord(10) || whichCall == QuadWord(17))) {\r\n                sim.incrementPC(mcode.length)\r\n            }\r\n        },\r\n        disasm = RawDisassembler { \"ecall\" }\r\n)\r\n\r\nenum class Syscall(val syscall: Int) {\r\n    PRINT_INT(1),\r\n    PRINT_STR(4),\r\n    ATOI(5),\r\n    SBRK(9),\r\n    EXIT(10),\r\n    PRINT_CHAR(11),\r\n    OPEN(13),\r\n    READ(14),\r\n    WRITE(15),\r\n    CLOSE(16),\r\n    EXIT_WITH_CODE(17),\r\n    FLUSH(18),\r\n    FEOF(19),\r\n    FERROR(20),\r\n    PRINT_HEX(34)\r\n}\r\n\r\n// All file operations will return -1 if the file descriptor is not found.\r\nprivate fun openFile(sim: Simulator) {\r\n    /**\r\n     * Attempt to open the file with the lowest number to return first. If cannot open file, return -1.\r\n     * Look here for the permissionbits:https://en.cppreference.com/w/c/io/fopen\r\n     *\r\n     * a0=13,a1=filename,a2=permissionbits -> a0=filedescriptor\r\n     */\r\n    val filenameAddress = sim.getReg(Registers.a1).toInt()\r\n    val permissions = sim.getReg(Registers.a2).toInt()\r\n    val filename = getString(sim, filenameAddress)\r\n    val fdID = sim.filesHandler.openFile(sim, filename, permissions)\r\n    sim.setReg(Registers.a0, fdID)\r\n}\r\n\r\nprivate fun readFile(sim: Simulator) {\r\n    /**\r\n     * Check file descriptor and check if we have the valid permissions.\r\n     * If we can read from the file, start reading at the offset (default=0)\r\n     * and increment the offset by the bytes read. Return the number of bytes which were read.\r\n     * User will call feof(fd) or ferror(fd) for if the output is not equal to the length.\r\n     *\r\n     * a0=14, a1=filedescriptor, a2=where to store data, a3=amt to read -> a0=Number of items read\r\n     */\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val bufferAddress = sim.getReg(Registers.a2).toInt()\r\n    val size = sim.getReg(Registers.a3).toInt()\r\n    if (size < 0) {\r\n        sim.setReg(Registers.a0, FilesHandler.EOF)\r\n        return\r\n    }\r\n    val data = sim.filesHandler.readFileDescriptor(fdID, size)\r\n    var offset = 0\r\n    if (data != null) {\r\n        for (c in data) {\r\n            sim.storeBytewCache(bufferAddress + offset, c.toInt())\r\n            offset++\r\n        }\r\n        sim.setReg(Registers.a0, offset)\r\n    } else {\r\n        sim.setReg(Registers.a0, FilesHandler.EOF)\r\n    }\r\n}\r\n\r\nprivate fun writeFile(sim: Simulator) {\r\n    /**\r\n     * a0=15, a1=filedescriptor, a2=buffer to read data, a3=amt to write, a4=size of each item -> a0=Number of items written\r\n     */\r\n    // FIXME This needs to be redone to handle different possible errors for results. Currently this is fine due to the error which can be produced.\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val bufferAddress = sim.getReg(Registers.a2).toInt()\r\n    val sizeOfItem = sim.getReg(Registers.a4).toInt()\r\n    val size = sim.getReg(Registers.a3).toInt() * sizeOfItem\r\n    if (size < 0) {\r\n        sim.setReg(Registers.a0, FilesHandler.EOF)\r\n        return\r\n    }\r\n    var offset = 0\r\n    val sb = StringBuilder()\r\n    while (offset < size) {\r\n        var addr = bufferAddress + offset\r\n        var byte = sim.loadByte(addr).toShort()\r\n        var char = byte.toChar()\r\n        sb.append(char)\r\n        offset++\r\n    }\r\n    val s = sb.toString()\r\n    var result = sim.filesHandler.writeFileDescriptor(fdID, s)\r\n    if (result != FilesHandler.EOF) {\r\n        result /= sizeOfItem\r\n    }\r\n    sim.setReg(Registers.a0, result)\r\n}\r\n\r\nprivate fun seekFile(sim: Simulator) {\r\n//\r\n}\r\n\r\nprivate fun tellFile(sim: Simulator) {\r\n//\r\n}\r\n\r\nprivate fun closeFile(sim: Simulator) {\r\n    /**\r\n     * Flush the data written to the file back to where it came from.\r\n     * a0=16, a1=filedescriptor -> \u200b0\u200b on success, EOF otherwise\r\n     */\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val a0 = sim.filesHandler.closeFileDescriptor(fdID)\r\n    sim.setReg(Registers.a0, a0)\r\n}\r\n\r\nprivate fun fflush(sim: Simulator) {\r\n    /**\r\n     * Returns zero on success. Otherwise EOF is returned and the error indicator of the file stream is set.\r\n     * a0=19, a1=filedescriptor -> a0=if end of file\r\n     */\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val a0 = sim.filesHandler.flushFileDescriptor(fdID)\r\n    sim.setReg(Registers.a0, a0)\r\n}\r\n\r\nprivate fun feof(sim: Simulator) {\r\n    /**\r\n     * Will return nonzero value if the end of the stream has been reached, otherwise \u200b0\u200b\r\n     *\r\n     * a0=19, a1=filedescriptor -> a0=if end of file\r\n     */\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val a0 = sim.filesHandler.getFileDescriptorEOF(fdID)\r\n    sim.setReg(Registers.a0, a0)\r\n}\r\n\r\nprivate fun ferror(sim: Simulator) {\r\n    /**\r\n     * Will return Nonzero value if the file stream has errors occurred, \u200b0\u200b otherwise\r\n     *\r\n     * a0=20, a1=filedescriptor -> a0=if error occured\r\n     */\r\n    val fdID = sim.getReg(Registers.a1).toInt()\r\n    val a0 = sim.filesHandler.getFileDescriptorError(fdID)\r\n    sim.setReg(Registers.a0, a0)\r\n}\r\n\r\nprivate fun printHex(sim: Simulator) {\r\n    val arg = sim.getReg(11)\r\n    sim.ecallMsg = Renderer.toHex(arg)\r\n    Renderer.printConsole(sim.ecallMsg)\r\n}\r\n\r\nprivate fun printInteger(sim: Simulator) {\r\n    val arg = sim.getReg(11)\r\n    sim.ecallMsg = arg.toString()\r\n    Renderer.printConsole(sim.ecallMsg)\r\n}\r\n\r\nprivate fun printString(sim: Simulator) {\r\n    val arg = sim.getReg(11)\r\n    val s = getString(sim, arg)\r\n    sim.ecallMsg += s\r\n    Renderer.printConsole(s)\r\n}\r\n\r\nprivate fun atoi(sim: Simulator) {\r\n    val str_pointer = sim.getReg(Registers.a1)\r\n    val s = getString(sim, str_pointer)\r\n    val n = try {\r\n        s.toInt()\r\n    } catch (e: NumberFormatException) {\r\n        0\r\n    }\r\n    sim.setReg(Registers.a0, n)\r\n}\r\n\r\nprivate fun sbrk(sim: Simulator) {\r\n    val bytes = sim.getReg(11)\r\n    if (bytes < 0) return\r\n    sim.setReg(10, sim.getHeapEnd())\r\n    sim.addHeapSpace(bytes)\r\n}\r\n\r\nprivate fun exit(sim: Simulator) {\r\n    sim.setPC(MemorySegments.STATIC_BEGIN)\r\n    sim.exitcode = 0\r\n    // sim.ecallMsg = \"exiting the simulator\"\r\n}\r\n\r\nprivate fun printChar(sim: Simulator) {\r\n    val arg = sim.getReg(11)\r\n    sim.ecallMsg = (arg.toChar()).toString()\r\n    Renderer.printConsole(arg.toChar())\r\n}\r\n\r\nprivate fun exitWithCode(sim: Simulator) {\r\n    sim.setPC(MemorySegments.STATIC_BEGIN)\r\n    val retVal = sim.getReg(11)\r\n    sim.exitcode = retVal.toInt()\r\n    sim.ecallMsg = \"\\nExited with error code $retVal\"\r\n    Renderer.printConsole(\"\\nExited with error code $retVal\\n\")\r\n}\r\n\r\nprivate fun memdump(sim: Simulator) {\r\n    /**\r\n     * Dumps Venus's state to the filename given as a pointer in a1. If a1 points to 0,\r\n     * then the name is set to \"venus.dump\"\r\n     *\r\n     * a0=22, a1=(optional)Filename pointer\r\n     */\r\n    val filepathptr = sim.getReg(Registers.a1)\r\n    val filepath = if (filepathptr == 0) {\r\n        \"venus.dump\"\r\n    } else {\r\n        getString(sim, filepathptr)\r\n    }\r\n    // TODO Complete me\r\n    var err = sim.VFS.touch(filepath)\r\n    if (err == \"\") {\r\n        err = sim.VFS.write(filepath, \"\")\r\n    }\r\n}\r\n\r\nprivate fun getString(sim: Simulator, address: Number): String {\r\n    var addr = address\r\n    val s = StringBuilder()\r\n    var c = sim.loadByte(address)\r\n    addr++\r\n    while (c != 0) {\r\n        s.append(c.toChar())\r\n        c = sim.loadByte(addr)\r\n        addr++\r\n    }\r\n    return s.toString()\r\n}\r\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\n\n@Suppress(\"NON_PUBLIC_PRIMARY_CONSTRUCTOR_OF_INLINE_CLASS\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /** Calculates the remainder of dividing this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /** Shifts this value left by the [bitCount] number of bits. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval div = RTypeInstruction(\r\n        name = \"div\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b100,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            if (b == 0.toShort()) -1\r\n            else if (a == Short.MIN_VALUE && b == (-1).toShort()) a\r\n            else (a / b).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            if (b == 0) -1\r\n            else if (a == Int.MIN_VALUE && b == -1) a\r\n            else a / b\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b == 0.toLong()) -1\r\n            else if (a == Long.MIN_VALUE && b == (-1).toLong()) a\r\n            else a / b\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b == 0.toQuadWord()) (-1).toQuadWord()\r\n            else if (a == QuadWord.MIN_VALUE && b == (-1).toQuadWord()) a\r\n            else a / b\r\n        }\r\n)\r\n","package venusbackend.riscv\r\n\r\nfun userStringToInt(s: String): Int {\r\n    if (isCharacterLiteral(s)) {\r\n        return characterLiteralToInt(s)\r\n    }\r\n\r\n    val radix = when {\r\n        s.startsWith(\"0x\") -> 16\r\n        s.startsWith(\"0b\") -> 2\r\n        s.drop(1).startsWith(\"0x\") -> 16\r\n        s.drop(1).startsWith(\"0b\") -> 2\r\n        else -> return s.toLong().toInt()\r\n    }\r\n\r\n    val skipSign = when (s.first()) {\r\n        '+', '-' -> 1\r\n        else -> 0\r\n    }\r\n\r\n    val noRadixString = s.take(skipSign) + s.drop(skipSign + 2)\r\n    return noRadixString.toLong(radix).toInt()\r\n}\r\n\r\nfun userStringToLong(s: String): Long {\r\n    if (isCharacterLiteral(s)) {\r\n        return characterLiteralToLong(s)\r\n    }\r\n\r\n    val radix = when {\r\n        s.startsWith(\"0x\") -> 16\r\n        s.startsWith(\"0b\") -> 2\r\n        s.drop(1).startsWith(\"0x\") -> 16\r\n        s.drop(1).startsWith(\"0b\") -> 2\r\n        else -> return s.toLong()\r\n    }\r\n\r\n    val skipSign = when (s.first()) {\r\n        '+', '-' -> 1\r\n        else -> 0\r\n    }\r\n\r\n    val noRadixString = s.take(skipSign) + s.drop(skipSign + 2)\r\n    return noRadixString.toLong(radix)\r\n}\r\n\r\nfun userStringToFloat(s: String): Float {\r\n    val radix = when {\r\n        s.startsWith(\"0x\") -> 16\r\n        s.startsWith(\"0b\") -> 2\r\n        s.drop(1).startsWith(\"0x\") -> 16\r\n        s.drop(1).startsWith(\"0b\") -> 2\r\n        else -> return s.toFloat()\r\n    }\r\n    var bits = userStringToInt(s)\r\n    val v = Float.fromBits(bits)\r\n    return v\r\n}\r\n\r\nfun userStringToDouble(s: String): Double {\r\n    val radix = when {\r\n        s.startsWith(\"0x\") -> 16\r\n        s.startsWith(\"0b\") -> 2\r\n        s.drop(1).startsWith(\"0x\") -> 16\r\n        s.drop(1).startsWith(\"0b\") -> 2\r\n        else -> return s.toDouble()\r\n    }\r\n    var bits = userStringToLong(s)\r\n    val v = Double.fromBits(bits)\r\n    return v\r\n}\r\n\r\nfun getBit(value: Number, position: Int): Int {\r\n    return ((value.toLong() shr position) and 1).toInt()\r\n}\r\n\r\nfun unescapeString(s: String) =\r\n        s.replace(\"\\\\n\", \"\\n\")\r\n                .replace(\"\\\\r\", \"\\r\")\r\n                .replace(\"\\\\t\", \"\\t\")\r\n                .replace(\"\\\\b\", \"\\b\")\r\n                .replace(\"\\\\\\\"\", \"\\\"\")\r\n                .replace(\"\\\\'\", \"'\")\r\n\r\nfun isNumeral(s: String): Boolean {\r\n    try {\r\n        userStringToInt(s)\r\n        return true\r\n    } catch (e: NumberFormatException) {\r\n        return false\r\n    }\r\n}\r\n\r\nprivate fun isCharacterLiteral(s: String) =\r\n        s.first() == '\\'' && s.last() == '\\''\r\n\r\nprivate fun characterLiteralToInt(s: String): Int {\r\n    val stripSingleQuotes = s.drop(1).dropLast(1)\r\n    if (stripSingleQuotes == \"\\\\'\") return '\\''.toInt()\r\n    if (stripSingleQuotes == \"\\\"\") return '\"'.toInt()\r\n\r\n    try {\r\n        val parsed = unescapeString(stripSingleQuotes)\r\n        if (parsed.isEmpty()) throw NumberFormatException(\"character literal $s is empty\")\r\n        if (parsed.length > 1) throw NumberFormatException(\"character literal $s too long\")\r\n        return parsed[0].toInt()\r\n    } catch (e: Throwable) {\r\n        throw NumberFormatException(\"could not parse character literal $s\")\r\n    }\r\n}\r\n\r\nprivate fun characterLiteralToLong(s: String): Long {\r\n    val stripSingleQuotes = s.drop(1).dropLast(1)\r\n    if (stripSingleQuotes == \"\\\\'\") return '\\''.toLong()\r\n    if (stripSingleQuotes == \"\\\"\") return '\"'.toLong()\r\n\r\n    try {\r\n        val parsed = unescapeString(stripSingleQuotes)\r\n        if (parsed.isEmpty()) throw NumberFormatException(\"character literal $s is empty\")\r\n        if (parsed.length > 1) throw NumberFormatException(\"character literal $s too long\")\r\n        return parsed[0].toLong()\r\n    } catch (e: Throwable) {\r\n        throw NumberFormatException(\"could not parse character literal $s\")\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length)))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the desired action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\npublic fun CharSequence.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\npublic fun CharSequence.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n",null,"package venusbackend.simulator\r\n\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.cache.CacheHandler\r\n\r\nclass SimulatorState64 : SimulatorState {\r\n    /*Register 32 is the special register.*/\r\n    private val regs64 = Array(33) { 0.toLong() }\r\n    private val fregs = Array(33) { Decimal() }\r\n    private var pc: Long = 0\r\n    private var maxpc: Long = MemorySegments.TEXT_BEGIN.toLong()\r\n    private var heapEnd = MemorySegments.HEAP_BEGIN.toLong()\r\n\r\n    override val registerWidth = 64\r\n    override var mem = Memory()\r\n    override var cache = CacheHandler(1)\r\n    override fun setCacheHandler(ch: CacheHandler) {\r\n        cache = ch\r\n    }\r\n    override fun setPC(location: Number) {\r\n        this.pc = location.toLong()\r\n    }\r\n    override fun getPC(): Number {\r\n        return this.pc\r\n    }\r\n    override fun incPC(amount: Number) {\r\n        this.pc += amount.toLong()\r\n    }\r\n    override fun setMaxPC(location: Number) {\r\n        this.maxpc = location.toLong()\r\n    }\r\n    override fun getMaxPC(): Number {\r\n        return this.maxpc\r\n    }\r\n    override fun incMaxPC(amount: Number) {\r\n        this.maxpc = (this.maxpc + amount.toLong())\r\n    }\r\n    override fun getReg(i: Int) = regs64[i]\r\n    override fun setReg(i: Int, v: Number) { if (i != 0) regs64[i] = v.toLong() }\r\n    override fun getFReg(i: Int) = fregs[i]\r\n    override fun setFReg(i: Int, v: Decimal) { fregs[i] = v }\r\n    override fun getHeapEnd(): Number {\r\n        return heapEnd\r\n    }\r\n\r\n    override fun setHeapEnd(i: Number) {\r\n        heapEnd = i.toLong()\r\n    }\r\n\r\n    override fun incHeapEnd(amount: Number) {\r\n        heapEnd += amount.toLong()\r\n    }\r\n\r\n    override fun reset() {\r\n        this.cache.reset()\r\n    }\r\n}\r\n","package venus.api\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport org.w3c.dom.*\r\nimport venus.Driver\r\nimport venus.Renderer\r\nimport kotlin.browser.document\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.hasClass\r\n\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n@JsName(\"API\") object API {\r\n    // The key (String) is the ID of the FunctionsList\r\n    val functionsLists: MutableMap<String, FunctionsList> = HashMap()\r\n\r\n    @JsName(\"addList\") fun addList(s: String) {\r\n        functionsLists[s] = FunctionsList(s)\r\n    }\r\n\r\n    @JsName(\"evalList\") fun evalList(s: String, args: Any?): Boolean {\r\n        return functionsLists[s]?.evalFunctions(args) ?: false\r\n    }\r\n\r\n    /**\r\n     * All functions should take in a single argument which is a javascript list of arguments.\r\n     * This list of arguments will differ depending on which function it uses.\r\n     */\r\n    @JsName(\"addListener\") fun addListener(locationID: String, pkgid: String, fnid: String, function: Function<Any?>) {\r\n        if (functionsLists.containsKey(locationID)) {\r\n            val f = functionsLists.get(locationID)\r\n            f?.add(\"$pkgid.$fnid\", function)\r\n            console.log(\"Added function to '$locationID'\")\r\n        } else {\r\n            console.error(\"Could not add function to '$locationID' because the location ID does not exist!\")\r\n        }\r\n    }\r\n\r\n    @JsName(\"removeListener\") fun removeListener(locationID: String, pkgid: String, fnid: String) {\r\n        if (functionsLists.containsKey(locationID)) {\r\n            val f = functionsLists.get(locationID)\r\n            f?.remove(\"$pkgid.$fnid\")\r\n            console.log(\"Remove function to '$locationID'\")\r\n        } else {\r\n            console.error(\"Could not remove function to '$locationID' because the location ID does not exist!\")\r\n        }\r\n    }\r\n\r\n    @JsName(\"addMainTab\") fun addMainTab(name: String): Element? {\r\n        if (Renderer.mainTabs.contains(name)) {\r\n            console.error(\"Tabs MUST have unique names!\")\r\n            return null\r\n        }\r\n        val t = document.createElement(\"li\")\r\n        t.id = \"$name-tab\"\r\n\r\n        val link = document.createElement(\"a\")\r\n        t.appendChild(link)\r\n        link.setAttribute(\"onclick\", \"driver.openGenericMainTab(\\\"$name\\\")\")\r\n\r\n        val font = document.createElement(\"font\")\r\n        link.appendChild(font)\r\n        val tmp = name\r\n        font.innerHTML = tmp.capitalize()\r\n\r\n        val tabs_list = document.getElementById(\"venus-main-tabs\") ?: return null\r\n        tabs_list.appendChild(t)\r\n\r\n        val s = document.createElement(\"section\")\r\n\r\n        s.addClass(\"section\")\r\n        s.id = \"$name-tab-view\"\r\n        s.setAttribute(\"style\", \"display:none;\")\r\n        document.body!!.appendChild(s)\r\n\r\n        Renderer.mainTabs.add(name)\r\n        s.innerHTML = \"TEST\"\r\n        return s\r\n    }\r\n\r\n    @JsName(\"addMainTabAndShow\") fun addMainTab(name: String, show: Boolean): Element? {\r\n        val s = addMainTab(name)\r\n        showMainTab(name)\r\n        return s\r\n    }\r\n\r\n    @JsName(\"showMainTab\") fun showMainTab(name: String): Boolean {\r\n        val tab = (document.getElementById(\"$name-tab\") ?: return false) as HTMLLIElement\r\n        tab.style.display = \"\"\r\n        return true\r\n    }\r\n\r\n    @JsName(\"hideMainTab\") fun hideMainTab(name: String): Boolean {\r\n        val tab = (document.getElementById(\"$name-tab\") ?: return false) as HTMLLIElement\r\n        tab.style.display = \"none\"\r\n        if (tab.hasClass(\"is-active\")) {\r\n            Driver.openVenus()\r\n        }\r\n        return true\r\n    }\r\n\r\n    @JsName(\"removeMainTab\") fun removeMainTab(name: String): Boolean {\r\n        val t = (document.getElementById(\"$name-tab\") ?: return false) as HTMLLIElement\r\n        val v = (document.getElementById(\"$name-tab-view\") ?: return false)\r\n        if (t.hasClass(\"is-active\")) {\r\n            hideMainTab(name)\r\n        }\r\n        Renderer.mainTabs.remove(name)\r\n        t.remove()\r\n        v.remove()\r\n        return true\r\n    }\r\n}","package venus.api\r\n\r\nclass FunctionsList(val id: String) {\r\n    private val fns = HashMap<String, Function<Any?>>()\r\n\r\n    fun add(id: String, f: Function<Any?>) {\r\n        fns[id] = f\r\n    }\r\n\r\n    fun remove(id: String) {\r\n        fns.remove(id)\r\n    }\r\n\r\n    fun evalFunctions(args: Any?): Boolean {\r\n        js(\"\"\"var a = [];\"\"\")\r\n        if (js(\"args.constructor === Array\") as Boolean) {\r\n            js(\"a = args;\")\r\n        } else {\r\n            if (args is Collection<Any?>) {\r\n                for (arg in args) {\r\n                    js(\"a.push(arg);\")\r\n                }\r\n            }\r\n        }\r\n        var rv = true\r\n        for (f in fns.values) {\r\n            val v = js(\"f(a)\")\r\n            if (jsTypeOf(v) !== \"undefined\") {\r\n                rv = rv && v\r\n            }\r\n        }\r\n        return rv\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n","package venus.api\r\n\r\nimport org.w3c.dom.get\r\nimport venus.Driver\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\nimport venus.Renderer\r\n\r\n/**\r\n* This is used to add and remove external packages.\r\n*/\r\n\r\n@JsName(\"ScriptManager\") object ScriptManager {\r\n    init {\r\n        js(\"\"\"\r\n            window.VenusScriptManager = this;\r\n            \"\"\")\r\n    }\r\n\r\n    var packages = HashMap<String, venuspackage>()\r\n\r\n    var loading_packages = HashSet<String>()\r\n\r\n    fun loadDefaults() {\r\n        val defpkgs = hashMapOf(\r\n                Pair(\"packages/tester.js\", false),\r\n                Pair(\"packages/disassembler.js\", false),\r\n                Pair(\"packages/chocopy.js\", true)\r\n        )\r\n\r\n        val pstr = Driver.LS.safeget(\"script_manager\", \"[]\")\r\n        val pkgs = JSON.parse<ArrayList<pkg>>(pstr)\r\n        var i = 0\r\n        while (js(\"i < pkgs.length\")) {\r\n            val p = js(\"pkgs[i]\")\r\n            if (defpkgs.containsKey(p.url)) {\r\n                defpkgs.set(p.url, p.enabled)\r\n            }\r\n            i++\r\n        }\r\n\r\n        for (pk in defpkgs) {\r\n            ScriptManager.addPackage(pk.key, enabled = pk.value, removable = false)\r\n        }\r\n    }\r\n\r\n    fun loadScript(url: String, onfail: String, onload: String) {\r\n        val urlelm = document.getElementById(url)\r\n        urlelm?.parentNode?.removeChild(urlelm)\r\n        val script = document.createElement(\"script\")\r\n        script.setAttribute(\"onerror\", onfail)\r\n        script.setAttribute(\"onload\", onload)\r\n        script.setAttribute(\"src\", url)\r\n        script.setAttribute(\"id\", url)\r\n        document.getElementsByTagName(\"head\")[0]?.appendChild(script)\r\n    }\r\n\r\n    fun addPackage(url: String, enabled: Boolean = true, removable: Boolean = true) {\r\n        val onfail = \"window.VenusScriptManager.addPackageFailure('$url');\"\r\n        val onload = \"window.VenusScriptManager.addPackageSuccess('$url', $enabled, $removable);\"\r\n        loadScript(url, onfail, onload)\r\n    }\r\n\r\n    @JsName(\"addPackageSuccess\") fun addPackageSuccess(url: String, en: Boolean = true, removable: Boolean = true) {\r\n        loading_packages.remove(url)\r\n        var enabled = en\r\n        if (venuspackage == undefined) {\r\n            addPackageFailure(url)\r\n            return\r\n        }\r\n        if (jsTypeOf(venuspackage.requires) != \"undefined\") {\r\n            if (js(\"venuspackage.requires.constructor === Array\")) {\r\n                var i = js(\"venuspackage.requires.length\")\r\n                while (i > 0) {\r\n                    var k = js(\"venuspackage.requires[i - 1]\")\r\n                    if (!packages.containsKey(k)) {\r\n                        val msg = \"This package requires '$k' which was not found in the currently installed packages! Thus it cannot be loaded!\"\r\n                        Renderer.pkgMsg(msg)\r\n                        console.warn(msg)\r\n                        addPackageFailure(url)\r\n                        return\r\n                    }\r\n                    i--\r\n                }\r\n            } else {\r\n                venuspackage.requires = js(\"[]\")\r\n            }\r\n        } else {\r\n            venuspackage.requires = js(\"[]\")\r\n        }\r\n        venuspackage.dependent = js(\"[]\")\r\n        if (packages.containsKey(venuspackage.id)) {\r\n            val orig = packages.get(venuspackage.id)\r\n            if (!orig!!.removable) {\r\n                js(\"window.venuspackage = undefined\")\r\n                throw Throwable(\"Cannot update a default script!\")\r\n            }\r\n            removePackage(venuspackage.id)\r\n        }\r\n        venuspackage.url = url\r\n        var i = js(\"window.venuspackage.requires.length\") as Int\r\n        while (i > 0) {\r\n            val k = js(\"window.venuspackage.requires[i - 1]\") as String\r\n            if (!((packages.get(k))?.enabled ?: true)) {\r\n                val msg = \"Could not enable package '${venuspackage.id}' because it requires a package which has been disabled ($k)!\"\r\n                Renderer.pkgMsg(msg)\r\n                console.warn(msg)\r\n                enabled = false\r\n            }\r\n            i--\r\n        }\r\n        val state = if (en) {\r\n            \"initenabled\"\r\n        } else {\r\n            \"initdisabled\"\r\n        }\r\n        var worked = true\r\n        if (enabled) {\r\n            js(\"\"\"\r\n            try {\r\n                window.venuspackage.load(state);\r\n            } catch (e) {\r\n                console.error(e);\r\n                worked = false\r\n                window.VenusScriptManager.addPackageFailure();\r\n            }\r\n        \"\"\")\r\n        }\r\n        if (worked) {\r\n            venuspackage.enabled = enabled\r\n            venuspackage.removable = removable\r\n            var i = js(\"venuspackage.requires.length\") as Int\r\n            while (i > 0) {\r\n                val k = js(\"venuspackage.requires[i - 1]\")\r\n                val p = packages[k]\r\n                js(\"p.dependent.push(venuspackage.id)\")\r\n                i--\r\n            }\r\n            Renderer.rendererAddPackage(venuspackage.id, enabled, removable)\r\n            packages.put(venuspackage.id, venuspackage)\r\n            updateLS()\r\n            val msg = \"Loaded script ($url)!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            js(\"window.venuspackage = undefined\")\r\n        }\r\n    }\r\n\r\n    @JsName(\"addPackageFailure\") fun addPackageFailure(url: String) {\r\n        loading_packages.remove(url)\r\n        val msg = \"Could not load the script ($url)!\"\r\n        Renderer.pkgMsg(msg)\r\n        console.warn(msg)\r\n        js(\"window.venuspackage = undefined\")\r\n    }\r\n\r\n    fun removePackage(id: String) {\r\n        var msg = \"Removing package '$id'!\"\r\n        Renderer.pkgMsg(msg)\r\n        if (Driver.debug) {\r\n            console.log(msg)\r\n        }\r\n        if (!packages.containsKey(id)) {\r\n            msg = \"Could not find package '$id'\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        disablePackage(id)\r\n        val p = packages.remove(id)\r\n        if (p != null) {\r\n            val s = document.getElementById(p.url)\r\n            if (s != null) {\r\n                s.parentElement?.removeChild(s)\r\n            }\r\n            var i = js(\"p.requires.length\") as Int\r\n            while (i > 0) {\r\n                val k = js(\"p.requires[i - 1]\")\r\n                val pk = packages[k]\r\n                js(\"\"\"try {\r\n                        pk.dependent.pop(k);\r\n                    } catch (e) {console.error(e);}\"\"\")\r\n                i--\r\n            }\r\n            i = js(\"p.dependent.length\") as Int\r\n            while (i > 0) {\r\n                val k = js(\"p.dependent[i - 1]\")\r\n                removePackage(k)\r\n                i--\r\n            }\r\n        }\r\n        var worked = true\r\n        js(\"\"\"\r\n            try {\r\n                p.unload('remove');\r\n            } catch (e) {\r\n                console.error(e);\r\n                worked = false;\r\n            }\r\n            \"\"\")\r\n        updateLS()\r\n        if (worked) {\r\n            Renderer.rendererRemovePackage(id)\r\n            msg = \"Package '$id' uninstalled successfully!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        } else {\r\n            Renderer.rendererUpdatePackage(id, false)\r\n            msg = \"Could not remove package '$id'!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun disablePackage(id: String) {\r\n        var msg = \"Disabling package '$id'!\"\r\n        Renderer.pkgMsg(msg)\r\n        if (Driver.debug) {\r\n            console.log(msg)\r\n        }\r\n        if (!packages.containsKey(id)) {\r\n            msg = \"Could not find package '$id'\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        val p = packages.get(id)\r\n        if (p?.enabled == false) {\r\n            msg = \"Package '$id' is already disabled!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        var worked = true\r\n        js(\"\"\"\r\n            try {\r\n                p.unload('disable');\r\n            } catch (e) {\r\n                console.error(e);\r\n                worked = false;\r\n            }\r\n            \"\"\")\r\n        if (worked) {\r\n            p?.enabled = false\r\n            Renderer.rendererUpdatePackage(id, false)\r\n            updateLS()\r\n            var i = js(\"p.dependent.length\") as Int\r\n            while (i > 0) {\r\n                val k = js(\"p.dependent[i - 1]\")\r\n                disablePackage(k)\r\n                i--\r\n            }\r\n            msg = \"Successfully disable package '$id'!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        } else {\r\n            Renderer.rendererUpdatePackage(id, true)\r\n            msg = \"Could not disable package '$id'!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun enablePackage(id: String) {\r\n        var msg = \"Enabling package '$id'!\"\r\n        Renderer.pkgMsg(msg)\r\n        if (Driver.debug) {\r\n            console.log(msg)\r\n        }\r\n        if (!packages.containsKey(id)) {\r\n            msg = \"Could not find package '$id'\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        val p = packages.get(id)\r\n        if (p?.enabled == true) {\r\n            msg = \"Package '$id' is already enabled!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        var i = js(\"p.requires.length\") as Int\r\n        while (i > 0) {\r\n            val k = js(\"p.requires[i - 1]\") as String\r\n            if (!((packages.get(k))?.enabled ?: true)) {\r\n                val msg = \"Could not enable package '${p?.id}' because it requires a package which has been disabled ($k)!\"\r\n                Renderer.pkgMsg(msg)\r\n                console.warn(msg)\r\n                Renderer.rendererUpdatePackage(id, false)\r\n                return\r\n            }\r\n            i--\r\n        }\r\n        var worked = true\r\n        js(\"\"\"\r\n            try {\r\n                p.load('enabled');\r\n            } catch (e) {\r\n                console.error(e);\r\n                worked = false;\r\n            }\r\n            \"\"\")\r\n        if (worked) {\r\n            p?.enabled = true\r\n            Renderer.rendererUpdatePackage(id, true)\r\n            updateLS()\r\n            msg = \"Successfully enabled package '$id'!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        } else {\r\n            Renderer.rendererUpdatePackage(id, false)\r\n            msg = \"Could not enable package '$id'!\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun togglePackage(id: String) {\r\n        var msg = \"Toggling package '$id'!\"\r\n        Renderer.pkgMsg(msg)\r\n        if (Driver.debug) {\r\n            console.log(msg)\r\n        }\r\n        if (!packages.containsKey(id)) {\r\n            msg = \"Could not find package '$id'\"\r\n            Renderer.pkgMsg(msg)\r\n            if (Driver.debug) {\r\n                console.log(msg)\r\n            }\r\n            return\r\n        }\r\n        val p = packages.get(id)\r\n        if (p?.enabled == true) {\r\n            disablePackage(p.id)\r\n        } else {\r\n            enablePackage(p?.id ?: \"\")\r\n        }\r\n    }\r\n\r\n    fun updateLS() {\r\n        val l = ArrayList<pkg>()\r\n        for (p in packages.values) {\r\n            val n = pkg(p.id, p.url, p.enabled, p.removable)\r\n            l.add(n)\r\n        }\r\n        Driver.LS.set(\"script_manager\", JSON.stringify(l))\r\n    }\r\n\r\n    fun loadPackages() {\r\n        val pstr = Driver.LS.safeget(\"script_manager\", \"[]\")\r\n        val pkgs = JSON.parse<ArrayList<pkg>>(pstr)\r\n        var i = 0\r\n        while (js(\"i < pkgs.length\")) {\r\n            val p = js(\"pkgs[i]\")\r\n            if (p.removable) {\r\n                addPackage(p.url, p.enabled, p.removable)\r\n            } else {\r\n                loadPKGTimeout(p.id, p.enabled)\r\n            }\r\n            loading_packages.add(p.url)\r\n            i++\r\n        }\r\n    }\r\n\r\n    fun packagesLoading(): Boolean {\r\n        return loading_packages.isNotEmpty()\r\n    }\r\n\r\n    fun loadPKGTimeout(id: String, enabled: Boolean) {\r\n        if (packages.containsKey(id)) {\r\n            if (enabled) {\r\n                enablePackage(id)\r\n            } else {\r\n                disablePackage(id)\r\n            }\r\n        } else {\r\n            window.setTimeout(ScriptManager::loadPKGTimeout, 100, id, enabled)\r\n        }\r\n    }\r\n}\r\n\r\nclass pkg(\r\n    var id: String = \"\",\r\n    var url: String = \"\",\r\n    var enabled: Boolean = false,\r\n    var removable: Boolean = true\r\n)\r\n\r\nexternal object venuspackage {\r\n    val id: String\r\n    var url: String\r\n    var enabled: Boolean\r\n    var removable: Boolean\r\n    val load: Function<Unit>\r\n    val unload: Function<Unit>\r\n    var requires: List<String>\r\n    var dependent: MutableList<String>\r\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.dom\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external abstract class HTMLAllCollection {\n    open val length: Int\n    fun item(nameOrIndex: String = definedExternally): UnionElementOrHTMLCollection?\n    fun namedItem(name: String): UnionElementOrHTMLCollection?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLAllCollection.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLAllCollection.get(name: String): UnionElementOrHTMLCollection? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLFormControlsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLFormControlsCollection) to Kotlin\n */\npublic external abstract class HTMLFormControlsCollection : HTMLCollection\n\n/**\n * Exposes the JavaScript [RadioNodeList](https://developer.mozilla.org/en/docs/Web/API/RadioNodeList) to Kotlin\n */\npublic external abstract class RadioNodeList : NodeList, UnionElementOrRadioNodeList {\n    open var value: String\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionsCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionsCollection) to Kotlin\n */\npublic external abstract class HTMLOptionsCollection : HTMLCollection {\n    override var length: Int\n    open var selectedIndex: Int\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally)\n    fun remove(index: Int)\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLOptionsCollection.set(index: Int, option: HTMLOptionElement?) { asDynamic()[index] = option }\n\n/**\n * Exposes the JavaScript [HTMLElement](https://developer.mozilla.org/en/docs/Web/API/HTMLElement) to Kotlin\n */\npublic external abstract class HTMLElement : Element, GlobalEventHandlers, DocumentAndElementEventHandlers, ElementContentEditable, ElementCSSInlineStyle {\n    open var title: String\n    open var lang: String\n    open var translate: Boolean\n    open var dir: String\n    open val dataset: DOMStringMap\n    open var hidden: Boolean\n    open var tabIndex: Int\n    open var accessKey: String\n    open val accessKeyLabel: String\n    open var draggable: Boolean\n    open val dropzone: DOMTokenList\n    open var contextMenu: HTMLMenuElement?\n    open var spellcheck: Boolean\n    open var innerText: String\n    open val offsetParent: Element?\n    open val offsetTop: Int\n    open val offsetLeft: Int\n    open val offsetWidth: Int\n    open val offsetHeight: Int\n    fun click()\n    fun focus()\n    fun blur()\n    fun forceSpellCheck()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLUnknownElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUnknownElement) to Kotlin\n */\npublic external abstract class HTMLUnknownElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMStringMap](https://developer.mozilla.org/en/docs/Web/API/DOMStringMap) to Kotlin\n */\npublic external abstract class DOMStringMap\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMStringMap.get(name: String): String? = asDynamic()[name]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMStringMap.set(name: String, value: String) { asDynamic()[name] = value }\n\n/**\n * Exposes the JavaScript [HTMLHtmlElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHtmlElement) to Kotlin\n */\npublic external abstract class HTMLHtmlElement : HTMLElement {\n    open var version: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadElement) to Kotlin\n */\npublic external abstract class HTMLHeadElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTitleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTitleElement) to Kotlin\n */\npublic external abstract class HTMLTitleElement : HTMLElement {\n    open var text: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBaseElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBaseElement) to Kotlin\n */\npublic external abstract class HTMLBaseElement : HTMLElement {\n    open var href: String\n    open var target: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLinkElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLinkElement) to Kotlin\n */\npublic external abstract class HTMLLinkElement : HTMLElement, LinkStyle {\n    open var href: String\n    open var crossOrigin: String?\n    open var rel: String\n    open var `as`: RequestDestination\n    open val relList: DOMTokenList\n    open var media: String\n    open var nonce: String\n    open var hreflang: String\n    open var type: String\n    open val sizes: DOMTokenList\n    open var referrerPolicy: String\n    open var charset: String\n    open var rev: String\n    open var target: String\n    open var scope: String\n    open var workerType: WorkerType\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMetaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMetaElement) to Kotlin\n */\npublic external abstract class HTMLMetaElement : HTMLElement {\n    open var name: String\n    open var httpEquiv: String\n    open var content: String\n    open var scheme: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLStyleElement](https://developer.mozilla.org/en/docs/Web/API/HTMLStyleElement) to Kotlin\n */\npublic external abstract class HTMLStyleElement : HTMLElement, LinkStyle {\n    open var media: String\n    open var nonce: String\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBodyElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBodyElement) to Kotlin\n */\npublic external abstract class HTMLBodyElement : HTMLElement, WindowEventHandlers {\n    open var text: String\n    open var link: String\n    open var vLink: String\n    open var aLink: String\n    open var bgColor: String\n    open var background: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHeadingElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHeadingElement) to Kotlin\n */\npublic external abstract class HTMLHeadingElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLParagraphElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParagraphElement) to Kotlin\n */\npublic external abstract class HTMLParagraphElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLHRElement) to Kotlin\n */\npublic external abstract class HTMLHRElement : HTMLElement {\n    open var align: String\n    open var color: String\n    open var noShade: Boolean\n    open var size: String\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLPreElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPreElement) to Kotlin\n */\npublic external abstract class HTMLPreElement : HTMLElement {\n    open var width: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLQuoteElement](https://developer.mozilla.org/en/docs/Web/API/HTMLQuoteElement) to Kotlin\n */\npublic external abstract class HTMLQuoteElement : HTMLElement {\n    open var cite: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOListElement) to Kotlin\n */\npublic external abstract class HTMLOListElement : HTMLElement {\n    open var reversed: Boolean\n    open var start: Int\n    open var type: String\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLUListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLUListElement) to Kotlin\n */\npublic external abstract class HTMLUListElement : HTMLElement {\n    open var compact: Boolean\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLIElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLIElement) to Kotlin\n */\npublic external abstract class HTMLLIElement : HTMLElement {\n    open var value: Int\n    open var type: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDListElement) to Kotlin\n */\npublic external abstract class HTMLDListElement : HTMLElement {\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDivElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDivElement) to Kotlin\n */\npublic external abstract class HTMLDivElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAnchorElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAnchorElement) to Kotlin\n */\npublic external abstract class HTMLAnchorElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var hreflang: String\n    open var type: String\n    open var text: String\n    open var referrerPolicy: String\n    open var coords: String\n    open var charset: String\n    open var name: String\n    open var rev: String\n    open var shape: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLDataElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataElement) to Kotlin\n */\npublic external abstract class HTMLDataElement : HTMLElement {\n    open var value: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTimeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTimeElement) to Kotlin\n */\npublic external abstract class HTMLTimeElement : HTMLElement {\n    open var dateTime: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSpanElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSpanElement) to Kotlin\n */\npublic external abstract class HTMLSpanElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLBRElement](https://developer.mozilla.org/en/docs/Web/API/HTMLBRElement) to Kotlin\n */\npublic external abstract class HTMLBRElement : HTMLElement {\n    open var clear: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLHyperlinkElementUtils](https://developer.mozilla.org/en/docs/Web/API/HTMLHyperlinkElementUtils) to Kotlin\n */\npublic external interface HTMLHyperlinkElementUtils {\n    var href: String\n    val origin: String\n    var protocol: String\n    var username: String\n    var password: String\n    var host: String\n    var hostname: String\n    var port: String\n    var pathname: String\n    var search: String\n    var hash: String\n}\n\n/**\n * Exposes the JavaScript [HTMLModElement](https://developer.mozilla.org/en/docs/Web/API/HTMLModElement) to Kotlin\n */\npublic external abstract class HTMLModElement : HTMLElement {\n    open var cite: String\n    open var dateTime: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLPictureElement](https://developer.mozilla.org/en/docs/Web/API/HTMLPictureElement) to Kotlin\n */\npublic external abstract class HTMLPictureElement : HTMLElement {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSourceElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSourceElement) to Kotlin\n */\npublic external abstract class HTMLSourceElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var srcset: String\n    open var sizes: String\n    open var media: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLImageElement](https://developer.mozilla.org/en/docs/Web/API/HTMLImageElement) to Kotlin\n */\npublic external abstract class HTMLImageElement : HTMLElement, HTMLOrSVGImageElement, TexImageSource {\n    open var alt: String\n    open var src: String\n    open var srcset: String\n    open var sizes: String\n    open var crossOrigin: String?\n    open var useMap: String\n    open var isMap: Boolean\n    open var width: Int\n    open var height: Int\n    open val naturalWidth: Int\n    open val naturalHeight: Int\n    open val complete: Boolean\n    open val currentSrc: String\n    open var referrerPolicy: String\n    open var name: String\n    open var lowsrc: String\n    open var align: String\n    open var hspace: Int\n    open var vspace: Int\n    open var longDesc: String\n    open var border: String\n    open val x: Int\n    open val y: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLIFrameElement](https://developer.mozilla.org/en/docs/Web/API/HTMLIFrameElement) to Kotlin\n */\npublic external abstract class HTMLIFrameElement : HTMLElement {\n    open var src: String\n    open var srcdoc: String\n    open var name: String\n    open val sandbox: DOMTokenList\n    open var allowFullscreen: Boolean\n    open var allowUserMedia: Boolean\n    open var width: String\n    open var height: String\n    open var referrerPolicy: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var align: String\n    open var scrolling: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var marginHeight: String\n    open var marginWidth: String\n    fun getSVGDocument(): Document?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLEmbedElement](https://developer.mozilla.org/en/docs/Web/API/HTMLEmbedElement) to Kotlin\n */\npublic external abstract class HTMLEmbedElement : HTMLElement {\n    open var src: String\n    open var type: String\n    open var width: String\n    open var height: String\n    open var align: String\n    open var name: String\n    fun getSVGDocument(): Document?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLObjectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLObjectElement) to Kotlin\n */\npublic external abstract class HTMLObjectElement : HTMLElement {\n    open var data: String\n    open var type: String\n    open var typeMustMatch: Boolean\n    open var name: String\n    open var useMap: String\n    open val form: HTMLFormElement?\n    open var width: String\n    open var height: String\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open var align: String\n    open var archive: String\n    open var code: String\n    open var declare: Boolean\n    open var hspace: Int\n    open var standby: String\n    open var vspace: Int\n    open var codeBase: String\n    open var codeType: String\n    open var border: String\n    fun getSVGDocument(): Document?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLParamElement](https://developer.mozilla.org/en/docs/Web/API/HTMLParamElement) to Kotlin\n */\npublic external abstract class HTMLParamElement : HTMLElement {\n    open var name: String\n    open var value: String\n    open var type: String\n    open var valueType: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLVideoElement](https://developer.mozilla.org/en/docs/Web/API/HTMLVideoElement) to Kotlin\n */\npublic external abstract class HTMLVideoElement : HTMLMediaElement, CanvasImageSource, TexImageSource {\n    open var width: Int\n    open var height: Int\n    open val videoWidth: Int\n    open val videoHeight: Int\n    open var poster: String\n    open var playsInline: Boolean\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAudioElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAudioElement) to Kotlin\n */\npublic external abstract class HTMLAudioElement : HTMLMediaElement {\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTrackElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTrackElement) to Kotlin\n */\npublic external abstract class HTMLTrackElement : HTMLElement {\n    open var kind: String\n    open var src: String\n    open var srclang: String\n    open var label: String\n    open var default: Boolean\n    open val readyState: Short\n    open val track: TextTrack\n\n    companion object {\n        val NONE: Short\n        val LOADING: Short\n        val LOADED: Short\n        val ERROR: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMediaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMediaElement) to Kotlin\n */\npublic external abstract class HTMLMediaElement : HTMLElement {\n    open val error: MediaError?\n    open var src: String\n    open var srcObject: dynamic\n    open val currentSrc: String\n    open var crossOrigin: String?\n    open val networkState: Short\n    open var preload: String\n    open val buffered: TimeRanges\n    open val readyState: Short\n    open val seeking: Boolean\n    open var currentTime: Double\n    open val duration: Double\n    open val paused: Boolean\n    open var defaultPlaybackRate: Double\n    open var playbackRate: Double\n    open val played: TimeRanges\n    open val seekable: TimeRanges\n    open val ended: Boolean\n    open var autoplay: Boolean\n    open var loop: Boolean\n    open var controls: Boolean\n    open var volume: Double\n    open var muted: Boolean\n    open var defaultMuted: Boolean\n    open val audioTracks: AudioTrackList\n    open val videoTracks: VideoTrackList\n    open val textTracks: TextTrackList\n    fun load()\n    fun canPlayType(type: String): CanPlayTypeResult\n    fun fastSeek(time: Double)\n    fun getStartDate(): dynamic\n    fun play(): Promise<Unit>\n    fun pause()\n    fun addTextTrack(kind: TextTrackKind, label: String = definedExternally, language: String = definedExternally): TextTrack\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [MediaError](https://developer.mozilla.org/en/docs/Web/API/MediaError) to Kotlin\n */\npublic external abstract class MediaError {\n    open val code: Short\n\n    companion object {\n        val MEDIA_ERR_ABORTED: Short\n        val MEDIA_ERR_NETWORK: Short\n        val MEDIA_ERR_DECODE: Short\n        val MEDIA_ERR_SRC_NOT_SUPPORTED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [AudioTrackList](https://developer.mozilla.org/en/docs/Web/API/AudioTrackList) to Kotlin\n */\npublic external abstract class AudioTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): AudioTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun AudioTrackList.get(index: Int): AudioTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [AudioTrack](https://developer.mozilla.org/en/docs/Web/API/AudioTrack) to Kotlin\n */\npublic external abstract class AudioTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var enabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [VideoTrackList](https://developer.mozilla.org/en/docs/Web/API/VideoTrackList) to Kotlin\n */\npublic external abstract class VideoTrackList : EventTarget {\n    open val length: Int\n    open val selectedIndex: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): VideoTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun VideoTrackList.get(index: Int): VideoTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [VideoTrack](https://developer.mozilla.org/en/docs/Web/API/VideoTrack) to Kotlin\n */\npublic external abstract class VideoTrack : UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val id: String\n    open val kind: String\n    open val label: String\n    open val language: String\n    open var selected: Boolean\n}\n\npublic external abstract class TextTrackList : EventTarget {\n    open val length: Int\n    open var onchange: ((Event) -> dynamic)?\n    open var onaddtrack: ((TrackEvent) -> dynamic)?\n    open var onremovetrack: ((TrackEvent) -> dynamic)?\n    fun getTrackById(id: String): TextTrack?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TextTrackList.get(index: Int): TextTrack? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrack](https://developer.mozilla.org/en/docs/Web/API/TextTrack) to Kotlin\n */\npublic external abstract class TextTrack : EventTarget, UnionAudioTrackOrTextTrackOrVideoTrack {\n    open val kind: TextTrackKind\n    open val label: String\n    open val language: String\n    open val id: String\n    open val inBandMetadataTrackDispatchType: String\n    open var mode: TextTrackMode\n    open val cues: TextTrackCueList?\n    open val activeCues: TextTrackCueList?\n    open var oncuechange: ((Event) -> dynamic)?\n    fun addCue(cue: TextTrackCue)\n    fun removeCue(cue: TextTrackCue)\n}\n\npublic external abstract class TextTrackCueList {\n    open val length: Int\n    fun getCueById(id: String): TextTrackCue?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TextTrackCueList.get(index: Int): TextTrackCue? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [TextTrackCue](https://developer.mozilla.org/en/docs/Web/API/TextTrackCue) to Kotlin\n */\npublic external abstract class TextTrackCue : EventTarget {\n    open val track: TextTrack?\n    open var id: String\n    open var startTime: Double\n    open var endTime: Double\n    open var pauseOnExit: Boolean\n    open var onenter: ((Event) -> dynamic)?\n    open var onexit: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin\n */\npublic external abstract class TimeRanges {\n    open val length: Int\n    fun start(index: Int): Double\n    fun end(index: Int): Double\n}\n\n/**\n * Exposes the JavaScript [TrackEvent](https://developer.mozilla.org/en/docs/Web/API/TrackEvent) to Kotlin\n */\npublic external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event {\n    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface TrackEventInit : EventInit {\n    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit {\n    val o = js(\"({})\")\n    o[\"track\"] = track\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin\n */\npublic external abstract class HTMLMapElement : HTMLElement {\n    open var name: String\n    open val areas: HTMLCollection\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLAreaElement) to Kotlin\n */\npublic external abstract class HTMLAreaElement : HTMLElement, HTMLHyperlinkElementUtils {\n    open var alt: String\n    open var coords: String\n    open var shape: String\n    open var target: String\n    open var download: String\n    open var ping: String\n    open var rel: String\n    open val relList: DOMTokenList\n    open var referrerPolicy: String\n    open var noHref: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableElement) to Kotlin\n */\npublic external abstract class HTMLTableElement : HTMLElement {\n    open var caption: HTMLTableCaptionElement?\n    open var tHead: HTMLTableSectionElement?\n    open var tFoot: HTMLTableSectionElement?\n    open val tBodies: HTMLCollection\n    open val rows: HTMLCollection\n    open var align: String\n    open var border: String\n    open var frame: String\n    open var rules: String\n    open var summary: String\n    open var width: String\n    open var bgColor: String\n    open var cellPadding: String\n    open var cellSpacing: String\n    fun createCaption(): HTMLTableCaptionElement\n    fun deleteCaption()\n    fun createTHead(): HTMLTableSectionElement\n    fun deleteTHead()\n    fun createTFoot(): HTMLTableSectionElement\n    fun deleteTFoot()\n    fun createTBody(): HTMLTableSectionElement\n    fun insertRow(index: Int = definedExternally): HTMLTableRowElement\n    fun deleteRow(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCaptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCaptionElement) to Kotlin\n */\npublic external abstract class HTMLTableCaptionElement : HTMLElement {\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableColElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableColElement) to Kotlin\n */\npublic external abstract class HTMLTableColElement : HTMLElement {\n    open var span: Int\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableSectionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableSectionElement) to Kotlin\n */\npublic external abstract class HTMLTableSectionElement : HTMLElement {\n    open val rows: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    fun insertRow(index: Int = definedExternally): HTMLElement\n    fun deleteRow(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableRowElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableRowElement) to Kotlin\n */\npublic external abstract class HTMLTableRowElement : HTMLElement {\n    open val rowIndex: Int\n    open val sectionRowIndex: Int\n    open val cells: HTMLCollection\n    open var align: String\n    open var ch: String\n    open var chOff: String\n    open var vAlign: String\n    open var bgColor: String\n    fun insertCell(index: Int = definedExternally): HTMLElement\n    fun deleteCell(index: Int)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTableCellElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTableCellElement) to Kotlin\n */\npublic external abstract class HTMLTableCellElement : HTMLElement {\n    open var colSpan: Int\n    open var rowSpan: Int\n    open var headers: String\n    open val cellIndex: Int\n    open var scope: String\n    open var abbr: String\n    open var align: String\n    open var axis: String\n    open var height: String\n    open var width: String\n    open var ch: String\n    open var chOff: String\n    open var noWrap: Boolean\n    open var vAlign: String\n    open var bgColor: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFormElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFormElement) to Kotlin\n */\npublic external abstract class HTMLFormElement : HTMLElement {\n    open var acceptCharset: String\n    open var action: String\n    open var autocomplete: String\n    open var enctype: String\n    open var encoding: String\n    open var method: String\n    open var name: String\n    open var noValidate: Boolean\n    open var target: String\n    open val elements: HTMLFormControlsCollection\n    open val length: Int\n    fun submit()\n    fun reset()\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLFormElement.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLFormElement.get(name: String): UnionElementOrRadioNodeList? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [HTMLLabelElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLabelElement) to Kotlin\n */\npublic external abstract class HTMLLabelElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var htmlFor: String\n    open val control: HTMLElement?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLInputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement) to Kotlin\n */\npublic external abstract class HTMLInputElement : HTMLElement {\n    open var accept: String\n    open var alt: String\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var defaultChecked: Boolean\n    open var checked: Boolean\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open val files: FileList?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var height: Int\n    open var indeterminate: Boolean\n    open var inputMode: String\n    open val list: HTMLElement?\n    open var max: String\n    open var maxLength: Int\n    open var min: String\n    open var minLength: Int\n    open var multiple: Boolean\n    open var name: String\n    open var pattern: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var size: Int\n    open var src: String\n    open var step: String\n    open var type: String\n    open var defaultValue: String\n    open var value: String\n    open var valueAsDate: dynamic\n    open var valueAsNumber: Double\n    open var width: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    open var align: String\n    open var useMap: String\n    fun stepUp(n: Int = definedExternally)\n    fun stepDown(n: Int = definedExternally)\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    fun select()\n    fun setRangeText(replacement: String)\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally)\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLButtonElement](https://developer.mozilla.org/en/docs/Web/API/HTMLButtonElement) to Kotlin\n */\npublic external abstract class HTMLButtonElement : HTMLElement {\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var formAction: String\n    open var formEnctype: String\n    open var formMethod: String\n    open var formNoValidate: Boolean\n    open var formTarget: String\n    open var name: String\n    open var type: String\n    open var value: String\n    open var menu: HTMLMenuElement?\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSelectElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSelectElement) to Kotlin\n */\npublic external abstract class HTMLSelectElement : HTMLElement, ItemArrayLike<Element> {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var multiple: Boolean\n    open var name: String\n    open var required: Boolean\n    open var size: Int\n    open val type: String\n    open val options: HTMLOptionsCollection\n    override var length: Int\n    open val selectedOptions: HTMLCollection\n    open var selectedIndex: Int\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun namedItem(name: String): HTMLOptionElement?\n    fun add(element: UnionHTMLOptGroupElementOrHTMLOptionElement, before: dynamic = definedExternally)\n    fun remove(index: Int)\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    override fun item(index: Int): Element?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLSelectElement.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLSelectElement.set(index: Int, option: HTMLOptionElement?) { asDynamic()[index] = option }\n\n/**\n * Exposes the JavaScript [HTMLDataListElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDataListElement) to Kotlin\n */\npublic external abstract class HTMLDataListElement : HTMLElement {\n    open val options: HTMLCollection\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOptGroupElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptGroupElement) to Kotlin\n */\npublic external abstract class HTMLOptGroupElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open var label: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOptionElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOptionElement) to Kotlin\n */\npublic external abstract class HTMLOptionElement : HTMLElement, UnionHTMLOptGroupElementOrHTMLOptionElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var label: String\n    open var defaultSelected: Boolean\n    open var selected: Boolean\n    open var value: String\n    open var text: String\n    open val index: Int\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTextAreaElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTextAreaElement) to Kotlin\n */\npublic external abstract class HTMLTextAreaElement : HTMLElement {\n    open var autocomplete: String\n    open var autofocus: Boolean\n    open var cols: Int\n    open var dirName: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var inputMode: String\n    open var maxLength: Int\n    open var minLength: Int\n    open var name: String\n    open var placeholder: String\n    open var readOnly: Boolean\n    open var required: Boolean\n    open var rows: Int\n    open var wrap: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val textLength: Int\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    open var selectionStart: Int?\n    open var selectionEnd: Int?\n    open var selectionDirection: String?\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n    fun select()\n    fun setRangeText(replacement: String)\n    fun setRangeText(replacement: String, start: Int, end: Int, selectionMode: SelectionMode = definedExternally)\n    fun setSelectionRange(start: Int, end: Int, direction: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLKeygenElement](https://developer.mozilla.org/en/docs/Web/API/HTMLKeygenElement) to Kotlin\n */\npublic external abstract class HTMLKeygenElement : HTMLElement {\n    open var autofocus: Boolean\n    open var challenge: String\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var keytype: String\n    open var name: String\n    open val type: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLOutputElement](https://developer.mozilla.org/en/docs/Web/API/HTMLOutputElement) to Kotlin\n */\npublic external abstract class HTMLOutputElement : HTMLElement {\n    open val htmlFor: DOMTokenList\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open var defaultValue: String\n    open var value: String\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    open val labels: NodeList\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLProgressElement](https://developer.mozilla.org/en/docs/Web/API/HTMLProgressElement) to Kotlin\n */\npublic external abstract class HTMLProgressElement : HTMLElement {\n    open var value: Double\n    open var max: Double\n    open val position: Double\n    open val labels: NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMeterElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMeterElement) to Kotlin\n */\npublic external abstract class HTMLMeterElement : HTMLElement {\n    open var value: Double\n    open var min: Double\n    open var max: Double\n    open var low: Double\n    open var high: Double\n    open var optimum: Double\n    open val labels: NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFieldSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFieldSetElement) to Kotlin\n */\npublic external abstract class HTMLFieldSetElement : HTMLElement {\n    open var disabled: Boolean\n    open val form: HTMLFormElement?\n    open var name: String\n    open val type: String\n    open val elements: HTMLCollection\n    open val willValidate: Boolean\n    open val validity: ValidityState\n    open val validationMessage: String\n    fun checkValidity(): Boolean\n    fun reportValidity(): Boolean\n    fun setCustomValidity(error: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLLegendElement](https://developer.mozilla.org/en/docs/Web/API/HTMLLegendElement) to Kotlin\n */\npublic external abstract class HTMLLegendElement : HTMLElement {\n    open val form: HTMLFormElement?\n    open var align: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ValidityState](https://developer.mozilla.org/en/docs/Web/API/ValidityState) to Kotlin\n */\npublic external abstract class ValidityState {\n    open val valueMissing: Boolean\n    open val typeMismatch: Boolean\n    open val patternMismatch: Boolean\n    open val tooLong: Boolean\n    open val tooShort: Boolean\n    open val rangeUnderflow: Boolean\n    open val rangeOverflow: Boolean\n    open val stepMismatch: Boolean\n    open val badInput: Boolean\n    open val customError: Boolean\n    open val valid: Boolean\n}\n\n/**\n * Exposes the JavaScript [HTMLDetailsElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDetailsElement) to Kotlin\n */\npublic external abstract class HTMLDetailsElement : HTMLElement {\n    open var open: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLMenuElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLMenuItemElement : HTMLElement {\n    open var type: String\n    open var label: String\n    open var icon: String\n    open var disabled: Boolean\n    open var checked: Boolean\n    open var radiogroup: String\n    open var default: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external open class RelatedEvent(type: String, eventInitDict: RelatedEventInit = definedExternally) : Event {\n    open val relatedTarget: EventTarget?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface RelatedEventInit : EventInit {\n    var relatedTarget: EventTarget? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun RelatedEventInit(relatedTarget: EventTarget? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): RelatedEventInit {\n    val o = js(\"({})\")\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLDialogElement](https://developer.mozilla.org/en/docs/Web/API/HTMLDialogElement) to Kotlin\n */\npublic external abstract class HTMLDialogElement : HTMLElement {\n    open var open: Boolean\n    open var returnValue: String\n    fun show(anchor: UnionElementOrMouseEvent = definedExternally)\n    fun showModal(anchor: UnionElementOrMouseEvent = definedExternally)\n    fun close(returnValue: String = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLScriptElement](https://developer.mozilla.org/en/docs/Web/API/HTMLScriptElement) to Kotlin\n */\npublic external abstract class HTMLScriptElement : HTMLElement, HTMLOrSVGScriptElement {\n    open var src: String\n    open var type: String\n    open var charset: String\n    open var async: Boolean\n    open var defer: Boolean\n    open var crossOrigin: String?\n    open var text: String\n    open var nonce: String\n    open var event: String\n    open var htmlFor: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLTemplateElement](https://developer.mozilla.org/en/docs/Web/API/HTMLTemplateElement) to Kotlin\n */\npublic external abstract class HTMLTemplateElement : HTMLElement {\n    open val content: DocumentFragment\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLSlotElement](https://developer.mozilla.org/en/docs/Web/API/HTMLSlotElement) to Kotlin\n */\npublic external abstract class HTMLSlotElement : HTMLElement {\n    open var name: String\n    fun assignedNodes(options: AssignedNodesOptions = definedExternally): Array<Node>\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface AssignedNodesOptions {\n    var flatten: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AssignedNodesOptions(flatten: Boolean? = false): AssignedNodesOptions {\n    val o = js(\"({})\")\n    o[\"flatten\"] = flatten\n    return o\n}\n\n/**\n * Exposes the JavaScript [HTMLCanvasElement](https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement) to Kotlin\n */\npublic external abstract class HTMLCanvasElement : HTMLElement, CanvasImageSource, TexImageSource {\n    open var width: Int\n    open var height: Int\n    fun getContext(contextId: String, vararg arguments: Any?): RenderingContext?\n    fun toDataURL(type: String = definedExternally, quality: Any? = definedExternally): String\n    fun toBlob(_callback: (Blob?) -> Unit, type: String = definedExternally, quality: Any? = definedExternally)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface CanvasRenderingContext2DSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CanvasRenderingContext2DSettings(alpha: Boolean? = true): CanvasRenderingContext2DSettings {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    return o\n}\n\n/**\n * Exposes the JavaScript [CanvasRenderingContext2D](https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D) to Kotlin\n */\npublic external abstract class CanvasRenderingContext2D : CanvasState, CanvasTransform, CanvasCompositing, CanvasImageSmoothing, CanvasFillStrokeStyles, CanvasShadowStyles, CanvasFilters, CanvasRect, CanvasDrawPath, CanvasUserInterface, CanvasText, CanvasDrawImage, CanvasHitRegion, CanvasImageData, CanvasPathDrawingStyles, CanvasTextDrawingStyles, CanvasPath, RenderingContext {\n    open val canvas: HTMLCanvasElement\n}\n\npublic external interface CanvasState {\n    fun save()\n    fun restore()\n}\n\npublic external interface CanvasTransform {\n    fun scale(x: Double, y: Double)\n    fun rotate(angle: Double)\n    fun translate(x: Double, y: Double)\n    fun transform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double)\n    fun getTransform(): DOMMatrix\n    fun setTransform(a: Double, b: Double, c: Double, d: Double, e: Double, f: Double)\n    fun setTransform(transform: dynamic = definedExternally)\n    fun resetTransform()\n}\n\npublic external interface CanvasCompositing {\n    var globalAlpha: Double\n    var globalCompositeOperation: String\n}\n\npublic external interface CanvasImageSmoothing {\n    var imageSmoothingEnabled: Boolean\n    var imageSmoothingQuality: ImageSmoothingQuality\n}\n\npublic external interface CanvasFillStrokeStyles {\n    var strokeStyle: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillStyle: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n    fun createLinearGradient(x0: Double, y0: Double, x1: Double, y1: Double): CanvasGradient\n    fun createRadialGradient(x0: Double, y0: Double, r0: Double, x1: Double, y1: Double, r1: Double): CanvasGradient\n    fun createPattern(image: CanvasImageSource, repetition: String): CanvasPattern?\n}\n\npublic external interface CanvasShadowStyles {\n    var shadowOffsetX: Double\n    var shadowOffsetY: Double\n    var shadowBlur: Double\n    var shadowColor: String\n}\n\npublic external interface CanvasFilters {\n    var filter: String\n}\n\npublic external interface CanvasRect {\n    fun clearRect(x: Double, y: Double, w: Double, h: Double)\n    fun fillRect(x: Double, y: Double, w: Double, h: Double)\n    fun strokeRect(x: Double, y: Double, w: Double, h: Double)\n}\n\npublic external interface CanvasDrawPath {\n    fun beginPath()\n    fun fill(fillRule: CanvasFillRule = definedExternally)\n    fun fill(path: Path2D, fillRule: CanvasFillRule = definedExternally)\n    fun stroke()\n    fun stroke(path: Path2D)\n    fun clip(fillRule: CanvasFillRule = definedExternally)\n    fun clip(path: Path2D, fillRule: CanvasFillRule = definedExternally)\n    fun resetClip()\n    fun isPointInPath(x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInPath(path: Path2D, x: Double, y: Double, fillRule: CanvasFillRule = definedExternally): Boolean\n    fun isPointInStroke(x: Double, y: Double): Boolean\n    fun isPointInStroke(path: Path2D, x: Double, y: Double): Boolean\n}\n\npublic external interface CanvasUserInterface {\n    fun drawFocusIfNeeded(element: Element)\n    fun drawFocusIfNeeded(path: Path2D, element: Element)\n    fun scrollPathIntoView()\n    fun scrollPathIntoView(path: Path2D)\n}\n\npublic external interface CanvasText {\n    fun fillText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally)\n    fun strokeText(text: String, x: Double, y: Double, maxWidth: Double = definedExternally)\n    fun measureText(text: String): TextMetrics\n}\n\npublic external interface CanvasDrawImage {\n    fun drawImage(image: CanvasImageSource, dx: Double, dy: Double)\n    fun drawImage(image: CanvasImageSource, dx: Double, dy: Double, dw: Double, dh: Double)\n    fun drawImage(image: CanvasImageSource, sx: Double, sy: Double, sw: Double, sh: Double, dx: Double, dy: Double, dw: Double, dh: Double)\n}\n\npublic external interface CanvasHitRegion {\n    fun addHitRegion(options: HitRegionOptions = definedExternally)\n    fun removeHitRegion(id: String)\n    fun clearHitRegions()\n}\n\npublic external interface CanvasImageData {\n    fun createImageData(sw: Double, sh: Double): ImageData\n    fun createImageData(imagedata: ImageData): ImageData\n    fun getImageData(sx: Double, sy: Double, sw: Double, sh: Double): ImageData\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double)\n    fun putImageData(imagedata: ImageData, dx: Double, dy: Double, dirtyX: Double, dirtyY: Double, dirtyWidth: Double, dirtyHeight: Double)\n}\n\npublic external interface CanvasPathDrawingStyles {\n    var lineWidth: Double\n    var lineCap: CanvasLineCap\n    var lineJoin: CanvasLineJoin\n    var miterLimit: Double\n    var lineDashOffset: Double\n    fun setLineDash(segments: Array<Double>)\n    fun getLineDash(): Array<Double>\n}\n\npublic external interface CanvasTextDrawingStyles {\n    var font: String\n    var textAlign: CanvasTextAlign\n    var textBaseline: CanvasTextBaseline\n    var direction: CanvasDirection\n}\n\npublic external interface CanvasPath {\n    fun closePath()\n    fun moveTo(x: Double, y: Double)\n    fun lineTo(x: Double, y: Double)\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)\n    fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double)\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double)\n    fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double)\n    fun rect(x: Double, y: Double, w: Double, h: Double)\n    fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally)\n    fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [CanvasGradient](https://developer.mozilla.org/en/docs/Web/API/CanvasGradient) to Kotlin\n */\npublic external abstract class CanvasGradient {\n    fun addColorStop(offset: Double, color: String)\n}\n\n/**\n * Exposes the JavaScript [CanvasPattern](https://developer.mozilla.org/en/docs/Web/API/CanvasPattern) to Kotlin\n */\npublic external abstract class CanvasPattern {\n    fun setTransform(transform: dynamic = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [TextMetrics](https://developer.mozilla.org/en/docs/Web/API/TextMetrics) to Kotlin\n */\npublic external abstract class TextMetrics {\n    open val width: Double\n    open val actualBoundingBoxLeft: Double\n    open val actualBoundingBoxRight: Double\n    open val fontBoundingBoxAscent: Double\n    open val fontBoundingBoxDescent: Double\n    open val actualBoundingBoxAscent: Double\n    open val actualBoundingBoxDescent: Double\n    open val emHeightAscent: Double\n    open val emHeightDescent: Double\n    open val hangingBaseline: Double\n    open val alphabeticBaseline: Double\n    open val ideographicBaseline: Double\n}\n\npublic external interface HitRegionOptions {\n    var path: Path2D? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */\n        get() = definedExternally\n        set(value) = definedExternally\n    var id: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var parentID: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cursor: String? /* = \"inherit\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var control: Element? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var label: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var role: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = \"\", parentID: String? = null, cursor: String? = \"inherit\", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions {\n    val o = js(\"({})\")\n    o[\"path\"] = path\n    o[\"fillRule\"] = fillRule\n    o[\"id\"] = id\n    o[\"parentID\"] = parentID\n    o[\"cursor\"] = cursor\n    o[\"control\"] = control\n    o[\"label\"] = label\n    o[\"role\"] = role\n    return o\n}\n\n/**\n * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin\n */\npublic external open class ImageData : ImageBitmapSource, TexImageSource {\n    constructor(sw: Int, sh: Int)\n    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)\n    open val width: Int\n    open val height: Int\n    open val data: Uint8ClampedArray\n}\n\n/**\n * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin\n */\npublic external open class Path2D() : CanvasPath {\n    constructor(path: Path2D)\n    constructor(paths: Array<Path2D>, fillRule: CanvasFillRule = definedExternally)\n    constructor(d: String)\n    fun addPath(path: Path2D, transform: dynamic = definedExternally)\n    override fun closePath()\n    override fun moveTo(x: Double, y: Double)\n    override fun lineTo(x: Double, y: Double)\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)\n    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double)\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double)\n    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double)\n    override fun rect(x: Double, y: Double, w: Double, h: Double)\n    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)\n    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)\n}\n\n/**\n * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin\n */\npublic external abstract class ImageBitmapRenderingContext {\n    open val canvas: HTMLCanvasElement\n    fun transferFromImageBitmap(bitmap: ImageBitmap?)\n}\n\npublic external interface ImageBitmapRenderingContextSettings {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapRenderingContextSettings(alpha: Boolean? = true): ImageBitmapRenderingContextSettings {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomElementRegistry](https://developer.mozilla.org/en/docs/Web/API/CustomElementRegistry) to Kotlin\n */\npublic external abstract class CustomElementRegistry {\n    fun define(name: String, constructor: () -> dynamic, options: ElementDefinitionOptions = definedExternally)\n    fun get(name: String): Any?\n    fun whenDefined(name: String): Promise<Unit>\n}\n\npublic external interface ElementDefinitionOptions {\n    var extends: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementDefinitionOptions(extends: String? = undefined): ElementDefinitionOptions {\n    val o = js(\"({})\")\n    o[\"extends\"] = extends\n    return o\n}\n\npublic external interface ElementContentEditable {\n    var contentEditable: String\n    val isContentEditable: Boolean\n}\n\n/**\n * Exposes the JavaScript [DataTransfer](https://developer.mozilla.org/en/docs/Web/API/DataTransfer) to Kotlin\n */\npublic external abstract class DataTransfer {\n    open var dropEffect: String\n    open var effectAllowed: String\n    open val items: DataTransferItemList\n    open val types: Array<out String>\n    open val files: FileList\n    fun setDragImage(image: Element, x: Int, y: Int)\n    fun getData(format: String): String\n    fun setData(format: String, data: String)\n    fun clearData(format: String = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [DataTransferItemList](https://developer.mozilla.org/en/docs/Web/API/DataTransferItemList) to Kotlin\n */\npublic external abstract class DataTransferItemList {\n    open val length: Int\n    fun add(data: String, type: String): DataTransferItem?\n    fun add(data: File): DataTransferItem?\n    fun remove(index: Int)\n    fun clear()\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DataTransferItemList.get(index: Int): DataTransferItem? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DataTransferItem](https://developer.mozilla.org/en/docs/Web/API/DataTransferItem) to Kotlin\n */\npublic external abstract class DataTransferItem {\n    open val kind: String\n    open val type: String\n    fun getAsString(_callback: ((String) -> Unit)?)\n    fun getAsFile(): File?\n}\n\n/**\n * Exposes the JavaScript [DragEvent](https://developer.mozilla.org/en/docs/Web/API/DragEvent) to Kotlin\n */\npublic external open class DragEvent(type: String, eventInitDict: DragEventInit = definedExternally) : MouseEvent {\n    open val dataTransfer: DataTransfer?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface DragEventInit : MouseEventInit {\n    var dataTransfer: DataTransfer? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DragEventInit(dataTransfer: DataTransfer? = null, screenX: Int? = 0, screenY: Int? = 0, clientX: Int? = 0, clientY: Int? = 0, button: Short? = 0, buttons: Short? = 0, relatedTarget: EventTarget? = null, region: String? = null, ctrlKey: Boolean? = false, shiftKey: Boolean? = false, altKey: Boolean? = false, metaKey: Boolean? = false, modifierAltGraph: Boolean? = false, modifierCapsLock: Boolean? = false, modifierFn: Boolean? = false, modifierFnLock: Boolean? = false, modifierHyper: Boolean? = false, modifierNumLock: Boolean? = false, modifierScrollLock: Boolean? = false, modifierSuper: Boolean? = false, modifierSymbol: Boolean? = false, modifierSymbolLock: Boolean? = false, view: Window? = null, detail: Int? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): DragEventInit {\n    val o = js(\"({})\")\n    o[\"dataTransfer\"] = dataTransfer\n    o[\"screenX\"] = screenX\n    o[\"screenY\"] = screenY\n    o[\"clientX\"] = clientX\n    o[\"clientY\"] = clientY\n    o[\"button\"] = button\n    o[\"buttons\"] = buttons\n    o[\"relatedTarget\"] = relatedTarget\n    o[\"region\"] = region\n    o[\"ctrlKey\"] = ctrlKey\n    o[\"shiftKey\"] = shiftKey\n    o[\"altKey\"] = altKey\n    o[\"metaKey\"] = metaKey\n    o[\"modifierAltGraph\"] = modifierAltGraph\n    o[\"modifierCapsLock\"] = modifierCapsLock\n    o[\"modifierFn\"] = modifierFn\n    o[\"modifierFnLock\"] = modifierFnLock\n    o[\"modifierHyper\"] = modifierHyper\n    o[\"modifierNumLock\"] = modifierNumLock\n    o[\"modifierScrollLock\"] = modifierScrollLock\n    o[\"modifierSuper\"] = modifierSuper\n    o[\"modifierSymbol\"] = modifierSymbol\n    o[\"modifierSymbolLock\"] = modifierSymbolLock\n    o[\"view\"] = view\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Window](https://developer.mozilla.org/en/docs/Web/API/Window) to Kotlin\n */\npublic external abstract class Window : EventTarget, GlobalEventHandlers, WindowEventHandlers, WindowOrWorkerGlobalScope, WindowSessionStorage, WindowLocalStorage, GlobalPerformance, UnionMessagePortOrWindowProxy {\n    open val window: Window\n    open val self: Window\n    open val document: Document\n    open var name: String\n    open val location: Location\n    open val history: History\n    open val customElements: CustomElementRegistry\n    open val locationbar: BarProp\n    open val menubar: BarProp\n    open val personalbar: BarProp\n    open val scrollbars: BarProp\n    open val statusbar: BarProp\n    open val toolbar: BarProp\n    open var status: String\n    open val closed: Boolean\n    open val frames: Window\n    open val length: Int\n    open val top: Window\n    open var opener: Any?\n    open val parent: Window\n    open val frameElement: Element?\n    open val navigator: Navigator\n    open val applicationCache: ApplicationCache\n    open val external: External\n    open val screen: Screen\n    open val innerWidth: Int\n    open val innerHeight: Int\n    open val scrollX: Double\n    open val pageXOffset: Double\n    open val scrollY: Double\n    open val pageYOffset: Double\n    open val screenX: Int\n    open val screenY: Int\n    open val outerWidth: Int\n    open val outerHeight: Int\n    open val devicePixelRatio: Double\n    fun close()\n    fun stop()\n    fun focus()\n    fun blur()\n    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?\n    fun alert()\n    fun alert(message: String)\n    fun confirm(message: String = definedExternally): Boolean\n    fun prompt(message: String = definedExternally, default: String = definedExternally): String?\n    fun print()\n    fun requestAnimationFrame(callback: (Double) -> Unit): Int\n    fun cancelAnimationFrame(handle: Int)\n    fun postMessage(message: Any?, targetOrigin: String, transfer: Array<dynamic> = definedExternally)\n    fun captureEvents()\n    fun releaseEvents()\n    fun matchMedia(query: String): MediaQueryList\n    fun moveTo(x: Int, y: Int)\n    fun moveBy(x: Int, y: Int)\n    fun resizeTo(x: Int, y: Int)\n    fun resizeBy(x: Int, y: Int)\n    fun scroll(options: ScrollToOptions = definedExternally)\n    fun scroll(x: Double, y: Double)\n    fun scrollTo(options: ScrollToOptions = definedExternally)\n    fun scrollTo(x: Double, y: Double)\n    fun scrollBy(options: ScrollToOptions = definedExternally)\n    fun scrollBy(x: Double, y: Double)\n    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Window.get(name: String): dynamic = asDynamic()[name]\n\npublic external abstract class BarProp {\n    open val visible: Boolean\n}\n\n/**\n * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin\n */\npublic external abstract class History {\n    open val length: Int\n    open var scrollRestoration: ScrollRestoration\n    open val state: Any?\n    fun go(delta: Int = definedExternally)\n    fun back()\n    fun forward()\n    fun pushState(data: Any?, title: String, url: String? = definedExternally)\n    fun replaceState(data: Any?, title: String, url: String? = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin\n */\npublic external abstract class Location {\n    open var href: String\n    open val origin: String\n    open var protocol: String\n    open var host: String\n    open var hostname: String\n    open var port: String\n    open var pathname: String\n    open var search: String\n    open var hash: String\n    open val ancestorOrigins: Array<out String>\n    fun assign(url: String)\n    fun replace(url: String)\n    fun reload()\n}\n\n/**\n * Exposes the JavaScript [PopStateEvent](https://developer.mozilla.org/en/docs/Web/API/PopStateEvent) to Kotlin\n */\npublic external open class PopStateEvent(type: String, eventInitDict: PopStateEventInit = definedExternally) : Event {\n    open val state: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PopStateEventInit : EventInit {\n    var state: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PopStateEventInit(state: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PopStateEventInit {\n    val o = js(\"({})\")\n    o[\"state\"] = state\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [HashChangeEvent](https://developer.mozilla.org/en/docs/Web/API/HashChangeEvent) to Kotlin\n */\npublic external open class HashChangeEvent(type: String, eventInitDict: HashChangeEventInit = definedExternally) : Event {\n    open val oldURL: String\n    open val newURL: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface HashChangeEventInit : EventInit {\n    var oldURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newURL: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun HashChangeEventInit(oldURL: String? = \"\", newURL: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): HashChangeEventInit {\n    val o = js(\"({})\")\n    o[\"oldURL\"] = oldURL\n    o[\"newURL\"] = newURL\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [PageTransitionEvent](https://developer.mozilla.org/en/docs/Web/API/PageTransitionEvent) to Kotlin\n */\npublic external open class PageTransitionEvent(type: String, eventInitDict: PageTransitionEventInit = definedExternally) : Event {\n    open val persisted: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PageTransitionEventInit : EventInit {\n    var persisted: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PageTransitionEventInit(persisted: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PageTransitionEventInit {\n    val o = js(\"({})\")\n    o[\"persisted\"] = persisted\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [BeforeUnloadEvent](https://developer.mozilla.org/en/docs/Web/API/BeforeUnloadEvent) to Kotlin\n */\npublic external open class BeforeUnloadEvent : Event {\n    var returnValue: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external abstract class ApplicationCache : EventTarget {\n    open val status: Short\n    open var onchecking: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onnoupdate: ((Event) -> dynamic)?\n    open var ondownloading: ((Event) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onupdateready: ((Event) -> dynamic)?\n    open var oncached: ((Event) -> dynamic)?\n    open var onobsolete: ((Event) -> dynamic)?\n    fun update()\n    fun abort()\n    fun swapCache()\n\n    companion object {\n        val UNCACHED: Short\n        val IDLE: Short\n        val CHECKING: Short\n        val DOWNLOADING: Short\n        val UPDATEREADY: Short\n        val OBSOLETE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NavigatorOnLine](https://developer.mozilla.org/en/docs/Web/API/NavigatorOnLine) to Kotlin\n */\npublic external interface NavigatorOnLine {\n    val onLine: Boolean\n}\n\n/**\n * Exposes the JavaScript [ErrorEvent](https://developer.mozilla.org/en/docs/Web/API/ErrorEvent) to Kotlin\n */\npublic external open class ErrorEvent(type: String, eventInitDict: ErrorEventInit = definedExternally) : Event {\n    open val message: String\n    open val filename: String\n    open val lineno: Int\n    open val colno: Int\n    open val error: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface ErrorEventInit : EventInit {\n    var message: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var filename: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lineno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colno: Int? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var error: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ErrorEventInit(message: String? = \"\", filename: String? = \"\", lineno: Int? = 0, colno: Int? = 0, error: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ErrorEventInit {\n    val o = js(\"({})\")\n    o[\"message\"] = message\n    o[\"filename\"] = filename\n    o[\"lineno\"] = lineno\n    o[\"colno\"] = colno\n    o[\"error\"] = error\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [PromiseRejectionEvent](https://developer.mozilla.org/en/docs/Web/API/PromiseRejectionEvent) to Kotlin\n */\npublic external open class PromiseRejectionEvent(type: String, eventInitDict: PromiseRejectionEventInit) : Event {\n    open val promise: Promise<Any?>\n    open val reason: Any?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface PromiseRejectionEventInit : EventInit {\n    var promise: Promise<Any?>?\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: Any?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun PromiseRejectionEventInit(promise: Promise<Any?>?, reason: Any? = undefined, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): PromiseRejectionEventInit {\n    val o = js(\"({})\")\n    o[\"promise\"] = promise\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [GlobalEventHandlers](https://developer.mozilla.org/en/docs/Web/API/GlobalEventHandlers) to Kotlin\n */\npublic external interface GlobalEventHandlers {\n    var onabort: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onblur: ((FocusEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncancel: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncanplay: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncanplaythrough: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onchange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onclick: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onclose: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncontextmenu: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncuechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondblclick: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondrag: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragend: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragenter: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragexit: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragleave: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragover: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondragstart: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondrop: ((DragEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ondurationchange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onemptied: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onended: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onfocus: ((FocusEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oninput: ((InputEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oninvalid: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeydown: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeypress: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onkeyup: ((KeyboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onload: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadeddata: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadedmetadata: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadend: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onloadstart: ((ProgressEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmousedown: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseenter: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseleave: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmousemove: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseout: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseover: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmouseup: ((MouseEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onwheel: ((WheelEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpause: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onplay: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onplaying: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onprogress: ((ProgressEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onratechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onreset: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onresize: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onscroll: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onseeked: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onseeking: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onselect: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onshow: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onstalled: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onsubmit: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onsuspend: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ontimeupdate: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ontoggle: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onvolumechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onwaiting: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ongotpointercapture: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onlostpointercapture: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerdown: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointermove: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerup: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointercancel: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerover: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerout: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerenter: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpointerleave: ((PointerEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [WindowEventHandlers](https://developer.mozilla.org/en/docs/Web/API/WindowEventHandlers) to Kotlin\n */\npublic external interface WindowEventHandlers {\n    var onafterprint: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onbeforeprint: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onbeforeunload: ((BeforeUnloadEvent) -> String?)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onhashchange: ((HashChangeEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onlanguagechange: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onmessage: ((MessageEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onoffline: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var ononline: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpagehide: ((PageTransitionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpageshow: ((PageTransitionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpopstate: ((PopStateEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onrejectionhandled: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onstorage: ((StorageEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onunload: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\npublic external interface DocumentAndElementEventHandlers {\n    var oncopy: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var oncut: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n    var onpaste: ((ClipboardEvent) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [WindowOrWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WindowOrWorkerGlobalScope) to Kotlin\n */\npublic external interface WindowOrWorkerGlobalScope {\n    val origin: String\n    val caches: CacheStorage\n    fun btoa(data: String): String\n    fun atob(data: String): String\n    fun setTimeout(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearTimeout(handle: Int = definedExternally)\n    fun setInterval(handler: dynamic, timeout: Int = definedExternally, vararg arguments: Any?): Int\n    fun clearInterval(handle: Int = definedExternally)\n    fun createImageBitmap(image: ImageBitmapSource, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun createImageBitmap(image: ImageBitmapSource, sx: Int, sy: Int, sw: Int, sh: Int, options: ImageBitmapOptions = definedExternally): Promise<ImageBitmap>\n    fun fetch(input: dynamic, init: RequestInit = definedExternally): Promise<Response>\n}\n\n/**\n * Exposes the JavaScript [Navigator](https://developer.mozilla.org/en/docs/Web/API/Navigator) to Kotlin\n */\npublic external abstract class Navigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorContentUtils, NavigatorCookies, NavigatorPlugins, NavigatorConcurrentHardware {\n    open val clipboard: Clipboard\n    open val mediaDevices: MediaDevices\n    open val maxTouchPoints: Int\n    open val serviceWorker: ServiceWorkerContainer\n    fun getUserMedia(constraints: MediaStreamConstraints, successCallback: (MediaStream) -> Unit, errorCallback: (dynamic) -> Unit)\n    fun vibrate(pattern: dynamic): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorID](https://developer.mozilla.org/en/docs/Web/API/NavigatorID) to Kotlin\n */\npublic external interface NavigatorID {\n    val appCodeName: String\n    val appName: String\n    val appVersion: String\n    val platform: String\n    val product: String\n    val productSub: String\n    val userAgent: String\n    val vendor: String\n    val vendorSub: String\n    val oscpu: String\n    fun taintEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorLanguage](https://developer.mozilla.org/en/docs/Web/API/NavigatorLanguage) to Kotlin\n */\npublic external interface NavigatorLanguage {\n    val language: String\n    val languages: Array<out String>\n}\n\npublic external interface NavigatorContentUtils {\n    fun registerProtocolHandler(scheme: String, url: String, title: String)\n    fun registerContentHandler(mimeType: String, url: String, title: String)\n    fun isProtocolHandlerRegistered(scheme: String, url: String): String\n    fun isContentHandlerRegistered(mimeType: String, url: String): String\n    fun unregisterProtocolHandler(scheme: String, url: String)\n    fun unregisterContentHandler(mimeType: String, url: String)\n}\n\npublic external interface NavigatorCookies {\n    val cookieEnabled: Boolean\n}\n\n/**\n * Exposes the JavaScript [NavigatorPlugins](https://developer.mozilla.org/en/docs/Web/API/NavigatorPlugins) to Kotlin\n */\npublic external interface NavigatorPlugins {\n    val plugins: PluginArray\n    val mimeTypes: MimeTypeArray\n    fun javaEnabled(): Boolean\n}\n\n/**\n * Exposes the JavaScript [PluginArray](https://developer.mozilla.org/en/docs/Web/API/PluginArray) to Kotlin\n */\npublic external abstract class PluginArray : ItemArrayLike<Plugin> {\n    fun refresh(reload: Boolean = definedExternally)\n    override fun item(index: Int): Plugin?\n    fun namedItem(name: String): Plugin?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun PluginArray.get(index: Int): Plugin? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun PluginArray.get(name: String): Plugin? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeTypeArray](https://developer.mozilla.org/en/docs/Web/API/MimeTypeArray) to Kotlin\n */\npublic external abstract class MimeTypeArray : ItemArrayLike<MimeType> {\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun MimeTypeArray.get(index: Int): MimeType? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun MimeTypeArray.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [Plugin](https://developer.mozilla.org/en/docs/Web/API/Plugin) to Kotlin\n */\npublic external abstract class Plugin : ItemArrayLike<MimeType> {\n    open val name: String\n    open val description: String\n    open val filename: String\n    override fun item(index: Int): MimeType?\n    fun namedItem(name: String): MimeType?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Plugin.get(index: Int): MimeType? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Plugin.get(name: String): MimeType? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MimeType](https://developer.mozilla.org/en/docs/Web/API/MimeType) to Kotlin\n */\npublic external abstract class MimeType {\n    open val type: String\n    open val description: String\n    open val suffixes: String\n    open val enabledPlugin: Plugin\n}\n\n/**\n * Exposes the JavaScript [ImageBitmap](https://developer.mozilla.org/en/docs/Web/API/ImageBitmap) to Kotlin\n */\npublic external abstract class ImageBitmap : CanvasImageSource, TexImageSource {\n    open val width: Int\n    open val height: Int\n    fun close()\n}\n\npublic external interface ImageBitmapOptions {\n    var imageOrientation: ImageOrientation? /* = ImageOrientation.NONE */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultiplyAlpha: PremultiplyAlpha? /* = PremultiplyAlpha.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var colorSpaceConversion: ColorSpaceConversion? /* = ColorSpaceConversion.DEFAULT */\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeWidth: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeHeight: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n    var resizeQuality: ResizeQuality? /* = ResizeQuality.LOW */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ImageBitmapOptions(imageOrientation: ImageOrientation? = ImageOrientation.NONE, premultiplyAlpha: PremultiplyAlpha? = PremultiplyAlpha.DEFAULT, colorSpaceConversion: ColorSpaceConversion? = ColorSpaceConversion.DEFAULT, resizeWidth: Int? = undefined, resizeHeight: Int? = undefined, resizeQuality: ResizeQuality? = ResizeQuality.LOW): ImageBitmapOptions {\n    val o = js(\"({})\")\n    o[\"imageOrientation\"] = imageOrientation\n    o[\"premultiplyAlpha\"] = premultiplyAlpha\n    o[\"colorSpaceConversion\"] = colorSpaceConversion\n    o[\"resizeWidth\"] = resizeWidth\n    o[\"resizeHeight\"] = resizeHeight\n    o[\"resizeQuality\"] = resizeQuality\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageEvent](https://developer.mozilla.org/en/docs/Web/API/MessageEvent) to Kotlin\n */\npublic external open class MessageEvent(type: String, eventInitDict: MessageEventInit = definedExternally) : Event {\n    open val data: Any?\n    open val origin: String\n    open val lastEventId: String\n    open val source: UnionMessagePortOrWindowProxy?\n    open val ports: Array<out MessagePort>\n    fun initMessageEvent(type: String, bubbles: Boolean, cancelable: Boolean, data: Any?, origin: String, lastEventId: String, source: UnionMessagePortOrWindowProxy?, ports: Array<MessagePort>)\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface MessageEventInit : EventInit {\n    var data: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var origin: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var lastEventId: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var source: UnionMessagePortOrWindowProxy? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var ports: Array<MessagePort>? /* = arrayOf() */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MessageEventInit(data: Any? = null, origin: String? = \"\", lastEventId: String? = \"\", source: UnionMessagePortOrWindowProxy? = null, ports: Array<MessagePort>? = arrayOf(), bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MessageEventInit {\n    val o = js(\"({})\")\n    o[\"data\"] = data\n    o[\"origin\"] = origin\n    o[\"lastEventId\"] = lastEventId\n    o[\"source\"] = source\n    o[\"ports\"] = ports\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [EventSource](https://developer.mozilla.org/en/docs/Web/API/EventSource) to Kotlin\n */\npublic external open class EventSource(url: String, eventSourceInitDict: EventSourceInit = definedExternally) : EventTarget {\n    open val url: String\n    open val withCredentials: Boolean\n    open val readyState: Short\n    var onopen: ((Event) -> dynamic)?\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    fun close()\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSED: Short\n    }\n}\n\npublic external interface EventSourceInit {\n    var withCredentials: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventSourceInit(withCredentials: Boolean? = false): EventSourceInit {\n    val o = js(\"({})\")\n    o[\"withCredentials\"] = withCredentials\n    return o\n}\n\n/**\n * Exposes the JavaScript [WebSocket](https://developer.mozilla.org/en/docs/Web/API/WebSocket) to Kotlin\n */\npublic external open class WebSocket(url: String, protocols: dynamic = definedExternally) : EventTarget {\n    open val url: String\n    open val readyState: Short\n    open val bufferedAmount: Number\n    var onopen: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onclose: ((Event) -> dynamic)?\n    open val extensions: String\n    open val protocol: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    var binaryType: BinaryType\n    fun close(code: Short = definedExternally, reason: String = definedExternally)\n    fun send(data: String)\n    fun send(data: Blob)\n    fun send(data: ArrayBuffer)\n    fun send(data: ArrayBufferView)\n\n    companion object {\n        val CONNECTING: Short\n        val OPEN: Short\n        val CLOSING: Short\n        val CLOSED: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CloseEvent](https://developer.mozilla.org/en/docs/Web/API/CloseEvent) to Kotlin\n */\npublic external open class CloseEvent(type: String, eventInitDict: CloseEventInit = definedExternally) : Event {\n    open val wasClean: Boolean\n    open val code: Short\n    open val reason: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface CloseEventInit : EventInit {\n    var wasClean: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var code: Short? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var reason: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CloseEventInit(wasClean: Boolean? = false, code: Short? = 0, reason: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CloseEventInit {\n    val o = js(\"({})\")\n    o[\"wasClean\"] = wasClean\n    o[\"code\"] = code\n    o[\"reason\"] = reason\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [MessageChannel](https://developer.mozilla.org/en/docs/Web/API/MessageChannel) to Kotlin\n */\npublic external open class MessageChannel {\n    open val port1: MessagePort\n    open val port2: MessagePort\n}\n\n/**\n * Exposes the JavaScript [MessagePort](https://developer.mozilla.org/en/docs/Web/API/MessagePort) to Kotlin\n */\npublic external abstract class MessagePort : EventTarget, UnionMessagePortOrWindowProxy, UnionMessagePortOrServiceWorker, UnionClientOrMessagePortOrServiceWorker {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n    fun start()\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [BroadcastChannel](https://developer.mozilla.org/en/docs/Web/API/BroadcastChannel) to Kotlin\n */\npublic external open class BroadcastChannel(name: String) : EventTarget {\n    open val name: String\n    var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?)\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [WorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/WorkerGlobalScope) to Kotlin\n */\npublic external abstract class WorkerGlobalScope : EventTarget, WindowOrWorkerGlobalScope, GlobalPerformance {\n    open val self: WorkerGlobalScope\n    open val location: WorkerLocation\n    open val navigator: WorkerNavigator\n    open var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    open var onlanguagechange: ((Event) -> dynamic)?\n    open var onoffline: ((Event) -> dynamic)?\n    open var ononline: ((Event) -> dynamic)?\n    open var onrejectionhandled: ((Event) -> dynamic)?\n    open var onunhandledrejection: ((PromiseRejectionEvent) -> dynamic)?\n    fun importScripts(vararg urls: String)\n}\n\n/**\n * Exposes the JavaScript [DedicatedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/DedicatedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class DedicatedWorkerGlobalScope : WorkerGlobalScope {\n    open var onmessage: ((MessageEvent) -> dynamic)?\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [SharedWorkerGlobalScope](https://developer.mozilla.org/en/docs/Web/API/SharedWorkerGlobalScope) to Kotlin\n */\npublic external abstract class SharedWorkerGlobalScope : WorkerGlobalScope {\n    open val name: String\n    open val applicationCache: ApplicationCache\n    open var onconnect: ((Event) -> dynamic)?\n    fun close()\n}\n\n/**\n * Exposes the JavaScript [AbstractWorker](https://developer.mozilla.org/en/docs/Web/API/AbstractWorker) to Kotlin\n */\npublic external interface AbstractWorker {\n    var onerror: ((Event) -> dynamic)?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n/**\n * Exposes the JavaScript [Worker](https://developer.mozilla.org/en/docs/Web/API/Worker) to Kotlin\n */\npublic external open class Worker(scriptURL: String, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    var onmessage: ((MessageEvent) -> dynamic)?\n    override var onerror: ((Event) -> dynamic)?\n    fun terminate()\n    fun postMessage(message: Any?, transfer: Array<dynamic> = definedExternally)\n}\n\npublic external interface WorkerOptions {\n    var type: WorkerType? /* = WorkerType.CLASSIC */\n        get() = definedExternally\n        set(value) = definedExternally\n    var credentials: RequestCredentials? /* = RequestCredentials.OMIT */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WorkerOptions(type: WorkerType? = WorkerType.CLASSIC, credentials: RequestCredentials? = RequestCredentials.OMIT): WorkerOptions {\n    val o = js(\"({})\")\n    o[\"type\"] = type\n    o[\"credentials\"] = credentials\n    return o\n}\n\n/**\n * Exposes the JavaScript [SharedWorker](https://developer.mozilla.org/en/docs/Web/API/SharedWorker) to Kotlin\n */\npublic external open class SharedWorker(scriptURL: String, name: String = definedExternally, options: WorkerOptions = definedExternally) : EventTarget, AbstractWorker {\n    open val port: MessagePort\n    override var onerror: ((Event) -> dynamic)?\n}\n\n/**\n * Exposes the JavaScript [NavigatorConcurrentHardware](https://developer.mozilla.org/en/docs/Web/API/NavigatorConcurrentHardware) to Kotlin\n */\npublic external interface NavigatorConcurrentHardware {\n    val hardwareConcurrency: Number\n}\n\n/**\n * Exposes the JavaScript [WorkerNavigator](https://developer.mozilla.org/en/docs/Web/API/WorkerNavigator) to Kotlin\n */\npublic external abstract class WorkerNavigator : NavigatorID, NavigatorLanguage, NavigatorOnLine, NavigatorConcurrentHardware {\n    open val serviceWorker: ServiceWorkerContainer\n}\n\n/**\n * Exposes the JavaScript [WorkerLocation](https://developer.mozilla.org/en/docs/Web/API/WorkerLocation) to Kotlin\n */\npublic external abstract class WorkerLocation {\n    open val href: String\n    open val origin: String\n    open val protocol: String\n    open val host: String\n    open val hostname: String\n    open val port: String\n    open val pathname: String\n    open val search: String\n    open val hash: String\n}\n\n/**\n * Exposes the JavaScript [Storage](https://developer.mozilla.org/en/docs/Web/API/Storage) to Kotlin\n */\npublic external abstract class Storage {\n    open val length: Int\n    fun key(index: Int): String?\n    fun removeItem(key: String)\n    fun clear()\n    fun getItem(key: String): String?\n    fun setItem(key: String, value: String)\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Storage.get(key: String): String? = asDynamic()[key]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Storage.set(key: String, value: String) { asDynamic()[key] = value }\n\n/**\n * Exposes the JavaScript [WindowSessionStorage](https://developer.mozilla.org/en/docs/Web/API/WindowSessionStorage) to Kotlin\n */\npublic external interface WindowSessionStorage {\n    val sessionStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [WindowLocalStorage](https://developer.mozilla.org/en/docs/Web/API/WindowLocalStorage) to Kotlin\n */\npublic external interface WindowLocalStorage {\n    val localStorage: Storage\n}\n\n/**\n * Exposes the JavaScript [StorageEvent](https://developer.mozilla.org/en/docs/Web/API/StorageEvent) to Kotlin\n */\npublic external open class StorageEvent(type: String, eventInitDict: StorageEventInit = definedExternally) : Event {\n    open val key: String?\n    open val oldValue: String?\n    open val newValue: String?\n    open val url: String\n    open val storageArea: Storage?\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface StorageEventInit : EventInit {\n    var key: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var oldValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var newValue: String? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n    var url: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var storageArea: Storage? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun StorageEventInit(key: String? = null, oldValue: String? = null, newValue: String? = null, url: String? = \"\", storageArea: Storage? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): StorageEventInit {\n    val o = js(\"({})\")\n    o[\"key\"] = key\n    o[\"oldValue\"] = oldValue\n    o[\"newValue\"] = newValue\n    o[\"url\"] = url\n    o[\"storageArea\"] = storageArea\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\npublic external abstract class HTMLAppletElement : HTMLElement {\n    open var align: String\n    open var alt: String\n    open var archive: String\n    open var code: String\n    open var codeBase: String\n    open var height: String\n    open var hspace: Int\n    open var name: String\n    open var _object: String\n    open var vspace: Int\n    open var width: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLMarqueeElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMarqueeElement) to Kotlin\n */\npublic external abstract class HTMLMarqueeElement : HTMLElement {\n    open var behavior: String\n    open var bgColor: String\n    open var direction: String\n    open var height: String\n    open var hspace: Int\n    open var loop: Int\n    open var scrollAmount: Int\n    open var scrollDelay: Int\n    open var trueSpeed: Boolean\n    open var vspace: Int\n    open var width: String\n    open var onbounce: ((Event) -> dynamic)?\n    open var onfinish: ((Event) -> dynamic)?\n    open var onstart: ((Event) -> dynamic)?\n    fun start()\n    fun stop()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFrameSetElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFrameSetElement) to Kotlin\n */\npublic external abstract class HTMLFrameSetElement : HTMLElement, WindowEventHandlers {\n    open var cols: String\n    open var rows: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLFrameElement : HTMLElement {\n    open var name: String\n    open var scrolling: String\n    open var src: String\n    open var frameBorder: String\n    open var longDesc: String\n    open var noResize: Boolean\n    open val contentDocument: Document?\n    open val contentWindow: Window?\n    open var marginHeight: String\n    open var marginWidth: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external abstract class HTMLDirectoryElement : HTMLElement {\n    open var compact: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [HTMLFontElement](https://developer.mozilla.org/en/docs/Web/API/HTMLFontElement) to Kotlin\n */\npublic external abstract class HTMLFontElement : HTMLElement {\n    open var color: String\n    open var face: String\n    open var size: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface External {\n    fun AddSearchProvider()\n    fun IsSearchProviderInstalled()\n}\n\npublic external interface EventInit {\n    var bubbles: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var cancelable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventInit(bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): EventInit {\n    val o = js(\"({})\")\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [CustomEvent](https://developer.mozilla.org/en/docs/Web/API/CustomEvent) to Kotlin\n */\npublic external open class CustomEvent(type: String, eventInitDict: CustomEventInit = definedExternally) : Event {\n    open val detail: Any?\n    fun initCustomEvent(type: String, bubbles: Boolean, cancelable: Boolean, detail: Any?)\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface CustomEventInit : EventInit {\n    var detail: Any? /* = null */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun CustomEventInit(detail: Any? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): CustomEventInit {\n    val o = js(\"({})\")\n    o[\"detail\"] = detail\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\npublic external interface EventListenerOptions {\n    var capture: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun EventListenerOptions(capture: Boolean? = false): EventListenerOptions {\n    val o = js(\"({})\")\n    o[\"capture\"] = capture\n    return o\n}\n\npublic external interface AddEventListenerOptions : EventListenerOptions {\n    var passive: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var once: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun AddEventListenerOptions(passive: Boolean? = false, once: Boolean? = false, capture: Boolean? = false): AddEventListenerOptions {\n    val o = js(\"({})\")\n    o[\"passive\"] = passive\n    o[\"once\"] = once\n    o[\"capture\"] = capture\n    return o\n}\n\npublic external interface NonElementParentNode {\n    fun getElementById(elementId: String): Element?\n}\n\n/**\n * Exposes the JavaScript [DocumentOrShadowRoot](https://developer.mozilla.org/en/docs/Web/API/DocumentOrShadowRoot) to Kotlin\n */\npublic external interface DocumentOrShadowRoot {\n    val fullscreenElement: Element?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [ParentNode](https://developer.mozilla.org/en/docs/Web/API/ParentNode) to Kotlin\n */\npublic external interface ParentNode {\n    val children: HTMLCollection\n    val firstElementChild: Element?\n        get() = definedExternally\n    val lastElementChild: Element?\n        get() = definedExternally\n    val childElementCount: Int\n    fun prepend(vararg nodes: dynamic)\n    fun append(vararg nodes: dynamic)\n    fun querySelector(selectors: String): Element?\n    fun querySelectorAll(selectors: String): NodeList\n}\n\n/**\n * Exposes the JavaScript [NonDocumentTypeChildNode](https://developer.mozilla.org/en/docs/Web/API/NonDocumentTypeChildNode) to Kotlin\n */\npublic external interface NonDocumentTypeChildNode {\n    val previousElementSibling: Element?\n        get() = definedExternally\n    val nextElementSibling: Element?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [ChildNode](https://developer.mozilla.org/en/docs/Web/API/ChildNode) to Kotlin\n */\npublic external interface ChildNode {\n    fun before(vararg nodes: dynamic)\n    fun after(vararg nodes: dynamic)\n    fun replaceWith(vararg nodes: dynamic)\n    fun remove()\n}\n\n/**\n * Exposes the JavaScript [Slotable](https://developer.mozilla.org/en/docs/Web/API/Slotable) to Kotlin\n */\npublic external interface Slotable {\n    val assignedSlot: HTMLSlotElement?\n        get() = definedExternally\n}\n\n/**\n * Exposes the JavaScript [NodeList](https://developer.mozilla.org/en/docs/Web/API/NodeList) to Kotlin\n */\npublic external abstract class NodeList : ItemArrayLike<Node> {\n    override fun item(index: Int): Node?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NodeList.get(index: Int): Node? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [HTMLCollection](https://developer.mozilla.org/en/docs/Web/API/HTMLCollection) to Kotlin\n */\npublic external abstract class HTMLCollection : ItemArrayLike<Element>, UnionElementOrHTMLCollection {\n    override fun item(index: Int): Element?\n    fun namedItem(name: String): Element?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLCollection.get(index: Int): Element? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun HTMLCollection.get(name: String): Element? = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) to Kotlin\n */\npublic external open class MutationObserver(callback: (Array<MutationRecord>, MutationObserver) -> Unit) {\n    fun observe(target: Node, options: MutationObserverInit = definedExternally)\n    fun disconnect()\n    fun takeRecords(): Array<MutationRecord>\n}\n\n/**\n * Exposes the JavaScript [MutationObserverInit](https://developer.mozilla.org/en/docs/Web/API/MutationObserverInit) to Kotlin\n */\npublic external interface MutationObserverInit {\n    var childList: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributes: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterData: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var subtree: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var characterDataOldValue: Boolean?\n        get() = definedExternally\n        set(value) = definedExternally\n    var attributeFilter: Array<String>?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MutationObserverInit(childList: Boolean? = false, attributes: Boolean? = undefined, characterData: Boolean? = undefined, subtree: Boolean? = false, attributeOldValue: Boolean? = undefined, characterDataOldValue: Boolean? = undefined, attributeFilter: Array<String>? = undefined): MutationObserverInit {\n    val o = js(\"({})\")\n    o[\"childList\"] = childList\n    o[\"attributes\"] = attributes\n    o[\"characterData\"] = characterData\n    o[\"subtree\"] = subtree\n    o[\"attributeOldValue\"] = attributeOldValue\n    o[\"characterDataOldValue\"] = characterDataOldValue\n    o[\"attributeFilter\"] = attributeFilter\n    return o\n}\n\n/**\n * Exposes the JavaScript [MutationRecord](https://developer.mozilla.org/en/docs/Web/API/MutationRecord) to Kotlin\n */\npublic external abstract class MutationRecord {\n    open val type: String\n    open val target: Node\n    open val addedNodes: NodeList\n    open val removedNodes: NodeList\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open val attributeName: String?\n    open val attributeNamespace: String?\n    open val oldValue: String?\n}\n\n/**\n * Exposes the JavaScript [Node](https://developer.mozilla.org/en/docs/Web/API/Node) to Kotlin\n */\npublic external abstract class Node : EventTarget {\n    open val nodeType: Short\n    open val nodeName: String\n    open val baseURI: String\n    open val isConnected: Boolean\n    open val ownerDocument: Document?\n    open val parentNode: Node?\n    open val parentElement: Element?\n    open val childNodes: NodeList\n    open val firstChild: Node?\n    open val lastChild: Node?\n    open val previousSibling: Node?\n    open val nextSibling: Node?\n    open var nodeValue: String?\n    open var textContent: String?\n    fun getRootNode(options: GetRootNodeOptions = definedExternally): Node\n    fun hasChildNodes(): Boolean\n    fun normalize()\n    fun cloneNode(deep: Boolean = definedExternally): Node\n    fun isEqualNode(otherNode: Node?): Boolean\n    fun isSameNode(otherNode: Node?): Boolean\n    fun compareDocumentPosition(other: Node): Short\n    fun contains(other: Node?): Boolean\n    fun lookupPrefix(namespace: String?): String?\n    fun lookupNamespaceURI(prefix: String?): String?\n    fun isDefaultNamespace(namespace: String?): Boolean\n    fun insertBefore(node: Node, child: Node?): Node\n    fun appendChild(node: Node): Node\n    fun replaceChild(node: Node, child: Node): Node\n    fun removeChild(child: Node): Node\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface GetRootNodeOptions {\n    var composed: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun GetRootNodeOptions(composed: Boolean? = false): GetRootNodeOptions {\n    val o = js(\"({})\")\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Document](https://developer.mozilla.org/en/docs/Web/API/Document) to Kotlin\n */\npublic external open class Document : Node, GlobalEventHandlers, DocumentAndElementEventHandlers, NonElementParentNode, DocumentOrShadowRoot, ParentNode, GeometryUtils {\n    open val implementation: DOMImplementation\n    open val URL: String\n    open val documentURI: String\n    open val origin: String\n    open val compatMode: String\n    open val characterSet: String\n    open val charset: String\n    open val inputEncoding: String\n    open val contentType: String\n    open val doctype: DocumentType?\n    open val documentElement: Element?\n    open val location: Location?\n    var domain: String\n    open val referrer: String\n    var cookie: String\n    open val lastModified: String\n    open val readyState: DocumentReadyState\n    var title: String\n    var dir: String\n    var body: HTMLElement?\n    open val head: HTMLHeadElement?\n    open val images: HTMLCollection\n    open val embeds: HTMLCollection\n    open val plugins: HTMLCollection\n    open val links: HTMLCollection\n    open val forms: HTMLCollection\n    open val scripts: HTMLCollection\n    open val currentScript: HTMLOrSVGScriptElement?\n    open val defaultView: Window?\n    open val activeElement: Element?\n    var designMode: String\n    var onreadystatechange: ((Event) -> dynamic)?\n    var fgColor: String\n    var linkColor: String\n    var vlinkColor: String\n    var alinkColor: String\n    var bgColor: String\n    open val anchors: HTMLCollection\n    open val applets: HTMLCollection\n    open val all: HTMLAllCollection\n    open val scrollingElement: Element?\n    open val styleSheets: StyleSheetList\n    open val rootElement: SVGSVGElement?\n    open val fullscreenEnabled: Boolean\n    open val fullscreen: Boolean\n    var onfullscreenchange: ((Event) -> dynamic)?\n    var onfullscreenerror: ((Event) -> dynamic)?\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override val fullscreenElement: Element?\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun createElement(localName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createElementNS(namespace: String?, qualifiedName: String, options: ElementCreationOptions = definedExternally): Element\n    fun createDocumentFragment(): DocumentFragment\n    fun createTextNode(data: String): Text\n    fun createCDATASection(data: String): CDATASection\n    fun createComment(data: String): Comment\n    fun createProcessingInstruction(target: String, data: String): ProcessingInstruction\n    fun importNode(node: Node, deep: Boolean = definedExternally): Node\n    fun adoptNode(node: Node): Node\n    fun createAttribute(localName: String): Attr\n    fun createAttributeNS(namespace: String?, qualifiedName: String): Attr\n    fun createEvent(`interface`: String): Event\n    fun createRange(): Range\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): NodeIterator\n    fun createNodeIterator(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): NodeIterator\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: NodeFilter? = definedExternally): TreeWalker\n    fun createTreeWalker(root: Node, whatToShow: Int = definedExternally, filter: ((Node) -> Short)? = definedExternally): TreeWalker\n    fun getElementsByName(elementName: String): NodeList\n    fun open(type: String = definedExternally, replace: String = definedExternally): Document\n    fun open(url: String, name: String, features: String): Window\n    fun close()\n    fun write(vararg text: String)\n    fun writeln(vararg text: String)\n    fun hasFocus(): Boolean\n    fun execCommand(commandId: String, showUI: Boolean = definedExternally, value: String = definedExternally): Boolean\n    fun queryCommandEnabled(commandId: String): Boolean\n    fun queryCommandIndeterm(commandId: String): Boolean\n    fun queryCommandState(commandId: String): Boolean\n    fun queryCommandSupported(commandId: String): Boolean\n    fun queryCommandValue(commandId: String): String\n    fun clear()\n    fun captureEvents()\n    fun releaseEvents()\n    fun elementFromPoint(x: Double, y: Double): Element?\n    fun elementsFromPoint(x: Double, y: Double): Array<Element>\n    fun caretPositionFromPoint(x: Double, y: Double): CaretPosition?\n    fun createTouch(view: Window, target: EventTarget, identifier: Int, pageX: Int, pageY: Int, screenX: Int, screenY: Int): Touch\n    fun createTouchList(vararg touches: Touch): TouchList\n    fun exitFullscreen(): Promise<Unit>\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Document.get(name: String): dynamic = asDynamic()[name]\n\n/**\n * Exposes the JavaScript [XMLDocument](https://developer.mozilla.org/en/docs/Web/API/XMLDocument) to Kotlin\n */\npublic external open class XMLDocument : Document {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface ElementCreationOptions {\n    var `is`: String?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ElementCreationOptions(`is`: String? = undefined): ElementCreationOptions {\n    val o = js(\"({})\")\n    o[\"is\"] = `is`\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMImplementation](https://developer.mozilla.org/en/docs/Web/API/DOMImplementation) to Kotlin\n */\npublic external abstract class DOMImplementation {\n    fun createDocumentType(qualifiedName: String, publicId: String, systemId: String): DocumentType\n    fun createDocument(namespace: String?, qualifiedName: String, doctype: DocumentType? = definedExternally): XMLDocument\n    fun createHTMLDocument(title: String = definedExternally): Document\n    fun hasFeature(): Boolean\n}\n\n/**\n * Exposes the JavaScript [DocumentType](https://developer.mozilla.org/en/docs/Web/API/DocumentType) to Kotlin\n */\npublic external abstract class DocumentType : Node, ChildNode {\n    open val name: String\n    open val publicId: String\n    open val systemId: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [DocumentFragment](https://developer.mozilla.org/en/docs/Web/API/DocumentFragment) to Kotlin\n */\npublic external open class DocumentFragment : Node, NonElementParentNode, ParentNode {\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override fun getElementById(elementId: String): Element?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ShadowRoot](https://developer.mozilla.org/en/docs/Web/API/ShadowRoot) to Kotlin\n */\npublic external open class ShadowRoot : DocumentFragment, DocumentOrShadowRoot {\n    open val mode: ShadowRootMode\n    open val host: Element\n    override val fullscreenElement: Element?\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Element](https://developer.mozilla.org/en/docs/Web/API/Element) to Kotlin\n */\npublic external abstract class Element : Node, ParentNode, NonDocumentTypeChildNode, ChildNode, Slotable, GeometryUtils, UnionElementOrHTMLCollection, UnionElementOrRadioNodeList, UnionElementOrMouseEvent, UnionElementOrProcessingInstruction {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val tagName: String\n    open var id: String\n    open var className: String\n    open val classList: DOMTokenList\n    open var slot: String\n    open val attributes: NamedNodeMap\n    open val shadowRoot: ShadowRoot?\n    open var scrollTop: Double\n    open var scrollLeft: Double\n    open val scrollWidth: Int\n    open val scrollHeight: Int\n    open val clientTop: Int\n    open val clientLeft: Int\n    open val clientWidth: Int\n    open val clientHeight: Int\n    open var innerHTML: String\n    open var outerHTML: String\n    fun hasAttributes(): Boolean\n    fun getAttributeNames(): Array<String>\n    fun getAttribute(qualifiedName: String): String?\n    fun getAttributeNS(namespace: String?, localName: String): String?\n    fun setAttribute(qualifiedName: String, value: String)\n    fun setAttributeNS(namespace: String?, qualifiedName: String, value: String)\n    fun removeAttribute(qualifiedName: String)\n    fun removeAttributeNS(namespace: String?, localName: String)\n    fun hasAttribute(qualifiedName: String): Boolean\n    fun hasAttributeNS(namespace: String?, localName: String): Boolean\n    fun getAttributeNode(qualifiedName: String): Attr?\n    fun getAttributeNodeNS(namespace: String?, localName: String): Attr?\n    fun setAttributeNode(attr: Attr): Attr?\n    fun setAttributeNodeNS(attr: Attr): Attr?\n    fun removeAttributeNode(attr: Attr): Attr\n    fun attachShadow(init: ShadowRootInit): ShadowRoot\n    fun closest(selectors: String): Element?\n    fun matches(selectors: String): Boolean\n    fun webkitMatchesSelector(selectors: String): Boolean\n    fun getElementsByTagName(qualifiedName: String): HTMLCollection\n    fun getElementsByTagNameNS(namespace: String?, localName: String): HTMLCollection\n    fun getElementsByClassName(classNames: String): HTMLCollection\n    fun insertAdjacentElement(where: String, element: Element): Element?\n    fun insertAdjacentText(where: String, data: String)\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun scrollIntoView()\n    fun scrollIntoView(arg: dynamic)\n    fun scroll(options: ScrollToOptions = definedExternally)\n    fun scroll(x: Double, y: Double)\n    fun scrollTo(options: ScrollToOptions = definedExternally)\n    fun scrollTo(x: Double, y: Double)\n    fun scrollBy(options: ScrollToOptions = definedExternally)\n    fun scrollBy(x: Double, y: Double)\n    fun insertAdjacentHTML(position: String, text: String)\n    fun setPointerCapture(pointerId: Int)\n    fun releasePointerCapture(pointerId: Int)\n    fun hasPointerCapture(pointerId: Int): Boolean\n    fun requestFullscreen(): Promise<Unit>\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface ShadowRootInit {\n    var mode: ShadowRootMode?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ShadowRootInit(mode: ShadowRootMode?): ShadowRootInit {\n    val o = js(\"({})\")\n    o[\"mode\"] = mode\n    return o\n}\n\n/**\n * Exposes the JavaScript [NamedNodeMap](https://developer.mozilla.org/en/docs/Web/API/NamedNodeMap) to Kotlin\n */\npublic external abstract class NamedNodeMap : ItemArrayLike<Attr> {\n    fun getNamedItemNS(namespace: String?, localName: String): Attr?\n    fun setNamedItem(attr: Attr): Attr?\n    fun setNamedItemNS(attr: Attr): Attr?\n    fun removeNamedItem(qualifiedName: String): Attr\n    fun removeNamedItemNS(namespace: String?, localName: String): Attr\n    override fun item(index: Int): Attr?\n    fun getNamedItem(qualifiedName: String): Attr?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NamedNodeMap.get(index: Int): Attr? = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun NamedNodeMap.get(qualifiedName: String): Attr? = asDynamic()[qualifiedName]\n\n/**\n * Exposes the JavaScript [Attr](https://developer.mozilla.org/en/docs/Web/API/Attr) to Kotlin\n */\npublic external abstract class Attr : Node {\n    open val namespaceURI: String?\n    open val prefix: String?\n    open val localName: String\n    open val name: String\n    open var value: String\n    open val ownerElement: Element?\n    open val specified: Boolean\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CharacterData](https://developer.mozilla.org/en/docs/Web/API/CharacterData) to Kotlin\n */\npublic external abstract class CharacterData : Node, NonDocumentTypeChildNode, ChildNode {\n    open var data: String\n    open val length: Int\n    fun substringData(offset: Int, count: Int): String\n    fun appendData(data: String)\n    fun insertData(offset: Int, data: String)\n    fun deleteData(offset: Int, count: Int)\n    fun replaceData(offset: Int, count: Int, data: String)\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Text](https://developer.mozilla.org/en/docs/Web/API/Text) to Kotlin\n */\npublic external open class Text(data: String = definedExternally) : CharacterData, Slotable, GeometryUtils {\n    open val wholeText: String\n    override val assignedSlot: HTMLSlotElement?\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    fun splitText(offset: Int): Text\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [CDATASection](https://developer.mozilla.org/en/docs/Web/API/CDATASection) to Kotlin\n */\npublic external open class CDATASection : Text {\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [ProcessingInstruction](https://developer.mozilla.org/en/docs/Web/API/ProcessingInstruction) to Kotlin\n */\npublic external abstract class ProcessingInstruction : CharacterData, LinkStyle, UnionElementOrProcessingInstruction {\n    open val target: String\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Comment](https://developer.mozilla.org/en/docs/Web/API/Comment) to Kotlin\n */\npublic external open class Comment(data: String = definedExternally) : CharacterData {\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Range](https://developer.mozilla.org/en/docs/Web/API/Range) to Kotlin\n */\npublic external open class Range {\n    open val startContainer: Node\n    open val startOffset: Int\n    open val endContainer: Node\n    open val endOffset: Int\n    open val collapsed: Boolean\n    open val commonAncestorContainer: Node\n    fun setStart(node: Node, offset: Int)\n    fun setEnd(node: Node, offset: Int)\n    fun setStartBefore(node: Node)\n    fun setStartAfter(node: Node)\n    fun setEndBefore(node: Node)\n    fun setEndAfter(node: Node)\n    fun collapse(toStart: Boolean = definedExternally)\n    fun selectNode(node: Node)\n    fun selectNodeContents(node: Node)\n    fun compareBoundaryPoints(how: Short, sourceRange: Range): Short\n    fun deleteContents()\n    fun extractContents(): DocumentFragment\n    fun cloneContents(): DocumentFragment\n    fun insertNode(node: Node)\n    fun surroundContents(newParent: Node)\n    fun cloneRange(): Range\n    fun detach()\n    fun isPointInRange(node: Node, offset: Int): Boolean\n    fun comparePoint(node: Node, offset: Int): Short\n    fun intersectsNode(node: Node): Boolean\n    fun getClientRects(): Array<DOMRect>\n    fun getBoundingClientRect(): DOMRect\n    fun createContextualFragment(fragment: String): DocumentFragment\n\n    companion object {\n        val START_TO_START: Short\n        val START_TO_END: Short\n        val END_TO_END: Short\n        val END_TO_START: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [NodeIterator](https://developer.mozilla.org/en/docs/Web/API/NodeIterator) to Kotlin\n */\npublic external abstract class NodeIterator {\n    open val root: Node\n    open val referenceNode: Node\n    open val pointerBeforeReferenceNode: Boolean\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    fun nextNode(): Node?\n    fun previousNode(): Node?\n    fun detach()\n}\n\n/**\n * Exposes the JavaScript [TreeWalker](https://developer.mozilla.org/en/docs/Web/API/TreeWalker) to Kotlin\n */\npublic external abstract class TreeWalker {\n    open val root: Node\n    open val whatToShow: Int\n    open val filter: NodeFilter?\n    open var currentNode: Node\n    fun parentNode(): Node?\n    fun firstChild(): Node?\n    fun lastChild(): Node?\n    fun previousSibling(): Node?\n    fun nextSibling(): Node?\n    fun previousNode(): Node?\n    fun nextNode(): Node?\n}\n\n/**\n * Exposes the JavaScript [NodeFilter](https://developer.mozilla.org/en/docs/Web/API/NodeFilter) to Kotlin\n */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface NodeFilter {\n    fun acceptNode(node: Node): Short\n\n    companion object {\n        val FILTER_ACCEPT: Short\n        val FILTER_REJECT: Short\n        val FILTER_SKIP: Short\n        val SHOW_ALL: Int\n        val SHOW_ELEMENT: Int\n        val SHOW_ATTRIBUTE: Int\n        val SHOW_TEXT: Int\n        val SHOW_CDATA_SECTION: Int\n        val SHOW_ENTITY_REFERENCE: Int\n        val SHOW_ENTITY: Int\n        val SHOW_PROCESSING_INSTRUCTION: Int\n        val SHOW_COMMENT: Int\n        val SHOW_DOCUMENT: Int\n        val SHOW_DOCUMENT_TYPE: Int\n        val SHOW_DOCUMENT_FRAGMENT: Int\n        val SHOW_NOTATION: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [DOMTokenList](https://developer.mozilla.org/en/docs/Web/API/DOMTokenList) to Kotlin\n */\npublic external abstract class DOMTokenList : ItemArrayLike<String> {\n    open var value: String\n    fun contains(token: String): Boolean\n    fun add(vararg tokens: String)\n    fun remove(vararg tokens: String)\n    fun toggle(token: String, force: Boolean = definedExternally): Boolean\n    fun replace(token: String, newToken: String)\n    fun supports(token: String): Boolean\n    override fun item(index: Int): String?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMTokenList.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMPointReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMPointReadOnly) to Kotlin\n */\npublic external open class DOMPointReadOnly(x: Double, y: Double, z: Double, w: Double) {\n    open val x: Double\n    open val y: Double\n    open val z: Double\n    open val w: Double\n    fun matrixTransform(matrix: DOMMatrixReadOnly): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [DOMPoint](https://developer.mozilla.org/en/docs/Web/API/DOMPoint) to Kotlin\n */\npublic external open class DOMPoint : DOMPointReadOnly {\n    constructor(point: DOMPointInit)\n    constructor(x: Double = definedExternally, y: Double = definedExternally, z: Double = definedExternally, w: Double = definedExternally)\n    override var x: Double\n    override var y: Double\n    override var z: Double\n    override var w: Double\n}\n\n/**\n * Exposes the JavaScript [DOMPointInit](https://developer.mozilla.org/en/docs/Web/API/DOMPointInit) to Kotlin\n */\npublic external interface DOMPointInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var z: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var w: Double? /* = 1.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMPointInit(x: Double? = 0.0, y: Double? = 0.0, z: Double? = 0.0, w: Double? = 1.0): DOMPointInit {\n    val o = js(\"({})\")\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"z\"] = z\n    o[\"w\"] = w\n    return o\n}\n\n/**\n * Exposes the JavaScript [DOMRect](https://developer.mozilla.org/en/docs/Web/API/DOMRect) to Kotlin\n */\npublic external open class DOMRect(x: Double = definedExternally, y: Double = definedExternally, width: Double = definedExternally, height: Double = definedExternally) : DOMRectReadOnly {\n    override var x: Double\n    override var y: Double\n    override var width: Double\n    override var height: Double\n}\n\n/**\n * Exposes the JavaScript [DOMRectReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMRectReadOnly) to Kotlin\n */\npublic external open class DOMRectReadOnly(x: Double, y: Double, width: Double, height: Double) {\n    open val x: Double\n    open val y: Double\n    open val width: Double\n    open val height: Double\n    open val top: Double\n    open val right: Double\n    open val bottom: Double\n    open val left: Double\n}\n\npublic external interface DOMRectInit {\n    var x: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var y: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var width: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var height: Double? /* = 0.0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun DOMRectInit(x: Double? = 0.0, y: Double? = 0.0, width: Double? = 0.0, height: Double? = 0.0): DOMRectInit {\n    val o = js(\"({})\")\n    o[\"x\"] = x\n    o[\"y\"] = y\n    o[\"width\"] = width\n    o[\"height\"] = height\n    return o\n}\n\npublic external interface DOMRectList : ItemArrayLike<DOMRect> {\n    override fun item(index: Int): DOMRect?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun DOMRectList.get(index: Int): DOMRect? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [DOMQuad](https://developer.mozilla.org/en/docs/Web/API/DOMQuad) to Kotlin\n */\npublic external open class DOMQuad {\n    constructor(p1: DOMPointInit = definedExternally, p2: DOMPointInit = definedExternally, p3: DOMPointInit = definedExternally, p4: DOMPointInit = definedExternally)\n    constructor(rect: DOMRectInit)\n    open val p1: DOMPoint\n    open val p2: DOMPoint\n    open val p3: DOMPoint\n    open val p4: DOMPoint\n    open val bounds: DOMRectReadOnly\n}\n\n/**\n * Exposes the JavaScript [DOMMatrixReadOnly](https://developer.mozilla.org/en/docs/Web/API/DOMMatrixReadOnly) to Kotlin\n */\npublic external open class DOMMatrixReadOnly(numberSequence: Array<Double>) {\n    open val a: Double\n    open val b: Double\n    open val c: Double\n    open val d: Double\n    open val e: Double\n    open val f: Double\n    open val m11: Double\n    open val m12: Double\n    open val m13: Double\n    open val m14: Double\n    open val m21: Double\n    open val m22: Double\n    open val m23: Double\n    open val m24: Double\n    open val m31: Double\n    open val m32: Double\n    open val m33: Double\n    open val m34: Double\n    open val m41: Double\n    open val m42: Double\n    open val m43: Double\n    open val m44: Double\n    open val is2D: Boolean\n    open val isIdentity: Boolean\n    fun translate(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scale(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3d(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniform(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotate(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVector(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngle(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewX(sx: Double): DOMMatrix\n    fun skewY(sy: Double): DOMMatrix\n    fun multiply(other: DOMMatrix): DOMMatrix\n    fun flipX(): DOMMatrix\n    fun flipY(): DOMMatrix\n    fun inverse(): DOMMatrix\n    fun transformPoint(point: DOMPointInit = definedExternally): DOMPoint\n    fun toFloat32Array(): Float32Array\n    fun toFloat64Array(): Float64Array\n}\n\n/**\n * Exposes the JavaScript [DOMMatrix](https://developer.mozilla.org/en/docs/Web/API/DOMMatrix) to Kotlin\n */\npublic external open class DOMMatrix() : DOMMatrixReadOnly {\n    constructor(transformList: String)\n    constructor(other: DOMMatrixReadOnly)\n    constructor(array32: Float32Array)\n    constructor(array64: Float64Array)\n    constructor(numberSequence: Array<Double>)\n    override var a: Double\n    override var b: Double\n    override var c: Double\n    override var d: Double\n    override var e: Double\n    override var f: Double\n    override var m11: Double\n    override var m12: Double\n    override var m13: Double\n    override var m14: Double\n    override var m21: Double\n    override var m22: Double\n    override var m23: Double\n    override var m24: Double\n    override var m31: Double\n    override var m32: Double\n    override var m33: Double\n    override var m34: Double\n    override var m41: Double\n    override var m42: Double\n    override var m43: Double\n    override var m44: Double\n    fun multiplySelf(other: DOMMatrix): DOMMatrix\n    fun preMultiplySelf(other: DOMMatrix): DOMMatrix\n    fun translateSelf(tx: Double, ty: Double, tz: Double = definedExternally): DOMMatrix\n    fun scaleSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun scale3dSelf(scale: Double, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun scaleNonUniformSelf(scaleX: Double, scaleY: Double = definedExternally, scaleZ: Double = definedExternally, originX: Double = definedExternally, originY: Double = definedExternally, originZ: Double = definedExternally): DOMMatrix\n    fun rotateSelf(angle: Double, originX: Double = definedExternally, originY: Double = definedExternally): DOMMatrix\n    fun rotateFromVectorSelf(x: Double, y: Double): DOMMatrix\n    fun rotateAxisAngleSelf(x: Double, y: Double, z: Double, angle: Double): DOMMatrix\n    fun skewXSelf(sx: Double): DOMMatrix\n    fun skewYSelf(sy: Double): DOMMatrix\n    fun invertSelf(): DOMMatrix\n    fun setMatrixValue(transformList: String): DOMMatrix\n}\n\npublic external interface ScrollOptions {\n    var behavior: ScrollBehavior? /* = ScrollBehavior.AUTO */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollOptions(behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollOptions {\n    val o = js(\"({})\")\n    o[\"behavior\"] = behavior\n    return o\n}\n\n/**\n * Exposes the JavaScript [ScrollToOptions](https://developer.mozilla.org/en/docs/Web/API/ScrollToOptions) to Kotlin\n */\npublic external interface ScrollToOptions : ScrollOptions {\n    var left: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n    var top: Double?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollToOptions(left: Double? = undefined, top: Double? = undefined, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollToOptions {\n    val o = js(\"({})\")\n    o[\"left\"] = left\n    o[\"top\"] = top\n    o[\"behavior\"] = behavior\n    return o\n}\n\n/**\n * Exposes the JavaScript [MediaQueryList](https://developer.mozilla.org/en/docs/Web/API/MediaQueryList) to Kotlin\n */\npublic external abstract class MediaQueryList : EventTarget {\n    open val media: String\n    open val matches: Boolean\n    open var onchange: ((Event) -> dynamic)?\n    fun addListener(listener: EventListener?)\n    fun addListener(listener: ((Event) -> Unit)?)\n    fun removeListener(listener: EventListener?)\n    fun removeListener(listener: ((Event) -> Unit)?)\n}\n\n/**\n * Exposes the JavaScript [MediaQueryListEvent](https://developer.mozilla.org/en/docs/Web/API/MediaQueryListEvent) to Kotlin\n */\npublic external open class MediaQueryListEvent(type: String, eventInitDict: MediaQueryListEventInit = definedExternally) : Event {\n    open val media: String\n    open val matches: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface MediaQueryListEventInit : EventInit {\n    var media: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n    var matches: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun MediaQueryListEventInit(media: String? = \"\", matches: Boolean? = false, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): MediaQueryListEventInit {\n    val o = js(\"({})\")\n    o[\"media\"] = media\n    o[\"matches\"] = matches\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [Screen](https://developer.mozilla.org/en/docs/Web/API/Screen) to Kotlin\n */\npublic external abstract class Screen {\n    open val availWidth: Int\n    open val availHeight: Int\n    open val width: Int\n    open val height: Int\n    open val colorDepth: Int\n    open val pixelDepth: Int\n}\n\n/**\n * Exposes the JavaScript [CaretPosition](https://developer.mozilla.org/en/docs/Web/API/CaretPosition) to Kotlin\n */\npublic external abstract class CaretPosition {\n    open val offsetNode: Node\n    open val offset: Int\n    fun getClientRect(): DOMRect?\n}\n\npublic external interface ScrollIntoViewOptions : ScrollOptions {\n    var block: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var inline: ScrollLogicalPosition? /* = ScrollLogicalPosition.CENTER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ScrollIntoViewOptions(block: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, inline: ScrollLogicalPosition? = ScrollLogicalPosition.CENTER, behavior: ScrollBehavior? = ScrollBehavior.AUTO): ScrollIntoViewOptions {\n    val o = js(\"({})\")\n    o[\"block\"] = block\n    o[\"inline\"] = inline\n    o[\"behavior\"] = behavior\n    return o\n}\n\npublic external interface BoxQuadOptions {\n    var box: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var relativeTo: dynamic\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BoxQuadOptions(box: CSSBoxType? = CSSBoxType.BORDER, relativeTo: dynamic = undefined): BoxQuadOptions {\n    val o = js(\"({})\")\n    o[\"box\"] = box\n    o[\"relativeTo\"] = relativeTo\n    return o\n}\n\npublic external interface ConvertCoordinateOptions {\n    var fromBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n    var toBox: CSSBoxType? /* = CSSBoxType.BORDER */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ConvertCoordinateOptions(fromBox: CSSBoxType? = CSSBoxType.BORDER, toBox: CSSBoxType? = CSSBoxType.BORDER): ConvertCoordinateOptions {\n    val o = js(\"({})\")\n    o[\"fromBox\"] = fromBox\n    o[\"toBox\"] = toBox\n    return o\n}\n\n/**\n * Exposes the JavaScript [GeometryUtils](https://developer.mozilla.org/en/docs/Web/API/GeometryUtils) to Kotlin\n */\npublic external interface GeometryUtils {\n    fun getBoxQuads(options: BoxQuadOptions = definedExternally): Array<DOMQuad>\n    fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMQuad\n    fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions = definedExternally): DOMPoint\n}\n\n/**\n * Exposes the JavaScript [Touch](https://developer.mozilla.org/en/docs/Web/API/Touch) to Kotlin\n */\npublic external abstract class Touch {\n    open val identifier: Int\n    open val target: EventTarget\n    open val screenX: Int\n    open val screenY: Int\n    open val clientX: Int\n    open val clientY: Int\n    open val pageX: Int\n    open val pageY: Int\n    open val region: String?\n}\n\npublic external abstract class TouchList : ItemArrayLike<Touch> {\n    override fun item(index: Int): Touch?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun TouchList.get(index: Int): Touch? = asDynamic()[index]\n\npublic external open class TouchEvent : UIEvent {\n    open val touches: TouchList\n    open val targetTouches: TouchList\n    open val changedTouches: TouchList\n    open val altKey: Boolean\n    open val metaKey: Boolean\n    open val ctrlKey: Boolean\n    open val shiftKey: Boolean\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Image](https://developer.mozilla.org/en/docs/Web/API/Image) to Kotlin\n */\npublic external open class Image(width: Int = definedExternally, height: Int = definedExternally) : HTMLImageElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external open class Audio(src: String = definedExternally) : HTMLAudioElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val NETWORK_EMPTY: Short\n        val NETWORK_IDLE: Short\n        val NETWORK_LOADING: Short\n        val NETWORK_NO_SOURCE: Short\n        val HAVE_NOTHING: Short\n        val HAVE_METADATA: Short\n        val HAVE_CURRENT_DATA: Short\n        val HAVE_FUTURE_DATA: Short\n        val HAVE_ENOUGH_DATA: Short\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [Option](https://developer.mozilla.org/en/docs/Web/API/Option) to Kotlin\n */\npublic external open class Option(text: String = definedExternally, value: String = definedExternally, defaultSelected: Boolean = definedExternally, selected: Boolean = definedExternally) : HTMLOptionElement {\n    override var onabort: ((Event) -> dynamic)?\n    override var onblur: ((FocusEvent) -> dynamic)?\n    override var oncancel: ((Event) -> dynamic)?\n    override var oncanplay: ((Event) -> dynamic)?\n    override var oncanplaythrough: ((Event) -> dynamic)?\n    override var onchange: ((Event) -> dynamic)?\n    override var onclick: ((MouseEvent) -> dynamic)?\n    override var onclose: ((Event) -> dynamic)?\n    override var oncontextmenu: ((MouseEvent) -> dynamic)?\n    override var oncuechange: ((Event) -> dynamic)?\n    override var ondblclick: ((MouseEvent) -> dynamic)?\n    override var ondrag: ((DragEvent) -> dynamic)?\n    override var ondragend: ((DragEvent) -> dynamic)?\n    override var ondragenter: ((DragEvent) -> dynamic)?\n    override var ondragexit: ((DragEvent) -> dynamic)?\n    override var ondragleave: ((DragEvent) -> dynamic)?\n    override var ondragover: ((DragEvent) -> dynamic)?\n    override var ondragstart: ((DragEvent) -> dynamic)?\n    override var ondrop: ((DragEvent) -> dynamic)?\n    override var ondurationchange: ((Event) -> dynamic)?\n    override var onemptied: ((Event) -> dynamic)?\n    override var onended: ((Event) -> dynamic)?\n    override var onerror: ((dynamic, String, Int, Int, Any?) -> dynamic)?\n    override var onfocus: ((FocusEvent) -> dynamic)?\n    override var oninput: ((InputEvent) -> dynamic)?\n    override var oninvalid: ((Event) -> dynamic)?\n    override var onkeydown: ((KeyboardEvent) -> dynamic)?\n    override var onkeypress: ((KeyboardEvent) -> dynamic)?\n    override var onkeyup: ((KeyboardEvent) -> dynamic)?\n    override var onload: ((Event) -> dynamic)?\n    override var onloadeddata: ((Event) -> dynamic)?\n    override var onloadedmetadata: ((Event) -> dynamic)?\n    override var onloadend: ((Event) -> dynamic)?\n    override var onloadstart: ((ProgressEvent) -> dynamic)?\n    override var onmousedown: ((MouseEvent) -> dynamic)?\n    override var onmouseenter: ((MouseEvent) -> dynamic)?\n    override var onmouseleave: ((MouseEvent) -> dynamic)?\n    override var onmousemove: ((MouseEvent) -> dynamic)?\n    override var onmouseout: ((MouseEvent) -> dynamic)?\n    override var onmouseover: ((MouseEvent) -> dynamic)?\n    override var onmouseup: ((MouseEvent) -> dynamic)?\n    override var onwheel: ((WheelEvent) -> dynamic)?\n    override var onpause: ((Event) -> dynamic)?\n    override var onplay: ((Event) -> dynamic)?\n    override var onplaying: ((Event) -> dynamic)?\n    override var onprogress: ((ProgressEvent) -> dynamic)?\n    override var onratechange: ((Event) -> dynamic)?\n    override var onreset: ((Event) -> dynamic)?\n    override var onresize: ((Event) -> dynamic)?\n    override var onscroll: ((Event) -> dynamic)?\n    override var onseeked: ((Event) -> dynamic)?\n    override var onseeking: ((Event) -> dynamic)?\n    override var onselect: ((Event) -> dynamic)?\n    override var onshow: ((Event) -> dynamic)?\n    override var onstalled: ((Event) -> dynamic)?\n    override var onsubmit: ((Event) -> dynamic)?\n    override var onsuspend: ((Event) -> dynamic)?\n    override var ontimeupdate: ((Event) -> dynamic)?\n    override var ontoggle: ((Event) -> dynamic)?\n    override var onvolumechange: ((Event) -> dynamic)?\n    override var onwaiting: ((Event) -> dynamic)?\n    override var ongotpointercapture: ((PointerEvent) -> dynamic)?\n    override var onlostpointercapture: ((PointerEvent) -> dynamic)?\n    override var onpointerdown: ((PointerEvent) -> dynamic)?\n    override var onpointermove: ((PointerEvent) -> dynamic)?\n    override var onpointerup: ((PointerEvent) -> dynamic)?\n    override var onpointercancel: ((PointerEvent) -> dynamic)?\n    override var onpointerover: ((PointerEvent) -> dynamic)?\n    override var onpointerout: ((PointerEvent) -> dynamic)?\n    override var onpointerenter: ((PointerEvent) -> dynamic)?\n    override var onpointerleave: ((PointerEvent) -> dynamic)?\n    override var oncopy: ((ClipboardEvent) -> dynamic)?\n    override var oncut: ((ClipboardEvent) -> dynamic)?\n    override var onpaste: ((ClipboardEvent) -> dynamic)?\n    override var contentEditable: String\n    override val isContentEditable: Boolean\n    override val style: CSSStyleDeclaration\n    override val children: HTMLCollection\n    override val firstElementChild: Element?\n    override val lastElementChild: Element?\n    override val childElementCount: Int\n    override val previousElementSibling: Element?\n    override val nextElementSibling: Element?\n    override val assignedSlot: HTMLSlotElement?\n    override fun prepend(vararg nodes: dynamic)\n    override fun append(vararg nodes: dynamic)\n    override fun querySelector(selectors: String): Element?\n    override fun querySelectorAll(selectors: String): NodeList\n    override fun before(vararg nodes: dynamic)\n    override fun after(vararg nodes: dynamic)\n    override fun replaceWith(vararg nodes: dynamic)\n    override fun remove()\n    override fun getBoxQuads(options: BoxQuadOptions /* = definedExternally */): Array<DOMQuad>\n    override fun convertQuadFromNode(quad: dynamic, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertRectFromNode(rect: DOMRectReadOnly, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMQuad\n    override fun convertPointFromNode(point: DOMPointInit, from: dynamic, options: ConvertCoordinateOptions /* = definedExternally */): DOMPoint\n\n    companion object {\n        val ELEMENT_NODE: Short\n        val ATTRIBUTE_NODE: Short\n        val TEXT_NODE: Short\n        val CDATA_SECTION_NODE: Short\n        val ENTITY_REFERENCE_NODE: Short\n        val ENTITY_NODE: Short\n        val PROCESSING_INSTRUCTION_NODE: Short\n        val COMMENT_NODE: Short\n        val DOCUMENT_NODE: Short\n        val DOCUMENT_TYPE_NODE: Short\n        val DOCUMENT_FRAGMENT_NODE: Short\n        val NOTATION_NODE: Short\n        val DOCUMENT_POSITION_DISCONNECTED: Short\n        val DOCUMENT_POSITION_PRECEDING: Short\n        val DOCUMENT_POSITION_FOLLOWING: Short\n        val DOCUMENT_POSITION_CONTAINS: Short\n        val DOCUMENT_POSITION_CONTAINED_BY: Short\n        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short\n    }\n}\n\npublic external interface UnionElementOrHTMLCollection\n\npublic external interface UnionElementOrRadioNodeList\n\npublic external interface UnionHTMLOptGroupElementOrHTMLOptionElement\n\npublic external interface UnionAudioTrackOrTextTrackOrVideoTrack\n\npublic external interface UnionElementOrMouseEvent\n\npublic external interface RenderingContext\n\npublic external interface HTMLOrSVGImageElement : CanvasImageSource\n\npublic external interface CanvasImageSource : ImageBitmapSource\n\npublic external interface ImageBitmapSource\n\npublic external interface UnionMessagePortOrWindowProxy\n\npublic external interface HTMLOrSVGScriptElement\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface DocumentReadyState {\n    companion object\n}\n\npublic inline val DocumentReadyState.Companion.LOADING: DocumentReadyState get() = \"loading\".asDynamic().unsafeCast<DocumentReadyState>()\n\npublic inline val DocumentReadyState.Companion.INTERACTIVE: DocumentReadyState get() = \"interactive\".asDynamic().unsafeCast<DocumentReadyState>()\n\npublic inline val DocumentReadyState.Companion.COMPLETE: DocumentReadyState get() = \"complete\".asDynamic().unsafeCast<DocumentReadyState>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanPlayTypeResult {\n    companion object\n}\n\npublic inline val CanPlayTypeResult.Companion.EMPTY: CanPlayTypeResult get() = \"\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\npublic inline val CanPlayTypeResult.Companion.MAYBE: CanPlayTypeResult get() = \"maybe\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\npublic inline val CanPlayTypeResult.Companion.PROBABLY: CanPlayTypeResult get() = \"probably\".asDynamic().unsafeCast<CanPlayTypeResult>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface TextTrackMode {\n    companion object\n}\n\npublic inline val TextTrackMode.Companion.DISABLED: TextTrackMode get() = \"disabled\".asDynamic().unsafeCast<TextTrackMode>()\n\npublic inline val TextTrackMode.Companion.HIDDEN: TextTrackMode get() = \"hidden\".asDynamic().unsafeCast<TextTrackMode>()\n\npublic inline val TextTrackMode.Companion.SHOWING: TextTrackMode get() = \"showing\".asDynamic().unsafeCast<TextTrackMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface TextTrackKind {\n    companion object\n}\n\npublic inline val TextTrackKind.Companion.SUBTITLES: TextTrackKind get() = \"subtitles\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.CAPTIONS: TextTrackKind get() = \"captions\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.DESCRIPTIONS: TextTrackKind get() = \"descriptions\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.CHAPTERS: TextTrackKind get() = \"chapters\".asDynamic().unsafeCast<TextTrackKind>()\n\npublic inline val TextTrackKind.Companion.METADATA: TextTrackKind get() = \"metadata\".asDynamic().unsafeCast<TextTrackKind>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface SelectionMode {\n    companion object\n}\n\npublic inline val SelectionMode.Companion.SELECT: SelectionMode get() = \"select\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.START: SelectionMode get() = \"start\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.END: SelectionMode get() = \"end\".asDynamic().unsafeCast<SelectionMode>()\n\npublic inline val SelectionMode.Companion.PRESERVE: SelectionMode get() = \"preserve\".asDynamic().unsafeCast<SelectionMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasFillRule {\n    companion object\n}\n\npublic inline val CanvasFillRule.Companion.NONZERO: CanvasFillRule get() = \"nonzero\".asDynamic().unsafeCast<CanvasFillRule>()\n\npublic inline val CanvasFillRule.Companion.EVENODD: CanvasFillRule get() = \"evenodd\".asDynamic().unsafeCast<CanvasFillRule>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ImageSmoothingQuality {\n    companion object\n}\n\npublic inline val ImageSmoothingQuality.Companion.LOW: ImageSmoothingQuality get() = \"low\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\npublic inline val ImageSmoothingQuality.Companion.MEDIUM: ImageSmoothingQuality get() = \"medium\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\npublic inline val ImageSmoothingQuality.Companion.HIGH: ImageSmoothingQuality get() = \"high\".asDynamic().unsafeCast<ImageSmoothingQuality>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasLineCap {\n    companion object\n}\n\npublic inline val CanvasLineCap.Companion.BUTT: CanvasLineCap get() = \"butt\".asDynamic().unsafeCast<CanvasLineCap>()\n\npublic inline val CanvasLineCap.Companion.ROUND: CanvasLineCap get() = \"round\".asDynamic().unsafeCast<CanvasLineCap>()\n\npublic inline val CanvasLineCap.Companion.SQUARE: CanvasLineCap get() = \"square\".asDynamic().unsafeCast<CanvasLineCap>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasLineJoin {\n    companion object\n}\n\npublic inline val CanvasLineJoin.Companion.ROUND: CanvasLineJoin get() = \"round\".asDynamic().unsafeCast<CanvasLineJoin>()\n\npublic inline val CanvasLineJoin.Companion.BEVEL: CanvasLineJoin get() = \"bevel\".asDynamic().unsafeCast<CanvasLineJoin>()\n\npublic inline val CanvasLineJoin.Companion.MITER: CanvasLineJoin get() = \"miter\".asDynamic().unsafeCast<CanvasLineJoin>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasTextAlign {\n    companion object\n}\n\npublic inline val CanvasTextAlign.Companion.START: CanvasTextAlign get() = \"start\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.END: CanvasTextAlign get() = \"end\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.LEFT: CanvasTextAlign get() = \"left\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.RIGHT: CanvasTextAlign get() = \"right\".asDynamic().unsafeCast<CanvasTextAlign>()\n\npublic inline val CanvasTextAlign.Companion.CENTER: CanvasTextAlign get() = \"center\".asDynamic().unsafeCast<CanvasTextAlign>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasTextBaseline {\n    companion object\n}\n\npublic inline val CanvasTextBaseline.Companion.TOP: CanvasTextBaseline get() = \"top\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.HANGING: CanvasTextBaseline get() = \"hanging\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.MIDDLE: CanvasTextBaseline get() = \"middle\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.ALPHABETIC: CanvasTextBaseline get() = \"alphabetic\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.IDEOGRAPHIC: CanvasTextBaseline get() = \"ideographic\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\npublic inline val CanvasTextBaseline.Companion.BOTTOM: CanvasTextBaseline get() = \"bottom\".asDynamic().unsafeCast<CanvasTextBaseline>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CanvasDirection {\n    companion object\n}\n\npublic inline val CanvasDirection.Companion.LTR: CanvasDirection get() = \"ltr\".asDynamic().unsafeCast<CanvasDirection>()\n\npublic inline val CanvasDirection.Companion.RTL: CanvasDirection get() = \"rtl\".asDynamic().unsafeCast<CanvasDirection>()\n\npublic inline val CanvasDirection.Companion.INHERIT: CanvasDirection get() = \"inherit\".asDynamic().unsafeCast<CanvasDirection>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollRestoration {\n    companion object\n}\n\npublic inline val ScrollRestoration.Companion.AUTO: ScrollRestoration get() = \"auto\".asDynamic().unsafeCast<ScrollRestoration>()\n\npublic inline val ScrollRestoration.Companion.MANUAL: ScrollRestoration get() = \"manual\".asDynamic().unsafeCast<ScrollRestoration>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ImageOrientation {\n    companion object\n}\n\npublic inline val ImageOrientation.Companion.NONE: ImageOrientation get() = \"none\".asDynamic().unsafeCast<ImageOrientation>()\n\npublic inline val ImageOrientation.Companion.FLIPY: ImageOrientation get() = \"flipY\".asDynamic().unsafeCast<ImageOrientation>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface PremultiplyAlpha {\n    companion object\n}\n\npublic inline val PremultiplyAlpha.Companion.NONE: PremultiplyAlpha get() = \"none\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\npublic inline val PremultiplyAlpha.Companion.PREMULTIPLY: PremultiplyAlpha get() = \"premultiply\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\npublic inline val PremultiplyAlpha.Companion.DEFAULT: PremultiplyAlpha get() = \"default\".asDynamic().unsafeCast<PremultiplyAlpha>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ColorSpaceConversion {\n    companion object\n}\n\npublic inline val ColorSpaceConversion.Companion.NONE: ColorSpaceConversion get() = \"none\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\npublic inline val ColorSpaceConversion.Companion.DEFAULT: ColorSpaceConversion get() = \"default\".asDynamic().unsafeCast<ColorSpaceConversion>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ResizeQuality {\n    companion object\n}\n\npublic inline val ResizeQuality.Companion.PIXELATED: ResizeQuality get() = \"pixelated\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.LOW: ResizeQuality get() = \"low\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.MEDIUM: ResizeQuality get() = \"medium\".asDynamic().unsafeCast<ResizeQuality>()\n\npublic inline val ResizeQuality.Companion.HIGH: ResizeQuality get() = \"high\".asDynamic().unsafeCast<ResizeQuality>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface BinaryType {\n    companion object\n}\n\npublic inline val BinaryType.Companion.BLOB: BinaryType get() = \"blob\".asDynamic().unsafeCast<BinaryType>()\n\npublic inline val BinaryType.Companion.ARRAYBUFFER: BinaryType get() = \"arraybuffer\".asDynamic().unsafeCast<BinaryType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WorkerType {\n    companion object\n}\n\npublic inline val WorkerType.Companion.CLASSIC: WorkerType get() = \"classic\".asDynamic().unsafeCast<WorkerType>()\n\npublic inline val WorkerType.Companion.MODULE: WorkerType get() = \"module\".asDynamic().unsafeCast<WorkerType>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ShadowRootMode {\n    companion object\n}\n\npublic inline val ShadowRootMode.Companion.OPEN: ShadowRootMode get() = \"open\".asDynamic().unsafeCast<ShadowRootMode>()\n\npublic inline val ShadowRootMode.Companion.CLOSED: ShadowRootMode get() = \"closed\".asDynamic().unsafeCast<ShadowRootMode>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollBehavior {\n    companion object\n}\n\npublic inline val ScrollBehavior.Companion.AUTO: ScrollBehavior get() = \"auto\".asDynamic().unsafeCast<ScrollBehavior>()\n\npublic inline val ScrollBehavior.Companion.INSTANT: ScrollBehavior get() = \"instant\".asDynamic().unsafeCast<ScrollBehavior>()\n\npublic inline val ScrollBehavior.Companion.SMOOTH: ScrollBehavior get() = \"smooth\".asDynamic().unsafeCast<ScrollBehavior>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface ScrollLogicalPosition {\n    companion object\n}\n\npublic inline val ScrollLogicalPosition.Companion.START: ScrollLogicalPosition get() = \"start\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.CENTER: ScrollLogicalPosition get() = \"center\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.END: ScrollLogicalPosition get() = \"end\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\npublic inline val ScrollLogicalPosition.Companion.NEAREST: ScrollLogicalPosition get() = \"nearest\".asDynamic().unsafeCast<ScrollLogicalPosition>()\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface CSSBoxType {\n    companion object\n}\n\npublic inline val CSSBoxType.Companion.MARGIN: CSSBoxType get() = \"margin\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.BORDER: CSSBoxType get() = \"border\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.PADDING: CSSBoxType get() = \"padding\".asDynamic().unsafeCast<CSSBoxType>()\n\npublic inline val CSSBoxType.Companion.CONTENT: CSSBoxType get() = \"content\".asDynamic().unsafeCast<CSSBoxType>()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package venus.api.venusbackend.simulator\r\n\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n@JsName(\"Simulator\") object Simulator {\r\n    @JsName(\"isDone\") fun isDone(sim: Simulator): Boolean {\r\n        return sim.isDone()\r\n    }\r\n\r\n    @JsName(\"getCycles\") fun getCycles(sim: Simulator): Int {\r\n        return sim.getCycles()\r\n    }\r\n\r\n    @JsName(\"addArg\") fun addArg(sim: Simulator, arg: String) {\r\n        sim.addArg(arg)\r\n    }\r\n\r\n    @JsName(\"step\") fun step(sim: Simulator) {\r\n        sim.step()\r\n    }\r\n\r\n    @JsName(\"getReg\") fun getReg(sim: Simulator, id: Int): Number {\r\n        return sim.getReg(id)\r\n    }\r\n\r\n    @JsName(\"getFReg\") fun getFReg(sim: Simulator, id: Int): Decimal {\r\n        return sim.getFReg(id)\r\n    }\r\n\r\n    @JsName(\"loadByte\") fun loadByte(sim: Simulator, addr: Number): Int {\r\n        return sim.loadByte(addr)\r\n    }\r\n\r\n    @JsName(\"reset\") fun reset(sim: Simulator) {\r\n        sim.reset()\r\n    }\r\n}","package venus\r\n\r\nclass CookieJar() {\r\n    init {\r\n        js(\"/*!\\n\" +\r\n                \" * JavaScript Cookie v2.2.0\\n\" +\r\n                \" * https://github.com/js-cookie/js-cookie\\n\" +\r\n                \" *\\n\" +\r\n                \" * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\\n\" +\r\n                \" * Released under the MIT license\\n\" +\r\n                \" */\\n\" +\r\n                \";(function (factory) {\\n\" +\r\n                \"\\tvar registeredInModuleLoader = false;\\n\" +\r\n                \"\\tif (typeof define === 'function' && define.amd) {\\n\" +\r\n                \"\\t\\tdefine(factory);\\n\" +\r\n                \"\\t\\tregisteredInModuleLoader = true;\\n\" +\r\n                \"\\t}\\n\" +\r\n                \"\\tif (typeof exports === 'object') {\\n\" +\r\n                \"\\t\\tmodule.exports = factory();\\n\" +\r\n                \"\\t\\tregisteredInModuleLoader = true;\\n\" +\r\n                \"\\t}\\n\" +\r\n                \"\\tif (!registeredInModuleLoader) {\\n\" +\r\n                \"\\t\\tvar OldCookies = window.Cookies;\\n\" +\r\n                \"\\t\\tvar api = window.Cookies = factory();\\n\" +\r\n                \"\\t\\tapi.noConflict = function () {\\n\" +\r\n                \"\\t\\t\\twindow.Cookies = OldCookies;\\n\" +\r\n                \"\\t\\t\\treturn api;\\n\" +\r\n                \"\\t\\t};\\n\" +\r\n                \"\\t}\\n\" +\r\n                \"}(function () {\\n\" +\r\n                \"\\tfunction extend () {\\n\" +\r\n                \"\\t\\tvar i = 0;\\n\" +\r\n                \"\\t\\tvar result = {};\\n\" +\r\n                \"\\t\\tfor (; i < arguments.length; i++) {\\n\" +\r\n                \"\\t\\t\\tvar attributes = arguments[ i ];\\n\" +\r\n                \"\\t\\t\\tfor (var key in attributes) {\\n\" +\r\n                \"\\t\\t\\t\\tresult[key] = attributes[key];\\n\" +\r\n                \"\\t\\t\\t}\\n\" +\r\n                \"\\t\\t}\\n\" +\r\n                \"\\t\\treturn result;\\n\" +\r\n                \"\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\tfunction init (converter) {\\n\" +\r\n                \"\\t\\tfunction api (key, value, attributes) {\\n\" +\r\n                \"\\t\\t\\tvar result;\\n\" +\r\n                \"\\t\\t\\tif (typeof document === 'undefined') {\\n\" +\r\n                \"\\t\\t\\t\\treturn;\\n\" +\r\n                \"\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t// Write\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\tif (arguments.length > 1) {\\n\" +\r\n                \"\\t\\t\\t\\tattributes = extend({\\n\" +\r\n                \"\\t\\t\\t\\t\\tpath: '/'\\n\" +\r\n                \"\\t\\t\\t\\t}, api.defaults, attributes);\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tif (typeof attributes.expires === 'number') {\\n\" +\r\n                \"\\t\\t\\t\\t\\tvar expires = new Date();\\n\" +\r\n                \"\\t\\t\\t\\t\\texpires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\\n\" +\r\n                \"\\t\\t\\t\\t\\tattributes.expires = expires;\\n\" +\r\n                \"\\t\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\t// We're using \\\"expires\\\" because \\\"max-age\\\" is not supported by IE\\n\" +\r\n                \"\\t\\t\\t\\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\ttry {\\n\" +\r\n                \"\\t\\t\\t\\t\\tresult = JSON.stringify(value);\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (/^[\\\\{\\\\[]/.test(result)) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tvalue = result;\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\t\\t\\t\\t} catch (e) {}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tif (!converter.write) {\\n\" +\r\n                \"\\t\\t\\t\\t\\tvalue = encodeURIComponent(String(value))\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\\n\" +\r\n                \"\\t\\t\\t\\t} else {\\n\" +\r\n                \"\\t\\t\\t\\t\\tvalue = converter.write(value, key);\\n\" +\r\n                \"\\t\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tkey = encodeURIComponent(String(key));\\n\" +\r\n                \"\\t\\t\\t\\tkey = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\\n\" +\r\n                \"\\t\\t\\t\\tkey = key.replace(/[\\\\(\\\\)]/g, escape);\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tvar stringifiedAttributes = '';\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tfor (var attributeName in attributes) {\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (!attributes[attributeName]) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tcontinue;\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\t\\t\\t\\t\\tstringifiedAttributes += '; ' + attributeName;\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (attributes[attributeName] === true) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tcontinue;\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\t\\t\\t\\t\\tstringifiedAttributes += '=' + attributes[attributeName];\\n\" +\r\n                \"\\t\\t\\t\\t}\\n\" +\r\n                \"\\t\\t\\t\\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\\n\" +\r\n                \"\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t// Read\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\tif (!key) {\\n\" +\r\n                \"\\t\\t\\t\\tresult = {};\\n\" +\r\n                \"\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t// To prevent the for loop in the first place assign an empty array\\n\" +\r\n                \"\\t\\t\\t// in case there are no cookies at all. Also prevents odd result when\\n\" +\r\n                \"\\t\\t\\t// calling \\\"get()\\\"\\n\" +\r\n                \"\\t\\t\\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\\n\" +\r\n                \"\\t\\t\\tvar rdecode = /(%[0-9A-Z]{2})+/g;\\n\" +\r\n                \"\\t\\t\\tvar i = 0;\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\tfor (; i < cookies.length; i++) {\\n\" +\r\n                \"\\t\\t\\t\\tvar parts = cookies[i].split('=');\\n\" +\r\n                \"\\t\\t\\t\\tvar cookie = parts.slice(1).join('=');\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\tif (!this.json && cookie.charAt(0) === '\\\"') {\\n\" +\r\n                \"\\t\\t\\t\\t\\tcookie = cookie.slice(1, -1);\\n\" +\r\n                \"\\t\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\ttry {\\n\" +\r\n                \"\\t\\t\\t\\t\\tvar name = parts[0].replace(rdecode, decodeURIComponent);\\n\" +\r\n                \"\\t\\t\\t\\t\\tcookie = converter.read ?\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tconverter.read(cookie, name) : converter(cookie, name) ||\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tcookie.replace(rdecode, decodeURIComponent);\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (this.json) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\ttry {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\t\\tcookie = JSON.parse(cookie);\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\t} catch (e) {}\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (key === name) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tresult = cookie;\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tbreak;\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\t\\t\\tif (!key) {\\n\" +\r\n                \"\\t\\t\\t\\t\\t\\tresult[name] = cookie;\\n\" +\r\n                \"\\t\\t\\t\\t\\t}\\n\" +\r\n                \"\\t\\t\\t\\t} catch (e) {}\\n\" +\r\n                \"\\t\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\t\\treturn result;\\n\" +\r\n                \"\\t\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\tapi.set = api;\\n\" +\r\n                \"\\t\\tapi.get = function (key) {\\n\" +\r\n                \"\\t\\t\\treturn api.call(api, key);\\n\" +\r\n                \"\\t\\t};\\n\" +\r\n                \"\\t\\tapi.getJSON = function () {\\n\" +\r\n                \"\\t\\t\\treturn api.apply({\\n\" +\r\n                \"\\t\\t\\t\\tjson: true\\n\" +\r\n                \"\\t\\t\\t}, [].slice.call(arguments));\\n\" +\r\n                \"\\t\\t};\\n\" +\r\n                \"\\t\\tapi.defaults = {};\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\tapi.remove = function (key, attributes) {\\n\" +\r\n                \"\\t\\t\\tapi(key, '', extend(attributes, {\\n\" +\r\n                \"\\t\\t\\t\\texpires: -1\\n\" +\r\n                \"\\t\\t\\t}));\\n\" +\r\n                \"\\t\\t};\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\tapi.withConverter = init;\\n\" +\r\n                \"\\n\" +\r\n                \"\\t\\treturn api;\\n\" +\r\n                \"\\t}\\n\" +\r\n                \"\\n\" +\r\n                \"\\treturn init(function () {});\\n\" +\r\n                \"}));\")\r\n    }\r\n}\r\n\r\nexternal class Cookies {\r\n    companion object {\r\n        fun set(key: String, value: String): String\r\n        fun get(key: String): String\r\n        fun remove(key: String)\r\n    }\r\n}","package venus\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\n\r\nimport venus.api.venuspackage\r\nimport venus.terminal.Terminal\r\nimport venus.terminal.cmds.vdb\r\nimport venus.vfs.*\r\nimport venusbackend.assembler.*\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.linker.Linker\r\nimport venusbackend.linker.ProgramAndLibraries\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.plus\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.*\r\nimport venusbackend.simulator.Tracer.Companion.wordAddressed\r\nimport venusbackend.simulator.cache.BlockReplacementPolicy\r\nimport venusbackend.simulator.cache.CacheError\r\nimport venusbackend.simulator.cache.CacheHandler\r\nimport venusbackend.simulator.cache.PlacementPolicy\r\n\r\n// using these imports only for type checks and fake DOM\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.removeClass\r\nimport kotlin.dom.hasClass\r\nimport org.w3c.dom.*\r\n\r\nexternal class Timeout\r\nexternal fun setInterval(\r\n    callback: dynamic,\r\n    delay: Int = definedExternally,\r\n    vararg args: Any?\r\n): Timeout\r\nexternal fun setTimeout(\r\n    callback: dynamic,\r\n    delay: Int = definedExternally,\r\n    vararg args: Any?\r\n): Timeout\r\nexternal fun clearTimeout(handle: Timeout = definedExternally): Unit\r\nexternal val document: Document\r\n\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n/**\r\n * The \"driver\" singleton which can be called from Javascript for all functionality.\r\n */\r\n@JsName(\"Driver\") object Driver {\r\n    @JsName(\"VFS\") var VFS = VirtualFileSystem(\"/\")\r\n    var active_abs_file_name: String? = null\r\n    var active_abs_file_path: String? = null\r\n\r\n    fun set_active_afpath(path: String?) {\r\n        active_abs_file_path = path\r\n        document.getElementById(\"activeFileInEditor\")!!.innerHTML = path.toString()\r\n        activeFileinEditor = path ?: \"\"\r\n    }\r\n\r\n    var sim: Simulator = Simulator(LinkedProgram(), VFS)\r\n    var tr: Tracer = Tracer(sim)\r\n    val mainCache: CacheHandler = CacheHandler(1)\r\n\r\n    var cache: CacheHandler = mainCache\r\n    var cacheLevels: ArrayList<CacheHandler> = arrayListOf(mainCache)\r\n    val simSettings = SimulatorSettings()\r\n    val simState64 = SimulatorState64()\r\n    val temp = QuadWord()\r\n\r\n    private var timer: Timeout? = null\r\n    val LS = LocalStorage()\r\n    var useLS = false\r\n    private var saveInterval: Timeout? = null\r\n    var p = \"\"\r\n    private var ready = false\r\n    @JsName(\"FReginputAsFloat\") var FReginputAsFloat = true\r\n    @JsName(\"ScriptManager\") var ScriptManager = venus.api.ScriptManager\r\n    @JsName(\"debug\") var debug = false\r\n\r\n    @JsName(\"terminal\") var terminal = Terminal(VFS)\r\n\r\n    @JsName(\"activeFileinEditor\") var activeFileinEditor: String = \"\"\r\n\r\n    @JsName(\"driver_complete_loading\") var driver_complete_loading: Boolean = false\r\n\r\n    init {\r\n        /* This code right here is so that you can add custom kotlin code even after venus has been loaded! */\r\n        js(\"window.eval_in_venus_env = function (s) {return eval(s);}\")\r\n        js(\"load_update_message(\\\"Initializing Venus: Init\\\");\")\r\n        simState64.getReg(0)\r\n        Linter.lint(\"\")\r\n        console.log(\"Loading driver...\")\r\n        mainCache.attach(false)\r\n\r\n        useLS = LS.get(\"venus\") == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"sv\") as HTMLButtonElement, useLS)\r\n\r\n        setTimeout(Driver::initTimeout, 5)\r\n\r\n        console.log(\"Finished loading driver!\")\r\n    }\r\n\r\n    fun initTimeout() {\r\n        js(\"load_update_message(\\\"Initializing Venus: Local Storage\\\");\")\r\n        loadAll(useLS)\r\n        js(\"load_update_message(\\\"Initializing Venus: Renderer\\\");\")\r\n        Renderer.loadSimulator(sim)\r\n        Renderer.renderAssembleButtons()\r\n        saveInterval = setInterval(Driver::saveIntervalFn, 10000)\r\n        Driver.ready = true\r\n        initFinish()\r\n    }\r\n\r\n    fun initFinish() {\r\n        if (Driver.ready) {\r\n            if (!::fileExplorerCurrentLocation.isInitialized) {\r\n                fileExplorerCurrentLocation = VFS.sentinel\r\n                openVFObjectfromObj(VFS.sentinel)\r\n            }\r\n            js(\"\"\"window.onbeforeunload = function(){\r\n    driver.saveAll();\r\n}\"\"\")\r\n            js(\"window.driver_load_done();\")\r\n        } else {\r\n            setInterval(Driver::initFinish, 100)\r\n        }\r\n    }\r\n\r\n    @JsName(\"lint\") fun lint(text: String): Array<LintError> = Linter.lint(text)\r\n\r\n    /**\r\n     * Run when the user clicks the \"Simulator\" tab.\r\n     *\r\n     * Assembles the text in the editor, and then renders the simulator.\r\n     */\r\n    @JsName(\"openSimulator\") fun openSimulator() {\r\n        openGenericMainTab(\"simulator\")\r\n    }\r\n\r\n    @JsName(\"noAssemble\") fun noAssemble() {\r\n        Renderer.renderSimButtons()\r\n    }\r\n\r\n    fun getDefaultArgs(): String {\r\n        return (document.getElementById(\"ArgsList\") as HTMLInputElement).value\r\n    }\r\n\r\n    data class InstructionInfo(val pc: Int, val mcode: Int, val basicCode: String, val line: Int)\r\n    data class DebugInfo(val pc: Int, val mcode: Int, val basicCode: String, val line: Int, val sourceFile: String)\r\n    @JsName(\"getCurrentInstruction\") fun getCurrentInstruction(): DebugInfo{\r\n        for (i in 0 until sim.linkedProgram.prog.insts.size) {\r\n            val programDebug = sim.linkedProgram.dbg[i]\r\n            val (_, dbg) = programDebug\r\n            val pc = sim.instOrderMapping[i]!!\r\n            if (pc == sim.getPC().toInt()) {\r\n                val mc = sim.linkedProgram.prog.insts[i]\r\n                val basicCode = Instruction[mc].disasm(mc)\r\n                val mcode = mc[InstructionField.ENTIRE].toInt()\r\n                return DebugInfo(pc, mcode, basicCode, dbg.lineNo, dbg.prog.absPath)\r\n            }\r\n        }\r\n        return DebugInfo(0, 0, \"failure\", 0, \"unknown\")\r\n    }\r\n\r\n    @JsName(\"getInstructions\") fun getIntructions(): Array<InstructionInfo> {\r\n        val instructions: MutableList<InstructionInfo> = mutableListOf()\r\n        for (i in 0 until sim.linkedProgram.prog.insts.size) {\r\n            val programDebug = sim.linkedProgram.dbg[i]\r\n            val (_, dbg) = programDebug\r\n            val (_, line) = dbg\r\n            val lineNo = dbg.lineNo\r\n            val mc = sim.linkedProgram.prog.insts[i]\r\n            val pc = sim.instOrderMapping[i]!!\r\n            val basicCode = Instruction[mc].disasm(mc)\r\n            val mcode = mc[InstructionField.ENTIRE].toInt()\r\n            instructions.add(InstructionInfo(pc, mcode, basicCode, lineNo))\r\n        }\r\n\r\n        return instructions.toTypedArray()\r\n    }\r\n\r\n    @JsName(\"assembleSimulator\") fun assembleSimulator() {\r\n        var text = getText()\r\n        if (text == \"\") {\r\n            js(\"codeMirror.refresh();codeMirror.save();\")\r\n            text = getText()\r\n        }\r\n        if (ready) {\r\n            try {\r\n                val editorFileName = active_abs_file_name ?: \"editor.S\"\r\n                val fpath = active_abs_file_path ?: VFS.currentLocation.getPath() + \"/$editorFileName\"\r\n                var remove = false\r\n                if (VFS.getObjectFromPath(fpath) == null) {\r\n                    VFS.addFile(fpath, text)\r\n                    remove = true\r\n                }\r\n                val success = assemble(text, name = editorFileName, absPath = fpath)\r\n                if (success != null) {\r\n                    if (link(listOf(success))) {\r\n                        val args = Lexer.lex(getDefaultArgs())\r\n                        for (arg in args) {\r\n                            sim.addArg(arg)\r\n                        }\r\n                        Renderer.loadSimulator(sim)\r\n                        setCacheSettings()\r\n                        Renderer.updateCache(Address(0, MemSize.WORD))\r\n                    }\r\n                }\r\n                if (remove) {\r\n                    VFS.remove(fpath)\r\n                }\r\n            } catch (e: Throwable) {\r\n                Renderer.loadSimulator(Simulator(LinkedProgram(), VFS))\r\n                handleError(\"Open Simulator\", e)\r\n            }\r\n        } else {\r\n            setTimeout(Driver::openSimulator, 100)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DEPRECATED\r\n     * no operation\r\n     * should be irrelevant\r\n     * looks for some url-args\r\n     */\r\n    @JsName(\"checkURLParams\") fun checkURLParams() {\r\n        /*\r\n        var clearparams = true\r\n        val currentURL = URL(window.location.href)\r\n\r\n        var s = currentURL.searchParams.get(\"code\")\r\n        if (s != null) {\r\n            s = parseString(s)\r\n            js(\"codeMirror.save();\")\r\n            if (getText() != \"\") {\r\n                if (getText() != s) {\r\n                    val override = currentURL.searchParams.get(\"override\")\r\n                    val overrideb = override != null && override.toLowerCase() == \"true\"\r\n                    val choice = if (overrideb) { true } else { window.confirm(\"You have some saved code already in venus! Do you want to override it with the code in your url?\") }\r\n                    if (choice) {\r\n                        js(\"codeMirror.setValue(s);\")\r\n                    } else {\r\n                        clearparams = false\r\n                    }\r\n                }\r\n            } else {\r\n                js(\"codeMirror.setValue(s);\")\r\n            }\r\n        }\r\n\r\n        s = currentURL.searchParams.get(\"tab\")\r\n        if (s != null) {\r\n            s = parseString(s.toString())\r\n            if (s in Renderer.mainTabs) {\r\n                Renderer.renderTab(s, Renderer.mainTabs)\r\n            } else {\r\n                console.log(\"Unknown Tag!\")\r\n            }\r\n        }\r\n\r\n        s = currentURL.searchParams.get(\"target\")\r\n        if (s != null) {\r\n            s = parseString(s)\r\n            js(\"loadfromtarget(s);\")\r\n        }\r\n\r\n        s = currentURL.searchParams.get(\"save\")\r\n        if (jsTypeOf(s) != undefined) {\r\n            s = parseString(s.toString())\r\n            if (s.toLowerCase() == \"true\") {\r\n                persistentStorage(true)\r\n                Renderer.renderButton(document.getElementById(\"sv\") as HTMLButtonElement, true)\r\n            }\r\n\r\n            if (s.toLowerCase() == \"false\") {\r\n                persistentStorage(false)\r\n                Renderer.renderButton(document.getElementById(\"sv\") as HTMLButtonElement, false)\r\n            }\r\n        }\r\n\r\n        try {\r\n            s = currentURL.searchParams.get(\"packages\")\r\n            if (s != null) {\r\n                s = parseString(s.toString())\r\n                var l = s.split(Regex(\",\"))\r\n                for (pack in l) {\r\n                    ScriptManager.addPackage(pack)\r\n                }\r\n            }\r\n        } catch (e: Exception) {\r\n            console.warn(\"An error occurred when parsing the packages!\")\r\n            console.warn(e)\r\n        }\r\n\r\n        if (clearparams) {\r\n            clearURLParams()\r\n        }\r\n         */\r\n    }\r\n\r\n    /**\r\n     * DEPRECATED\r\n     * No Operation\r\n     * see fun checkURLParams\r\n     */\r\n    fun clearURLParams() {\r\n        /*\r\n        val location = window.location.origin + window.location.pathname\r\n        js(\"window.history.replaceState({}, document.title, location)\")\r\n        */\r\n    }\r\n\r\n    fun parseString(s: String): String {\r\n        val ps = s.replace(\"\\\\n\", \"\\n\")\r\n                .replace(\"\\\\t\", \"\\t\")\r\n        return ps\r\n    }\r\n\r\n    fun unparseString(s: String): String {\r\n        val ps = s.replace(\"\\n\", \"\\\\n\")\r\n                .replace(\"\\t\", \"\\\\t\")\r\n        return ps\r\n    }\r\n\r\n    /**\r\n     * Opens and renders the editor.\r\n     */\r\n    @JsName(\"openEditor\") fun openEditor() {\r\n        runEnd()\r\n        openGenericMainTab(\"editor\")\r\n        js(\"codeMirror.refresh();\")\r\n    }\r\n\r\n    @JsName(\"openVenus\") fun openVenus() {\r\n        openGenericMainTab(\"venus\")\r\n    }\r\n\r\n    @JsName(\"openGenericMainTab\") fun openGenericMainTab(name: String) {\r\n        Renderer.renderTab(name, Renderer.mainTabs)\r\n        if (name == \"editor\") {\r\n            Renderer.renderAssembleButtons()\r\n        }\r\n        LS.set(\"defaultTab\", name)\r\n    }\r\n\r\n    @JsName(\"openURLMaker\") fun openURLMaker() {\r\n        js(\"setUpURL();\")\r\n        Renderer.renderURLMaker()\r\n    }\r\n\r\n    /**\r\n     * Gets the text from the textarea editor.\r\n     */\r\n    @JsName(\"getText\") internal fun getText(): String {\r\n        val editor = kotlin.browser.document.getElementById(\"asm-editor\") as HTMLTextAreaElement\r\n        return editor.value\r\n    }\r\n\r\n    /**\r\n     * Assembles and links the program, sets the simulator\r\n     *\r\n     * @param text the assembly code.\r\n     */\r\n    internal fun assemble(text: String, name: String = \"\", absPath: String): Program? {\r\n        val (prog, errors, warnings) = if (name != \"\") {\r\n            Assembler.assemble(text, name, abspath = absPath)\r\n        } else {\r\n            Assembler.assemble(text, abspath = absPath)\r\n        }\r\n        if (errors.isNotEmpty()) {\r\n            Renderer.displayAssemblerError(errors.first())\r\n            return null\r\n        }\r\n        return prog\r\n    }\r\n\r\n    internal fun link(progs: List<Program>): Boolean {\r\n        try {\r\n            val PandL = ProgramAndLibraries(progs, VFS)\r\n            val linked = Linker.link(PandL)\r\n            loadSim(linked)\r\n            return true\r\n        } catch (e: AssemblerError) {\r\n            Renderer.displayAssemblerError(e)\r\n            return false\r\n        }\r\n    }\r\n\r\n    fun loadSim(linked: LinkedProgram) {\r\n        sim = Simulator(linked, VFS, simSettings)\r\n        mainCache.reset()\r\n        sim.state.cache = mainCache\r\n        tr = Tracer(sim)\r\n    }\r\n\r\n    fun getMaxSteps(): Int {\r\n        return (document.getElementById(\"tmaxsteps-val\") as HTMLInputElement).value.toInt()\r\n    }\r\n\r\n    @JsName(\"updateMaxSteps\") fun updateMaxSteps() {\r\n        runEnd()\r\n        simSettings.maxSteps = getMaxSteps()\r\n    }\r\n\r\n    fun exitcodecheck() {\r\n        if (sim.exitcode != null) {\r\n            val msg = \"Exited with error code ${sim.exitcode}\"\r\n            if (sim.exitcode ?: 0 == 0) {\r\n                Renderer.stdout(msg)\r\n            } else {\r\n                Renderer.displayWarning(msg)\r\n            }\r\n        }\r\n    }\r\n\r\n    @JsName(\"externalAssemble\") fun externalAssemble(text: String, absPath: String = \"\", fileName: String = \"main.s\"): Any {\r\n        var success = true\r\n        var errs = \"\"\r\n        val (prog, errors, warnings) = Assembler.assemble(text, abspath = absPath, name = fileName)\r\n        if (errors.isNotEmpty()) {\r\n            errs = errors.first().toString()\r\n            success = false\r\n        } else {\r\n            try {\r\n                val PandL = ProgramAndLibraries(listOf(prog), VFS)\r\n                val linked = Linker.link(PandL)\r\n                sim = Simulator(linked, VFS, simSettings)\r\n                val args = Lexer.lex(getDefaultArgs())\r\n                for (arg in args) {\r\n                    sim.addArg(arg)\r\n                }\r\n                setCacheSettings()\r\n            } catch (e: AssemblerError) {\r\n                errs = e.toString()\r\n                success = false\r\n            }\r\n        }\r\n\r\n        return js(\"[success, errs, warnings]\")\r\n    }\r\n\r\n    /**\r\n     * Runs the simulator until it is done, or until the run button is pressed again.\r\n     */\r\n    @JsName(\"run\") fun run() {\r\n        if (currentlyRunning()) {\r\n            runEnd()\r\n        } else {\r\n            try {\r\n                Renderer.setRunButtonSpinning(true)\r\n                timer = setTimeout(Driver::runStart, TIMEOUT_TIME, true)\r\n                sim.step() // walk past breakpoint\r\n            } catch (e: Throwable) {\r\n                runEnd()\r\n                handleError(\"RunStart\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the simulator to its initial state\r\n     */\r\n    @JsName(\"reset\") fun reset() {\r\n        try {\r\n            val args = sim.args\r\n            sim = Simulator(sim.linkedProgram, VFS, sim.settings, simulatorID = sim.simulatorID)\r\n            tr.sim = sim\r\n            for (arg in args) {\r\n                sim.addArg(arg)\r\n            }\r\n            mainCache.reset()\r\n            sim.state.setCacheHandler(mainCache)\r\n            Renderer.loadSimulator(sim)\r\n            setCacheSettings()\r\n            Renderer.updateCache(Address(0, MemSize.WORD))\r\n        } catch (e: Throwable) {\r\n            Renderer.loadSimulator(Simulator(LinkedProgram(), VFS))\r\n            handleError(\"Reset Simulator\", e)\r\n        }\r\n    }\r\n\r\n    @JsName(\"toggleBreakpoint\") fun addBreakpoint(idx: Int) {\r\n        val isBreakpoint = sim.toggleBreakpointAt(idx)\r\n        Renderer.renderBreakpointAt(idx, isBreakpoint)\r\n    }\r\n\r\n    internal const val TIMEOUT_CYCLES = 100\r\n    internal const val TIMEOUT_TIME = 10\r\n    internal fun runStart(useBreakPoints: Boolean) {\r\n        try {\r\n            var cycles = 0\r\n            while (cycles < TIMEOUT_CYCLES) {\r\n                if (sim.isDone() || (sim.atBreakpoint() && useBreakPoints)) {\r\n                    exitcodecheck()\r\n                    runEnd()\r\n                    Renderer.updateAll()\r\n                    return\r\n                }\r\n\r\n                handleNotExitOver()\r\n                sim.step()\r\n                Renderer.updateCache(Address(0, MemSize.WORD))\r\n                cycles++\r\n            }\r\n\r\n            timer = setTimeout(Driver::runStart, TIMEOUT_TIME, useBreakPoints)\r\n        } catch (e: Throwable) {\r\n            runEnd()\r\n            handleError(\"RunStart\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n        }\r\n    }\r\n\r\n    @JsName(\"runEnd\") fun runEnd() {\r\n        handleNotExitOver()\r\n        Renderer.updatePC(sim.getPC())\r\n        Renderer.updateAll()\r\n        Renderer.setRunButtonSpinning(false)\r\n        timer?.let(::clearTimeout)\r\n        timer = null\r\n    }\r\n\r\n    /**\r\n     * Runs the simulator for one step and renders any updates.\r\n     */\r\n    @JsName(\"step\") fun step() {\r\n        try {\r\n            val diffs = sim.step()\r\n            handleNotExitOver()\r\n            exitcodecheck()\r\n        } catch (e: Throwable) {\r\n            handleError(\"step\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs the simulator for one step and renders any updates.\r\n     */\r\n    @JsName(\"isFinished\") fun isFinished(): Boolean {\r\n        if (sim.exitcode != null) {\r\n            return true\r\n        } else {\r\n            return false\r\n        }\r\n    }\r\n\r\n    private fun handleNotExitOver() {\r\n        if (sim.settings.ecallOnlyExit &&\r\n                (sim.getPC().toInt() >= sim.getMaxPC().toInt() || sim.getPC().toInt() < MemorySegments.TEXT_BEGIN)\r\n        ) {\r\n//            val pcloc = (sim.getMaxPC().toInt() - MemorySegments.TEXT_BEGIN)\r\n            val pcloc = sim.getPC().toInt()\r\n            sim.incMaxPC(4)\r\n            var mcode = MachineCode(0)\r\n            var progLine = \"\"\r\n            try {\r\n                mcode = sim.getNextInstruction()\r\n                Renderer.addToProgramListing(pcloc, mcode, Instruction[mcode].disasm(mcode))\r\n            } catch (e: SimulatorError) {\r\n                val short0 = sim.loadHalfWord(sim.getPC())\r\n                val short1 = sim.loadHalfWord(sim.getPC() + 2)\r\n                Renderer.addToProgramListing(pcloc, MachineCode((short1 shl 16) or short0), \"Invalid Instruction\", true)\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Undo the last executed instruction and render any updates.\r\n     */\r\n    @JsName(\"undo\") fun undo() {\r\n        try {\r\n            val diffs = sim.undo()\r\n            Renderer.updateFromDiffs(diffs)\r\n            Renderer.updateControlButtons()\r\n        } catch (e: Throwable) {\r\n            handleError(\"undo\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change to memory tab.\r\n     */\r\n    @JsName(\"openMemoryTab\") fun openMemoryTab() {\r\n        Renderer.renderMemoryTab()\r\n    }\r\n\r\n    /**\r\n     * Change to register tab.\r\n     */\r\n    @JsName(\"openRegisterTab\") fun openRegisterTab() {\r\n        Renderer.renderRegisterTab()\r\n    }\r\n\r\n    @JsName(\"openRegsTab\") fun openRegsTab() {\r\n        Renderer.renderRegsTab()\r\n    }\r\n\r\n    @JsName(\"openFRegsTab\") fun openFRegsTab() {\r\n        Renderer.renderFRegsTab()\r\n    }\r\n\r\n    /**\r\n     * Change to trace settings tab\r\n     */\r\n    @JsName(\"openTracerSettingsTab\") fun openTracerSettingsTab() {\r\n        Renderer.renderTracerSettingsTab()\r\n    }\r\n\r\n    @JsName(\"openPackagesTab\") fun openPackagesTab() {\r\n        Renderer.renderPackagesTab()\r\n    }\r\n\r\n    @JsName(\"openCacheTab\") fun openCacheTab() {\r\n        Renderer.renderCacheTab()\r\n    }\r\n\r\n    @JsName(\"openSettingsTab\") fun openSettingsTab() {\r\n        Renderer.renderSettingsTab()\r\n    }\r\n\r\n    @JsName(\"openGeneralSettingsTab\") fun openGeneralSettingsTab() {\r\n        Renderer.renderGeneralSettingsTab()\r\n    }\r\n\r\n    @JsName(\"currentlyRunning\") fun currentlyRunning(): Boolean = timer != null\r\n\r\n    @JsName(\"destructiveGetSimOut\") fun destrictiveGetSimOut(): String {\r\n        val tmp = sim.stdout\r\n        sim.stdout = \"\"\r\n        return tmp\r\n    }\r\n\r\n    @JsName(\"openVenusTab\") fun openVenusTab(tabid: String) {\r\n        val tabs = listOf(\"venus-terminal\", \"venus-files\", \"venus-url\", \"venus-jvm\")\r\n        Renderer.renderTab(tabid, tabs)\r\n        if (tabid == \"venus-files\") {\r\n            refreshVFS()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save a register's value\r\n     */\r\n    @JsName(\"saveRegister\") fun saveRegister(reg: HTMLInputElement, id: Int) {\r\n        if (!currentlyRunning()) {\r\n            try {\r\n                val input = reg.value\r\n                sim.setRegNoUndo(id, userStringToInt(input))\r\n            } catch (e: NumberFormatException) {\r\n                /* do nothing */\r\n            }\r\n        }\r\n        Renderer.updateRegister(id, sim.getReg(id))\r\n    }\r\n\r\n    @JsName(\"saveFRegister\") fun saveFRegister(freg: HTMLInputElement, id: Int) {\r\n        if (!currentlyRunning()) {\r\n            try {\r\n                val input = freg.value\r\n                val d = Decimal(f = userStringToFloat(input), d = userStringToDouble(input), isF = FReginputAsFloat)\r\n                sim.setFRegNoUndo(id, d)\r\n            } catch (e: NumberFormatException) {\r\n                /* do nothing */\r\n            }\r\n        }\r\n        Renderer.updateFRegister(id, sim.getFReg(id))\r\n    }\r\n\r\n    @JsName(\"updateRegMemDisplay\") fun updateRegMemDisplay() {\r\n        Renderer.updateRegMemDisplay()\r\n    }\r\n\r\n    @JsName(\"moveMemoryJump\") fun moveMemoryJump() = Renderer.moveMemoryJump()\r\n\r\n    @JsName(\"moveMemoryUp\") fun moveMemoryUp() = Renderer.moveMemoryUp()\r\n\r\n    @JsName(\"moveMemoryDown\") fun moveMemoryDown() = Renderer.moveMemoryDown()\r\n\r\n    @JsName(\"moveMemoryLocation\") fun moveMemoryLocation(address: String) {\r\n        try {\r\n            val addr = userStringToInt(address)\r\n            Renderer.updateMemory(addr)\r\n        } catch (e: Throwable) {\r\n            handleError(\"MoveMemLoc\", e, true)\r\n        }\r\n    }\r\n\r\n    fun getInstructionDump(): String {\r\n        val sb = StringBuilder()\r\n        for (i in 0 until sim.linkedProgram.prog.insts.size) {\r\n            val mcode = sim.linkedProgram.prog.insts[i]\r\n            val hexRepresentation = Renderer.toHex(mcode[InstructionField.ENTIRE].toInt())\r\n            sb.append(hexRepresentation/*.removePrefix(\"0x\")*/)\r\n            sb.append(\"\\n\")\r\n        }\r\n        return sb.toString()\r\n    }\r\n\r\n    /**\r\n     * DEPRECATED\r\n     * Not implemented\r\n     * This did copy instruction codes into a text area\r\n     */\r\n    @JsName(\"dump\") fun dump() {\r\n        /*\r\n        try {\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(getInstructionDump())\r\n            val ta = document.getElementById(\"console-output\") as HTMLTextAreaElement\r\n            ta.select()\r\n            val success = document.execCommand(\"copy\")\r\n            if (success) {\r\n                // window.alert(\"Successfully copied machine code to clipboard\")\r\n                console.log(\"Successfully copied machine code to clipboard\")\r\n            }\r\n        } catch (e: Throwable) {\r\n            handleError(\"dump\", e)\r\n        }\r\n         */\r\n    }\r\n\r\n    @JsName(\"setOnlyEcallExit\") fun setOnlyEcallExit(b: Boolean) {\r\n        simSettings.ecallOnlyExit = b\r\n    }\r\n\r\n    @JsName(\"setAllowAccessBtnStackHeap\") fun setAllowAccessBtnStackHeap(b: Boolean) {\r\n        simSettings.allowAccessBtnStackHeap = b\r\n    }\r\n\r\n    @JsName(\"setSetRegsOnInit\") fun setSetRegsOnInit(b: Boolean) {\r\n        simSettings.setRegesOnInit = b\r\n    }\r\n\r\n    @JsName(\"verifyText\") fun verifyText(input: HTMLInputElement) {\r\n        try {\r\n            if (!currentlyRunning()) {\r\n                try {\r\n                    var i = userStringToInt(input.value)\r\n                    try {\r\n                        MemorySegments.setTextBegin(i)\r\n                        // val tabDisplay = document.getElementById(\"simulator-tab\") as HTMLElement\r\n                        // if (tabDisplay.classList.contains(\"is-active\")) {\r\n                            openSimulator()\r\n                        // }\r\n                    } catch (e: SimulatorError) {\r\n                        console.warn(e.toString())\r\n                    }\r\n                } catch (e: NumberFormatException) {\r\n                    /* do nothing */\r\n                    console.warn(\"Unknown number format!\")\r\n                }\r\n            } else {\r\n                console.warn(\"Could not change text because the program is currently running!\")\r\n            }\r\n            val ts = Renderer.intToString(MemorySegments.TEXT_BEGIN)\r\n            input.value = ts\r\n        } catch (e: Throwable) {\r\n            handleError(\"Verify Text\", e)\r\n        }\r\n    }\r\n\r\n    @JsName(\"setNumberOfCacheLevels\") fun setNumberOfCacheLevels(i: Int) {\r\n        if (i < 1) {\r\n            (document.getElementById(\"setNumCacheLvls\") as HTMLInputElement).value = cacheLevels.size.toString()\r\n            handleError(\"Set Number of Cache Levels (LT0)\", CacheError(\"You must set the number of caches to at least 1! If you do not want to use any cache, set this to 1 and then disable the cache.\"), true)\r\n            return\r\n        }\r\n        (document.getElementById(\"setNumCacheLvls\") as HTMLInputElement).value = i.toString()\r\n        if (i == cacheLevels.size) {\r\n            return\r\n        }\r\n        if (cacheLevels.size < i) {\r\n            val lastCache = cacheLevels[cacheLevels.size - 1]\r\n            while (cacheLevels.size < i) {\r\n                val newCache = CacheHandler(cacheLevels.size + 1)\r\n                cacheLevels[cacheLevels.size - 1].nextLevelCacheHandler = newCache\r\n                cacheLevels.add(newCache)\r\n                Renderer.renderAddCacheLevel()\r\n            }\r\n            lastCache.update()\r\n        } else if (cacheLevels.size > i) {\r\n            while (cacheLevels.size > i) {\r\n                val prevCacheIndex = cacheLevels.size - 1\r\n                val prevCache = cacheLevels[prevCacheIndex]\r\n                cacheLevels.removeAt(prevCacheIndex)\r\n                val lastCache = cacheLevels[cacheLevels.size - 1]\r\n                lastCache.nextLevelCacheHandler = null\r\n                if (cache.cacheLevel == prevCache.cacheLevel) {\r\n                    cache = lastCache\r\n                    Renderer.renderSetCacheLevel(cache.cacheLevel)\r\n                }\r\n                Renderer.renderRemoveCacheLevel()\r\n            }\r\n            setCacheSettings()\r\n        }\r\n    }\r\n\r\n    @JsName(\"setCacheEnabled\") fun setCacheEnabled(enabled: Boolean) {\r\n        cache.attach(enabled)\r\n        Renderer.updateCache(Address(0, MemSize.WORD))\r\n    }\r\n\r\n    @JsName(\"updateCacheLevel\") fun updateCacheLevel(e: HTMLSelectElement) {\r\n        try {\r\n            val level = e.value.removePrefix(\"L\").toInt()\r\n            updateCacheLvl(level)\r\n        } catch (e: NumberFormatException) {\r\n            handleError(\"Update Cache Level (NFE)\", e, true)\r\n        }\r\n    }\r\n\r\n    fun updateCacheLvl(level: Int) {\r\n        if (level in 1..cacheLevels.size) {\r\n            cache = cacheLevels[level - 1]\r\n            Renderer.renderSetCacheLevel(level)\r\n            setCacheSettings()\r\n        } else {\r\n            handleError(\"Update Cache Level (LVL)\", CacheError(\"Cache level '\" + level + \"' does not exist in your current cache!\"), true)\r\n        }\r\n    }\r\n\r\n    @JsName(\"updateCacheBlockSize\") fun updateCacheBlockSize(e: HTMLInputElement) {\r\n        val v = e.value.toInt()\r\n        try {\r\n            cache.setCacheBlockSize(v)\r\n        } catch (er: CacheError) {\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(er.toString())\r\n        }\r\n        e.value = cache.cacheBlockSize().toString()\r\n        setCacheSettings()\r\n    }\r\n\r\n    @JsName(\"updateCacheNumberOfBlocks\") fun updateCacheNumberOfBlocks(e: HTMLInputElement) {\r\n        val v = e.value.toInt()\r\n        try {\r\n            cache.setNumberOfBlocks(v)\r\n        } catch (er: CacheError) {\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(er.toString())\r\n        }\r\n        e.value = cache.numberOfBlocks().toString()\r\n        setCacheSettings()\r\n    }\r\n\r\n    @JsName(\"updateCacheAssociativity\") fun updateCacheAssociativity(e: HTMLInputElement) {\r\n        val v = e.value.toInt()\r\n        try {\r\n            cache.setAssociativity(v)\r\n        } catch (er: CacheError) {\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(er.toString())\r\n        }\r\n        e.value = cache.associativity().toString()\r\n        setCacheSettings()\r\n    }\r\n\r\n    @JsName(\"updateCachePlacementPolicy\") fun updateCachePlacementPolicy(e: HTMLSelectElement) {\r\n        if (e.value == \"N-Way Set Associative\") {\r\n            cache.setPlacementPol(PlacementPolicy.NWAY_SET_ASSOCIATIVE)\r\n        } else if (e.value == \"Fully Associative\") {\r\n            cache.setPlacementPol(PlacementPolicy.FULLY_ASSOCIATIVE)\r\n        } else {\r\n            cache.setPlacementPol(PlacementPolicy.DIRECT_MAPPING)\r\n            e.value = \"Direct Mapped\"\r\n        }\r\n        setCacheSettings()\r\n    }\r\n\r\n    @JsName(\"updateCacheReplacementPolicy\") fun updateCacheReplacementPolicy(e: HTMLSelectElement) {\r\n        if (e.value == \"Random\") {\r\n            cache.setBlockRepPolicy(BlockReplacementPolicy.RANDOM)\r\n        } else {\r\n            cache.setBlockRepPolicy(BlockReplacementPolicy.LRU)\r\n            e.value = \"LRU\"\r\n        }\r\n        setCacheSettings()\r\n    }\r\n\r\n    @JsName(\"setCacheSeed\") fun setCacheSeed(v: String) {\r\n        cache.setCurrentSeed(v)\r\n        setCacheSettings()\r\n    }\r\n\r\n    fun setCacheSettings() {\r\n        val bs = cache.cacheBlockSize().toString()\r\n        val nb = cache.numberOfBlocks().toString()\r\n        val av = cache.associativity().toString()\r\n        val avenabled = cache.canSetAssociativity()\r\n        val at = cache.placementPol().toMyString()\r\n        val rp = cache.blockRepPolicy().toMyString()\r\n        val cs = cache.cacheSize().toString()\r\n        val cseed = cache.seed\r\n        val attached = cache.attached\r\n        (document.getElementById(\"block-size-val\") as HTMLInputElement).value = bs\r\n        (document.getElementById(\"numblocks-val\") as HTMLInputElement).value = nb\r\n        val ave = (document.getElementById(\"associativity-val\") as HTMLInputElement)\r\n        ave.value = av\r\n        ave.disabled = !avenabled\r\n        (document.getElementById(\"associativity-type\") as HTMLSelectElement).value = at\r\n        (document.getElementById(\"replacementPolicy\") as HTMLSelectElement).value = rp\r\n        (document.getElementById(\"cache-size-val\") as HTMLInputElement).value = cs\r\n        (document.getElementById(\"cache-seed\") as HTMLInputElement).value = cseed\r\n        val attachedButton = (document.getElementById(\"cacheEnabled\") as HTMLButtonElement)\r\n        attachedButton.value = attached.toString()\r\n        if (attached) {\r\n            attachedButton.addClass(\"is-primary\")\r\n        } else {\r\n            attachedButton.removeClass(\"is-primary\")\r\n        }\r\n        Renderer.makeCacheBlocks()\r\n        Renderer.updateCache(Address(0, MemSize.WORD))\r\n    }\r\n\r\n    @JsName(\"setAlignedAddressing\") fun setAlignedAddressing(b: Boolean) {\r\n        simSettings.alignedAddress = b\r\n    }\r\n\r\n    @JsName(\"setMutableText\") fun setMutableText(b: Boolean) {\r\n        simSettings.mutableText = b\r\n    }\r\n\r\n    @JsName(\"addPackage\") fun addPackage(button: HTMLButtonElement) {\r\n        if (!button.hasClass(\"is-loading\")) {\r\n            button.addClass(\"is-loading\")\r\n            js(\"window.venuspackage = {id:'LOADING!'}\")\r\n            val purlinput = document.getElementById(\"package-url-val\") as HTMLInputElement\r\n            val url = purlinput.value\r\n            ScriptManager.addPackage(url)\r\n            setTimeout(Driver::packageLoaded, 100, button)\r\n        } else {\r\n            console.log(\"Cannot add a new package until the previous package has finished!\")\r\n        }\r\n    }\r\n\r\n    @JsName(\"togglePackage\") fun togglePackage(packageID: String) {\r\n        setTimeout(ScriptManager::togglePackage, TIMEOUT_TIME, packageID)\r\n    }\r\n\r\n    @JsName(\"removePackage\") fun removePackage(packageID: String) {\r\n        setTimeout(ScriptManager::removePackage, TIMEOUT_TIME, packageID)\r\n    }\r\n\r\n    fun packageLoaded(b: HTMLButtonElement) {\r\n        if (venuspackage == undefined) {\r\n            b.removeClass(\"is-loading\")\r\n            return\r\n        }\r\n        setTimeout(Driver::packageLoaded, 100, b)\r\n    }\r\n\r\n    @JsName(\"trace\") fun trace() {\r\n        if (trTimer != null) {\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n            trTimer?.let(::clearTimeout)\r\n            trTimer = null\r\n            tr.traceFullReset()\r\n            sim.reset()\r\n            Renderer.updateControlButtons()\r\n            return\r\n        }\r\n        Renderer.setNameButtonSpinning(\"simulator-trace\", true)\r\n        Renderer.clearConsole()\r\n        loadTraceSettings()\r\n        trTimer = setTimeout(Driver::traceSt, TIMEOUT_TIME)\r\n    }\r\n\r\n    private fun loadTraceSettings() {\r\n        tr.format = (document.getElementById(\"tregPattern\") as HTMLTextAreaElement).value\r\n        tr.base = (document.getElementById(\"tbase-val\") as HTMLInputElement).value.toInt()\r\n        tr.totCommands = (document.getElementById(\"ttot-cmds-val\") as HTMLInputElement).value.toInt()\r\n        tr.maxSteps = (document.getElementById(\"tmaxsteps-val\") as HTMLInputElement).value.toInt()\r\n        tr.instFirst = (document.getElementById(\"tinst-first\") as HTMLButtonElement).value == \"true\"\r\n        tr.twoStage = (document.getElementById(\"tTwoStage\") as HTMLButtonElement).value == \"true\"\r\n        wordAddressed = (document.getElementById(\"tPCWAddr\") as HTMLButtonElement).value == \"true\"\r\n    }\r\n\r\n    var trTimer: Timeout? = null\r\n    internal fun traceSt() {\r\n        try {\r\n            tr.traceStart()\r\n            traceLoop()\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace tr Start\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n            trTimer?.let(::clearTimeout)\r\n            trTimer = null\r\n        }\r\n    }\r\n\r\n    internal fun traceLoop() {\r\n        try {\r\n            var cycles = 0\r\n            while (cycles < TIMEOUT_CYCLES) {\r\n                if (sim.isDone()) {\r\n                    trTimer = setTimeout(Driver::runTrEnd, TIMEOUT_TIME)\r\n                    return\r\n                }\r\n                try {\r\n                    tr.traceStep()\r\n                } catch (err: SimulatorError) {\r\n                    trTimer = setTimeout(Driver::runTrEnd, TIMEOUT_TIME, err)\r\n                    return\r\n                }\r\n                cycles++\r\n            }\r\n            trTimer = setTimeout(Driver::traceLoop, TIMEOUT_TIME)\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace tr Loop\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n            trTimer?.let(::clearTimeout)\r\n            trTimer = null\r\n        }\r\n    }\r\n    internal fun runTrEnd(err: SimulatorError? = null) {\r\n        try {\r\n            tr.traceEnd()\r\n            if (err != null) {\r\n                tr.traceAddError(err)\r\n            }\r\n            tr.traceStringStart()\r\n            trTimer = setTimeout(Driver::traceStringLoop, TIMEOUT_TIME)\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace Tr End\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n            trTimer?.let(::clearTimeout)\r\n            trTimer = null\r\n        }\r\n    }\r\n\r\n    internal fun traceStringLoop() {\r\n        try {\r\n        var cycles = 0\r\n        while (cycles < TIMEOUT_CYCLES) {\r\n            if (!tr.traceStringStep()) {\r\n                trTimer = setTimeout(Driver::traceStringEnd, TIMEOUT_TIME)\r\n                return\r\n            }\r\n        }\r\n            trTimer = setTimeout(Driver::traceStringLoop, TIMEOUT_TIME)\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace String Loop\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n            trTimer?.let(::clearTimeout)\r\n            trTimer = null\r\n        }\r\n    }\r\n\r\n    internal fun traceStringEnd() {\r\n        try {\r\n            tr.traceStringEnd()\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(tr.getString())\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace String End\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n        }\r\n        Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n        trTimer?.let(::clearTimeout)\r\n        trTimer = null\r\n    }\r\n\r\n    /*@JsName(\"trace\") fun trace() {\r\n        //@todo make it so trace is better\r\n        Renderer.setNameButtonSpinning(\"simulator-trace\", true)\r\n        Renderer.clearConsole()\r\n        this.loadTraceSettings()\r\n        setTimeout(Driver::traceStart, TIMEOUT_TIME)\r\n    }*/\r\n    internal fun traceStart() {\r\n        try {\r\n            tr.trace()\r\n            setTimeout(Driver::traceString, TIMEOUT_TIME)\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace Start\", e, e is AlignmentError || e is StoreError || e is ExceededAllowedCyclesError)\r\n            Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n        }\r\n    }\r\n    internal fun traceString() {\r\n        try {\r\n            tr.traceString()\r\n            Renderer.clearConsole()\r\n            Renderer.printConsole(tr.getString())\r\n        } catch (e: Throwable) {\r\n            handleError(\"Trace to String\", e)\r\n        }\r\n        Renderer.setNameButtonSpinning(\"simulator-trace\", false)\r\n    }\r\n\r\n    @JsName(\"persistentStorage\") fun persistentStorage(b: Boolean) {\r\n        useLS = b\r\n        if (useLS) {\r\n            console.log(\"Persistent storage has been enabled!\")\r\n            LS.set(\"venus\", \"true\")\r\n            saveAll()\r\n        } else {\r\n            console.log(\"Persistent storage has been disabled!\")\r\n            LS.set(\"venus\", \"false\")\r\n            // this.LS.reset()\r\n        }\r\n    }\r\n\r\n    @JsName(\"psReset\") fun psReset() {\r\n        LS.reset()\r\n        console.log(\"Persistent storage has been reset!\")\r\n    }\r\n\r\n    fun saveIntervalFn() {\r\n        if (useLS) {\r\n            blinkSave(true)\r\n            setTimeout(Driver::blinkSave, 500, false)\r\n            saveAll()\r\n        }\r\n    }\r\n\r\n    fun blinkSave(b: Boolean) {\r\n        val e = document.getElementById(\"sv\") as HTMLButtonElement\r\n        if (b) {\r\n            e.style.color = \"yellow\"\r\n        } else {\r\n            e.style.color = \"\"\r\n        }\r\n    }\r\n\r\n    fun saveAll(override: Boolean = false) {\r\n        if (!(useLS or override)) {\r\n            return\r\n        }\r\n        /*Trace settings*/\r\n        loadTraceSettings()\r\n        LS.set(\"trace_format\", tr.format)\r\n        LS.set(\"trace_base\", tr.base.toString())\r\n        LS.set(\"trace_totCommands\", tr.totCommands.toString())\r\n        LS.set(\"trace_maxSteps\", tr.maxSteps.toString())\r\n        LS.set(\"trace_instFirst\", tr.instFirst.toString())\r\n        LS.set(\"trace_wordAddressed\", wordAddressed.toString())\r\n        LS.set(\"trace_TwoStage\", tr.twoStage.toString())\r\n\r\n        /*Text Begin*/\r\n        LS.set(\"text_begin\", MemorySegments.TEXT_BEGIN.toString())\r\n        /*Other Settings*/\r\n        LS.set(\"aligned_memory\", simSettings.alignedAddress.toString())\r\n        LS.set(\"mutable_text\", simSettings.mutableText.toString())\r\n        LS.set(\"ecall_exit_only\", simSettings.ecallOnlyExit.toString())\r\n        LS.set(\"set_regs_on_init\", simSettings.setRegesOnInit.toString())\r\n        LS.set(\"simargs\", getDefaultArgs())\r\n\r\n        /*Program*/\r\n        js(\"codeMirror.save()\")\r\n        LS.set(\"prog\", getText())\r\n\r\n        /*Cache*/\r\n        val numExtraCache = LS.safeget(\"cache_levels\", \"1\").toInt()\r\n        if (cacheLevels.size < numExtraCache) {\r\n            for (i in (cacheLevels.size + 1)..numExtraCache) {\r\n                LS.remove(\"cache_L\" + i + \"_associativity\")\r\n                LS.remove(\"cache_L\" + i + \"_cacheBlockSize\")\r\n                LS.remove(\"cache_L\" + i + \"_numberOfBlocks\")\r\n                LS.remove(\"cache_L\" + i + \"_placementPol\")\r\n                LS.remove(\"cache_L\" + i + \"_blockRepPolicy\")\r\n                LS.remove(\"cache_L\" + i + \"_seed\")\r\n                LS.remove(\"cache_L\" + i + \"_attach\")\r\n            }\r\n        }\r\n        LS.set(\"cache_levels\", cacheLevels.size.toString())\r\n        LS.set(\"cache_current_level\", cache.cacheLevel.toString())\r\n        for (i in cacheLevels.indices) {\r\n            val curCache = cacheLevels[i]\r\n            LS.set(\"cache_L\" + (i + 1) + \"_associativity\", curCache.associativity().toString())\r\n            LS.set(\"cache_L\" + (i + 1) + \"_cacheBlockSize\", curCache.cacheBlockSize().toString())\r\n            LS.set(\"cache_L\" + (i + 1) + \"_numberOfBlocks\", curCache.numberOfBlocks().toString())\r\n            LS.set(\"cache_L\" + (i + 1) + \"_placementPol\", curCache.placementPol().toString())\r\n            LS.set(\"cache_L\" + (i + 1) + \"_blockRepPolicy\", curCache.blockRepPolicy().toString())\r\n            LS.set(\"cache_L\" + (i + 1) + \"_seed\", curCache.seed)\r\n            LS.set(\"cache_L\" + (i + 1) + \"_attach\", curCache.attached.toString())\r\n        }\r\n\r\n        LS.set(\"activeFileinEditor\", activeFileinEditor)\r\n        var s = if (active_abs_file_name == null) {\r\n            \"n\"\r\n        } else {\r\n            \"p$active_abs_file_name\"\r\n        }\r\n        LS.set(\"active_abs_file_name\", s)\r\n        s = if (active_abs_file_path == null) {\r\n            \"n\"\r\n        } else {\r\n            \"p$active_abs_file_path\"\r\n        }\r\n        LS.set(\"active_abs_file_path\", s)\r\n\r\n        if (::fileExplorerCurrentLocation.isInitialized) {\r\n            LS.set(\"fileExplorerCurrentLocation\", fileExplorerCurrentLocation.getPath())\r\n        }\r\n        LS.set(\"terminalCurrentLocation\", terminal.vfs.currentLocation.getPath())\r\n    }\r\n\r\n    /*If b is true, will load stored values else load default values.*/\r\n    fun loadAll(b: Boolean) {\r\n        val t = Tracer(sim)\r\n        /*Trace Settings*/\r\n        var fmt = t.format\r\n        var bs = t.base.toString()\r\n        var totC = t.totCommands.toString()\r\n        var ms = simSettings.maxSteps.toString()\r\n        var instf = t.instFirst.toString()\r\n        var tws = t.twoStage.toString()\r\n        var wa = wordAddressed.toString()\r\n\r\n        /*Text begin*/\r\n        var txtStart = Renderer.intToString(MemorySegments.TEXT_BEGIN)\r\n        /*Other Settings*/\r\n        var am = simSettings.alignedAddress.toString()\r\n        var mt = simSettings.mutableText.toString()\r\n        var eeo = simSettings.ecallOnlyExit.toString()\r\n        var sroi = simSettings.setRegesOnInit.toString()\r\n        var simargs = \"\"\r\n        var defaultTab = \"venus\"\r\n\r\n        /*Program*/\r\n        js(\"codeMirror.save()\")\r\n        p = getText()\r\n        if (useLS) {\r\n            console.log(\"Using local storage!\")\r\n            /*Trace Settings*/\r\n            fmt = LS.safeget(\"trace_format\", fmt)\r\n            bs = LS.safeget(\"trace_base\", bs)\r\n            totC = LS.safeget(\"trace_totCommands\", totC)\r\n            ms = LS.safeget(\"trace_maxSteps\", ms)\r\n            instf = LS.safeget(\"trace_instFirst\", instf)\r\n            tws = LS.safeget(\"trace_TwoStage\", tws)\r\n            wa = LS.safeget(\"trace_wordAddressed\", wa)\r\n\r\n            /*Text Begin*/\r\n            txtStart = LS.safeget(\"text_begin\", txtStart)\r\n\r\n            /*Other Settings*/\r\n            am = LS.safeget(\"aligned_memory\", am)\r\n            mt = LS.safeget(\"mutable_text\", mt)\r\n            eeo = LS.safeget(\"ecall_exit_only\", eeo)\r\n            sroi = LS.safeget(\"set_regs_on_init\", sroi)\r\n            simargs = LS.safeget(\"simargs\", simargs)\r\n            defaultTab = LS.safeget(\"defaultTab\", defaultTab)\r\n\r\n            /*Program*/\r\n            p = LS.safeget(\"prog\", p)\r\n\r\n            /*Cache*/\r\n            try {\r\n                setNumberOfCacheLevels(LS.safeget(\"cache_levels\", cacheLevels.size.toString()).toInt())\r\n                updateCacheLvl(LS.safeget(\"cache_current_level\", cache.cacheLevel.toString()).toInt())\r\n                for (i in cacheLevels.indices) {\r\n                    val currentCache = cacheLevels[i]\r\n                    currentCache.setCacheBlockSize(LS.safeget(\"cache_L\" + (i + 1) + \"_cacheBlockSize\", currentCache.cacheBlockSize().toString()).toInt())\r\n                    currentCache.setNumberOfBlocks(LS.safeget(\"cache_L\" + (i + 1) + \"_numberOfBlocks\", currentCache.numberOfBlocks().toString()).toInt())\r\n                    currentCache.setBlockRepPolicy(BlockReplacementPolicy.valueOf(LS.safeget(\"cache_L\" + (i + 1) + \"_blockRepPolicy\", currentCache.blockRepPolicy().toString())))\r\n                    currentCache.setPlacementPol(PlacementPolicy.valueOf(LS.safeget(\"cache_L\" + (i + 1) + \"_placementPol\", currentCache.placementPol().toString())))\r\n                    currentCache.setAssociativity(LS.safeget(\"cache_L\" + (i + 1) + \"_associativity\", currentCache.associativity().toString()).toInt())\r\n                    currentCache.attach(LS.safeget(\"cache_L\" + (i + 1) + \"_attach\", currentCache.attached.toString()) == \"true\")\r\n                    currentCache.setCurrentSeed(LS.safeget(\"cache_L\" + (i + 1) + \"_seed\", currentCache.seed))\r\n                }\r\n            } catch (e: Throwable) {\r\n                console.warn(\"An error occurred when loading the cache data!\")\r\n                console.warn(e)\r\n            }\r\n            try {\r\n                VFS.load()\r\n            } catch (e: Throwable) {\r\n                console.warn(\"An error occurred when loading the VFS data!\")\r\n                console.warn(e)\r\n            }\r\n\r\n            var tmp = LS.safeget(\"active_abs_file_name\", \"\")\r\n            active_abs_file_name = if (tmp == \"\" || tmp == \"n\") {\r\n                null\r\n            } else {\r\n                tmp.substring(1 until (tmp.length))\r\n            }\r\n\r\n            tmp = LS.safeget(\"active_abs_file_path\", \"\")\r\n            val ntmp = if (tmp == \"\" || tmp == \"n\") {\r\n                null\r\n            } else {\r\n                tmp.substring(1 until (tmp.length))\r\n            }\r\n            set_active_afpath(ntmp)\r\n\r\n            activeFileinEditor = LS.safeget(\"activeFileinEditor\", \"\")\r\n\r\n            tmp = LS.safeget(\"fileExplorerCurrentLocation\", \"\")\r\n            fileExplorerCurrentLocation = VFS.sentinel\r\n            openVFObject(tmp)\r\n\r\n            terminal.vfs.cd(LS.safeget(\"terminalCurrentLocation\", \"\"))\r\n            js(\"try {term.reset();} catch (e) {console.error(e);}\")\r\n        } else {\r\n            console.log(\"Local Storage has been disabled!\")\r\n        }\r\n        /*Trace Settings*/\r\n        (document.getElementById(\"tregPattern\") as HTMLTextAreaElement).value = fmt\r\n        tr.format = fmt\r\n        (document.getElementById(\"tbase-val\") as HTMLInputElement).value = bs\r\n        tr.base = bs.toInt()\r\n        (document.getElementById(\"ttot-cmds-val\") as HTMLInputElement).value = totC\r\n        tr.totCommands = totC.toInt()\r\n        (document.getElementById(\"tmaxsteps-val\") as HTMLInputElement).value = ms\r\n        tr.maxSteps = ms.toInt()\r\n        simSettings.maxSteps = ms.toInt()\r\n        Renderer.renderButton(document.getElementById(\"tinst-first\") as HTMLButtonElement, instf == \"true\")\r\n        tr.instFirst = instf == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"tPCWAddr\") as HTMLButtonElement, wa == \"true\")\r\n        wordAddressed = wa == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"tTwoStage\") as HTMLButtonElement, tws == \"true\")\r\n        tr.twoStage = tws == \"true\"\r\n\r\n        /*Text Begin*/\r\n        val ts = document.getElementById(\"text-start\") as HTMLInputElement\r\n        ts.value = txtStart\r\n        verifyText(ts)\r\n\r\n        /*Other Settings*/\r\n        Renderer.renderButton(document.getElementById(\"alignAddr\") as HTMLButtonElement, am == \"true\")\r\n        simSettings.alignedAddress = am == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"mutableText\") as HTMLButtonElement, mt == \"true\")\r\n        simSettings.mutableText = mt == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"ecallExit\") as HTMLButtonElement, eeo == \"true\")\r\n        simSettings.ecallOnlyExit = eeo == \"true\"\r\n        Renderer.renderButton(document.getElementById(\"setRegsOnInit\") as HTMLButtonElement, sroi == \"true\")\r\n        simSettings.setRegesOnInit = sroi == \"true\"\r\n        (document.getElementById(\"ArgsList\") as HTMLInputElement).value = simargs\r\n\r\n        /*Program*/\r\n        js(\"codeMirror.setValue(driver.p);\")\r\n        p = \"\"\r\n\r\n        mainCache.update()\r\n        setCacheSettings()\r\n\r\n        ScriptManager.loadDefaults()\r\n        ScriptManager.loadPackages()\r\n\r\n        checkURLParams()\r\n\r\n        fun checkToSetTab() {\r\n            js(\"load_update_message(\\\"Initializing Venus: Waiting on packages to load...\\\");\")\r\n            if (!this.ScriptManager.packagesLoading()) {\r\n                this.openGenericMainTab(defaultTab)\r\n                this.driver_complete_loading = true\r\n                return\r\n            }\r\n            setTimeout(fun () { checkToSetTab() }, 10)\r\n        }\r\n        setTimeout(fun () { checkToSetTab() }, 10)\r\n        js(\"codeMirror.refresh();\")\r\n    }\r\n\r\n    lateinit var fileExplorerCurrentLocation: VFSObject\r\n\r\n    @JsName(\"deleteVFObject\") fun deleteVFObject(name: String) {\r\n        VFS.rm(name, fileExplorerCurrentLocation)\r\n        refreshVFS()\r\n    }\r\n\r\n    @JsName(\"openVFObject\") fun openVFObject(name: String) {\r\n        val s = VFS.chdir(name, fileExplorerCurrentLocation)\r\n        if (s is VFSObject && s.type in listOf(VFSType.Drive, VFSType.Folder)) {\r\n            fileExplorerCurrentLocation = s\r\n            openVFObjectfromObj(fileExplorerCurrentLocation)\r\n        } else {\r\n            console.log(s)\r\n        }\r\n    }\r\n\r\n    fun openVFObjectfromObj(obj: VFSObject) {\r\n        Renderer.clearObjectsFromDisplay()\r\n        Renderer.addFilePWD(obj)\r\n        for ((key, value) in fileExplorerCurrentLocation.contents) {\r\n            if (key in listOf(\".\", \"..\")) {\r\n                Renderer.addObjectToDisplay(value as VFSObject, key)\r\n            } else {\r\n                Renderer.addObjectToDisplay(value as VFSObject)\r\n            }\r\n        }\r\n    }\r\n\r\n    @JsName(\"refreshVFS\") fun refreshVFS() {\r\n        openVFObject(\".\")\r\n    }\r\n\r\n    fun editVFObjectfromObj(obj: VFSObject) {\r\n        if (obj.type !== VFSType.File) {\r\n            console.warn(\"Only files can be loaded into the editor.\")\r\n            return\r\n        }\r\n        try {\r\n            val txt: String = (obj as VFSFile).readText()\r\n            active_abs_file_name = obj.label\r\n            set_active_afpath(obj.getPath())\r\n            js(\"codeMirror.setValue(txt);\")\r\n            this.openEditor()\r\n            js(\"codeMirror.refresh();\")\r\n            activeFileinEditor = obj.getPath()\r\n        } catch (e: Throwable) {\r\n            console.error(e)\r\n            console.warn(\"Could not load file to the editor!\")\r\n        }\r\n    }\r\n\r\n    @JsName(\"editVFObject\") fun editVFObject(name: String) {\r\n        val s = VFS.getObjectFromPath(name, location = fileExplorerCurrentLocation)\r\n        if (s is VFSObject) {\r\n            editVFObjectfromObj(s)\r\n        } else {\r\n            console.log(s)\r\n        }\r\n    }\r\n\r\n    fun saveVFObjectfromObj(obj: VFSObject, save: Boolean = true) {\r\n        val txt: String\r\n        try {\r\n            js(\"codeMirror.save();\")\r\n            txt = getText()\r\n        } catch (e: Throwable) {\r\n            console.error(e)\r\n            console.warn(\"Could not save file!\")\r\n            return\r\n        }\r\n        if (save) {\r\n            if (obj.type != VFSType.File) {\r\n                console.warn(\"You can (currently) only save to files!\")\r\n                return\r\n            }\r\n            var file = obj as VFSFile\r\n            file.setText(txt)\r\n            this.VFS.save()\r\n        }\r\n        active_abs_file_name = obj.label\r\n        set_active_afpath(obj.getPath())\r\n        activeFileinEditor = obj.getPath()\r\n    }\r\n\r\n    @JsName(\"saveVFObject\") fun saveVFObject(name: String) {\r\n        val s = VFS.getObjectFromPath(name, location = fileExplorerCurrentLocation)\r\n        if (s is VFSObject) {\r\n            saveVFObjectfromObj(s)\r\n        } else {\r\n            console.log(s)\r\n        }\r\n    }\r\n\r\n    @JsName(\"clearActiveFileInEditor\") fun clearActiveFileInEditor() {\r\n        active_abs_file_name = null\r\n        set_active_afpath(null)\r\n    }\r\n\r\n    @JsName(\"vdbVFObject\") fun vdbVFObject(name: String) {\r\n        val s = VFS.getObjectFromPath(name, location = fileExplorerCurrentLocation)\r\n        if (s is VFSObject) {\r\n            val cur_loc = VFS.currentLocation\r\n            VFS.currentLocation = fileExplorerCurrentLocation\r\n            val res = vdb.execute(arrayListOf(\"${s.getPath()}\"), terminal, false)\r\n            VFS.currentLocation = cur_loc\r\n            if (res != \"\") {\r\n                js(\"alert('[ERROR]\\\\n' + res)\")\r\n            }\r\n        } else {\r\n            console.log(s)\r\n        }\r\n    }\r\n}","package venus\r\n\r\nimport venusbackend.simulator.SimulatorError\r\nimport kotlin.browser.window\r\n\r\n/**\r\n * Created by thaum on 7/27/2018.\r\n */\r\n\r\ninternal fun handleError(where: String, error: Throwable, h: Boolean = false) {\r\n    var handled = h || if (error is SimulatorError) {\r\n        error.handled ?: false\r\n    } else {\r\n        false\r\n    }\r\n    if (!(error is SimulatorError && (error.infe != null))) {\r\n        Renderer.clearConsole()\r\n    } else {\r\n        handled = true\r\n    }\r\n    try {\r\n        /*Here, I will attempt to get the local storage to display in the error so if someone send sme the error, I can more easily track it.*/\r\n        val olduseLS = Driver.useLS\r\n        Driver.useLS = false\r\n        val oldlsm = Driver.LS.lsm\r\n\r\n        Driver.LS.lsm = LocalStorageManager(\"venus_error\")\r\n        Driver.LS.remove(\"venus_error\")\r\n        Driver.LS.set(\"venus\", \"true\")\r\n        Driver.saveAll(true)\r\n        val t = window.localStorage.getItem(\"venus_error\")\r\n        window.localStorage.removeItem(\"venus_error\")\r\n\r\n        Driver.LS.lsm = oldlsm\r\n        Driver.useLS = olduseLS\r\n        if (handled) {\r\n            Renderer.displayError(\"[ERROR] An error has occurred!\\n\\n\")\r\n        } else {\r\n            Renderer.displayError(\"[ERROR] An uncaught error has occurred! Here are the details that may help solve this issue.\\n\\n\")\r\n        }\r\n        Renderer.displayError(\"Error:\\n`\" + error.toString())\r\n        Renderer.displayError(\"\\n\\nID:\\n'\" + where + \"'!\\n\\n\")\r\n        if (!handled) {\r\n            Renderer.displayError(\"`\\n\\nData:\\n\" + t)\r\n        }\r\n    } catch (t: Throwable) {\r\n        Renderer.displayError(\"An error occurred when trying to handle the error! Please tell me what you did since I do not fully know how you caused this error and could not generate a trace for me to figure that out. All I know is that the error was here: '\" + where + \"' and was:\\n\" + error.toString())\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n *\n * Two characters are considered the same ignoring case if at least one of the following is `true`:\n *   - The two characters are the same (as compared by the == operator)\n *   - Applying the method [toUpperCase] to each character produces the same result\n *   - Applying the method [toLowerCase] to each character produces the same result\n *\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    if (this.toUpperCase() == other.toUpperCase()) return true\n    if (this.toLowerCase() == other.toLowerCase()) return true\n    return false\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n","package venus\r\n\r\nclass LocalStorage {\r\n    // @todo convert this to js and use it externally instead.\r\n    internal var lsm: LocalStorageManager = LocalStorageManager(\"venus\")\r\n\r\n    init {\r\n    }\r\n\r\n    @JsName(\"get\") fun get(key: String): String {\r\n        return lsm.get(key)\r\n    }\r\n\r\n    @JsName(\"set\") fun set(key: String, value: String) {\r\n        lsm.set(key, value)\r\n    }\r\n\r\n    @JsName(\"remove\") fun remove(key: String) {\r\n        lsm.remove(key)\r\n    }\r\n\r\n    @JsName(\"reset\") fun reset() {\r\n        lsm.reset()\r\n    }\r\n\r\n    @JsName(\"safeget\") fun safeget(key: String, prevVal: String): String {\r\n        val v = this.get(key)\r\n        if (v == \"undefined\") {\r\n            return prevVal\r\n        }\r\n        return v\r\n    }\r\n}\r\n\r\nexternal class LocalStorageManager(name: String) {\r\n    fun set(key: String, value: String)\r\n    fun get(key: String): String\r\n    fun remove(key: String)\r\n    fun reset()\r\n}","package venus\r\n/* ktlint-disable no-wildcard-imports */\r\n\r\nimport org.w3c.dom.*\r\nimport venus.vfs.*\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.riscv.*\r\n//import venusbackend.riscv.insts.dsl.types.Instruction\r\n//import venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.Simulator\r\n//import venusbackend.simulator.SimulatorError\r\n//import venusbackend.simulator.cache.BlockState\r\nimport venusbackend.simulator.cache.ChangedBlockState\r\n//import venusbackend.simulator.diffs.*\r\n//import kotlin.browser.document\r\n//import kotlin.browser.window\r\n//import kotlin.dom.addClass\r\n\r\nexternal fun require(module: String): dynamic\r\n/**\r\n * This singleton is used to render different parts of the screen, it serves as an interface between the UI and the\r\n * internal simulator.\r\n *\r\n * @todo break this up into multiple objects\r\n */\r\ninternal object Renderer : IRenderer  {\r\n\r\n    @JsName(\"emitter\") private var eventEmitter: dynamic = null\r\n\r\n    override val MEMORY_CONTEXT = 6\r\n    override var pkgmsgTimeout: Int? = 0\r\n    override val hexMap: List<Char> = listOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n    'A', 'B', 'C', 'D', 'E', 'F')\r\n    override var activeRegister: HTMLElement? = null\r\n    override var activeInstruction: HTMLElement? = null\r\n    override var activeMemoryAddress: Int = 0\r\n    override var sim: Simulator = Simulator(LinkedProgram(), VirtualFileSystem(\"dummy\"))\r\n    override var displayType = \"hex\"\r\n    override var mainTabs: ArrayList<String> = arrayListOf(\"simulator\", \"editor\", \"venus\")\r\n\r\n    /** Sets the emitter for this Renderer, if it is not already set. Returns the active emitter.  */\r\n    @JsName(\"setEmitter\") fun setEmitter(emitter: dynamic): dynamic {\r\n        if (this.eventEmitter == null) {\r\n            this.eventEmitter = emitter\r\n        }\r\n\r\n        return this.eventEmitter\r\n    }\r\n\r\n    override fun displayWarning(w: String){\r\n        eventEmitter?.emit(\"warning\", w)\r\n    }\r\n\r\n    /** Display a given ERROR */\r\n    override fun displayError(thing: Any) {\r\n        eventEmitter?.emit(\"error\", thing)\r\n    }\r\n\r\n    /** Display a given [AssemblerError] */\r\n    override fun displayAssemblerError(e: AssemblerError) {\r\n        eventEmitter?.emit(\"assembler_error\", e)\r\n    }\r\n\r\n    override fun stdout(thing: Any) {\r\n        eventEmitter?.emit(\"stdout\", thing)\r\n    }\r\n\r\n    override fun printConsole(thing: Any) {\r\n        eventEmitter?.emit(\"printConsole\", thing)\r\n    }\r\n\r\n}\r\n","package venus\r\n/* ktlint-disable no-wildcard-imports */\r\n\r\nimport org.w3c.dom.*\r\nimport venus.vfs.*\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.Simulator\r\nimport venusbackend.simulator.SimulatorError\r\nimport venusbackend.simulator.cache.BlockState\r\nimport venusbackend.simulator.cache.ChangedBlockState\r\nimport venusbackend.simulator.diffs.*\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\nimport kotlin.dom.addClass\r\nimport kotlin.dom.removeClass\r\n\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n/**\r\n * This singleton is used to render different parts of the screen, it serves as an interface between the UI and the\r\n * internal simulator.\r\n *\r\n * @todo break this up into multiple objects\r\n */\r\ninternal object RendererOriginal {\r\n    /** The register currently being highlighted */\r\n    private var activeRegister: HTMLElement? = null\r\n    /** The instruction currently being highlighted */\r\n    private var activeInstruction: HTMLElement? = null\r\n    /** The memory location currently centered */\r\n    var activeMemoryAddress: Int = 0\r\n    /** The simulator being rendered */\r\n    private var sim: Simulator = Simulator(LinkedProgram(), VirtualFileSystem(\"dummy\"))\r\n    /* The way the information in the registers is displayed*/\r\n    private var displayType = \"hex\"\r\n\r\n    @JsName(\"renderTab\") fun renderTab(tab: String, tabs: List<String>) {\r\n        if (!tabs.contains(tab)) {\r\n            return\r\n        }\r\n        for (t in tabs) {\r\n            var disp = \"none\"\r\n            if (t.equals(tab)) {\r\n                disp = \"block\"\r\n            }\r\n            tabSetVisibility(t, disp)\r\n        }\r\n    }\r\n\r\n    @JsName(\"addTab\") fun addTab(tabName: String, tabList: ArrayList<String>): Boolean {\r\n        if (!tabList.contains(tabName)) {\r\n            tabList.add(tabName)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    @JsName(\"removeTab\") fun removeTab(tabName: String, tabList: ArrayList<String>): Boolean {\r\n        if (tabList.contains(tabName)) {\r\n            tabList.remove(tabName)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    var mainTabs: ArrayList<String> = arrayListOf(\"simulator\", \"editor\", \"venus\")\r\n    /**\r\n     * Shows the simulator tab and hides other tabs\r\n     *\r\n     * @param displaySim the simulator to show\r\n     */\r\n    fun renderSimulator() {\r\n        renderTab(\"simulator\", mainTabs)\r\n    }\r\n\r\n    fun loadSimulator(displaySim: Simulator) {\r\n        sim = displaySim\r\n        setRunButtonSpinning(false)\r\n        renderProgramListing()\r\n        clearConsole()\r\n        updateAll()\r\n        renderSimButtons()\r\n    }\r\n\r\n    fun renderSimButtons() {\r\n        val simbtns = document.getElementById(\"simulator-buttons\") as HTMLDivElement\r\n        val simassmbbtns = document.getElementById(\"simulator-assemble-buttons\") as HTMLDivElement\r\n        simassmbbtns.style.display = \"none\"\r\n        simbtns.style.display = \"\"\r\n    }\r\n\r\n    fun renderAssembleButtons() {\r\n        val simbtns = document.getElementById(\"simulator-buttons\") as HTMLDivElement\r\n        val simassmbbtns = document.getElementById(\"simulator-assemble-buttons\") as HTMLDivElement\r\n        simassmbbtns.style.display = \"\"\r\n        simbtns.style.display = \"none\"\r\n    }\r\n\r\n    /** Shows the editor tab and hides other tabs */\r\n    fun renderEditor() {\r\n        renderTab(\"editor\", mainTabs)\r\n        renderAssembleButtons()\r\n    }\r\n\r\n    fun renderVenus() {\r\n        renderTab(\"venus\", mainTabs)\r\n    }\r\n\r\n    fun renderURLMaker() {\r\n        renderTab(\"urlmaker\", mainTabs)\r\n    }\r\n\r\n    /**\r\n     * Sets the tab to the desired visiblity.\r\n     *\r\n     * Also updates the highlighted tab at the top.\r\n     *\r\n     * @param tab the name of the tab (currently \"editor\" or \"simulator\")\r\n     */\r\n    @JsName(\"tabSetVisibility\") private fun tabSetVisibility(tab: String, display: String) {\r\n        val tabView = document.getElementById(\"$tab-tab-view\") as HTMLElement\r\n        val tabDisplay = document.getElementById(\"$tab-tab\") as HTMLElement\r\n        tabView.style.display = display\r\n        if (display == \"none\") {\r\n            tabDisplay.classList.remove(\"is-active\")\r\n        } else {\r\n            tabDisplay.classList.add(\"is-active\")\r\n        }\r\n    }\r\n\r\n    fun displayWarning(w: String) {\r\n        printConsole(w)\r\n    }\r\n\r\n    /** Display a given ERROR */\r\n    fun displayError(thing: Any) {\r\n        printConsole(\"\\n------STDERR------\\n\")\r\n        printConsole(thing)\r\n        printConsole(\"\\n----STDERR_END----\\n\")\r\n    }\r\n\r\n    fun stdout(thing: Any) {\r\n        printConsole(thing)\r\n    }\r\n\r\n    fun stderr(thing: Any) {\r\n        displayError(thing)\r\n    }\r\n\r\n    /** Display a given [AssemblerError] */\r\n    @Suppress(\"UNUSED_PARAMETER\") fun displayAssemblerError(e: AssemblerError) {\r\n//        if (e.line !== null) {\r\n//            js(\"alert('[ERROR]\\\\n(Line: ' + e.line + ') ' + e.message)\")\r\n//        } else {\r\n            js(\"alert('[ERROR]\\\\n' + e.message)\")\r\n//        }\r\n    }\r\n\r\n    /**\r\n     * Renders the program listing under the debugger\r\n     */\r\n    private fun renderProgramListing() {\r\n        clearProgramListing()\r\n        for (i in 0 until sim.linkedProgram.prog.insts.size) {\r\n            val programDebug = sim.linkedProgram.dbg[i]\r\n            val (_, dbg) = programDebug\r\n            val (_, line) = dbg\r\n            val mcode = sim.linkedProgram.prog.insts[i]\r\n            val pc = sim.instOrderMapping[i]!!\r\n            addToProgramListing(pc, mcode, line)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Refresh all of the simulator tab's content\r\n     *\r\n     * @todo refactor this into a \"reset\" and \"update\" all function\r\n     */\r\n    fun updateAll() {\r\n        updateText()\r\n        updatePC(sim.getPC())\r\n        updateMemory(activeMemoryAddress)\r\n        updateControlButtons()\r\n        for (i in 0..31) {\r\n            updateRegister(i, sim.getReg(i))\r\n        }\r\n        for (i in 0..31) {\r\n            updateFRegister(i, sim.getFReg(i))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the view by applying each individual diff.\r\n     *\r\n     * @param diffs the list of diffs to apply\r\n     */\r\n    fun updateFromDiffs(diffs: List<Diff>) {\r\n        for (diff in diffs) {\r\n            when (diff) {\r\n                is RegisterDiff -> updateRegister(diff.id, diff.v, true)\r\n                is FRegisterDiff -> updateFRegister(diff.id, diff.v, true)\r\n                is PCDiff -> updatePC(diff.pc)\r\n                is MemoryDiff -> updateMemory(diff.addr.toInt())\r\n                is CacheDiff -> updateCache(diff.addr)\r\n                is InstructionDiff -> {}\r\n                else -> {\r\n                    println(\"diff not yet implemented\")\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the current program listing.\r\n     *\r\n     * @todo find a less hacky way to do this?\r\n     */\r\n    fun clearProgramListing() {\r\n        getElement(\"program-listing-body\").innerHTML = \"\"\r\n    }\r\n\r\n    /**\r\n     * Adds an instruction with the given index to the program listing.\r\n     *\r\n     * @param idx the pc of the instruction\r\n     * @param mcode the machine code representation of the instruction\r\n     * @param progLine the original assembly code\r\n     */\r\n    fun addToProgramListing(pcx: Int, mcode: MachineCode, progLine: String, invalidInst: Boolean = false) {\r\n        val programTable = getElement(\"program-listing-body\") as HTMLTableSectionElement\r\n\r\n        val newRow = programTable.insertRow() as HTMLTableRowElement\r\n        newRow.id = \"instruction-$pcx\"\r\n        newRow.onclick = { Driver.addBreakpoint(pcx) }\r\n\r\n        val pcline = newRow.insertCell(0)\r\n        val pcText = document.createTextNode(\"0x\" + (pcx).toString(16))\r\n        pcline.appendChild(pcText)\r\n\r\n        val hexRepresention = toHex(mcode[InstructionField.ENTIRE].toInt(), mcode.length * 2)\r\n        val machineCode = newRow.insertCell(1)\r\n        val machineCodeText = document.createTextNode(hexRepresention)\r\n        machineCode.appendChild(machineCodeText)\r\n\r\n        val basicCode = newRow.insertCell(2)\r\n        val basicCodeText = document.createTextNode(if (invalidInst) progLine else Instruction[mcode].disasm(mcode))\r\n        basicCode.appendChild(basicCodeText)\r\n\r\n        val line = newRow.insertCell(3)\r\n        val lineText = document.createTextNode(progLine)\r\n        line.appendChild(lineText)\r\n    }\r\n\r\n    fun updateProgramListing(idx: Number, inst: Int, orig: String? = null): InstructionDiff {\r\n        val instTab = document.getElementById(\"instruction-$idx\")\r\n        val children = instTab?.children\r\n        val mcode = MachineCode(inst)\r\n        var code = \"Invalid Instruction\"\r\n        try {\r\n            code = Instruction[mcode].disasm(mcode)\r\n        } catch (e: SimulatorError) {}\r\n        val pre = InstructionDiff(idx.toInt(), userStringToInt(children?.get(1)?.innerHTML ?: \"-1\"), children?.get(3)?.innerHTML ?: \"\")\r\n        children?.get(1)?.innerHTML = toHex(mcode[InstructionField.ENTIRE].toInt()) /*Machine Code*/\r\n        children?.get(2)?.innerHTML = code /*Basic Code*/\r\n        children?.get(3)?.innerHTML = orig ?: code /*Original Code*/\r\n        return pre\r\n    }\r\n\r\n    /**\r\n     * Gets the element with a given ID\r\n     *\r\n     * @param id the id of the desired element\r\n     *\r\n     * @returns the HTML element corresponding to the given ID\r\n     * @throws ClassCastException if the element is not an [HTMLElement] or does not exist\r\n     */\r\n    fun getElement(id: String): HTMLElement = document.getElementById(id) as HTMLElement\r\n\r\n    /**\r\n     * Updates the register with the given id and value.\r\n     *\r\n     * @param id the ID of the register (e.g., x13 has ID 13)\r\n     * @param value the new value of the register\r\n     * @param setActive whether the register should be set to the active register (i.e., highlighted for the user)\r\n     */\r\n    fun updateRegister(id: Int, value: Number, setActive: Boolean = false) {\r\n        val register = getElement(\"reg-$id-val\") as HTMLInputElement\r\n        register.value = when (displayType) {\r\n            \"Hex\" -> toHex(value.toInt())\r\n            \"Decimal\" -> value.toString()\r\n            \"Unsigned\" -> toUnsigned(value.toInt())\r\n            \"ASCII\" -> toAscii(value.toInt())\r\n            else -> toHex(value.toInt())\r\n        }\r\n        if (setActive) {\r\n            activeRegister?.classList?.remove(\"is-modified\")\r\n            register.classList.add(\"is-modified\")\r\n            activeRegister = register\r\n        }\r\n    }\r\n    /**\r\n     * Updates the register with the given id and value.\r\n     *\r\n     * @param id the ID of the floating register (e.g., f13 has ID 13)\r\n     * @param value the new value of the register\r\n     * @param setActive whether the register should be set to the active register (i.e., highlighted for the user)\r\n     */\r\n    fun updateFRegister(id: Int, v: Decimal, setActive: Boolean = false) {\r\n        val fregister = getElement(\"freg-$id-val\") as HTMLInputElement\r\n        fregister.value = when (displayType) {\r\n            \"Hex\" -> v.toHex()\r\n            \"Decimal\" -> v.toDecimal()\r\n            \"Unsigned\" -> v.toUnsigned()\r\n            \"ASCII\" -> v.toAscii()\r\n            else -> v.toHex()\r\n        }\r\n        if (setActive) {\r\n            activeRegister?.classList?.remove(\"is-modified\")\r\n            fregister.classList.add(\"is-modified\")\r\n            activeRegister = fregister\r\n        }\r\n    }\r\n\r\n    fun intToString(value: Int): String {\r\n        var v = when (displayType) {\r\n            \"Hex\" -> toHex(value)\r\n            \"Decimal\" -> value.toString()\r\n            \"Unsigned\" -> toUnsigned(value)\r\n            \"ASCII\" -> toAscii(value)\r\n            else -> toHex(value)\r\n        }\r\n        return v\r\n    }\r\n    /*@TODO make it so I can detect between if I am continuing or not so I do not have to be too wasteful.*/\r\n    fun updateCache(a: Address) {\r\n        // println(\"Need to implement the update cHandler feature!\")\r\n        (document.getElementById(\"hit-count\") as HTMLInputElement).value = Driver.cache.getHitCount().toString()\r\n        val hr = Driver.cache.getHitRate()\r\n        (document.getElementById(\"hit-rate\") as HTMLInputElement).value = (if (hr.isNaN()) \"???\" else hr).toString()\r\n        (document.getElementById(\"access-amt\") as HTMLInputElement).value = Driver.cache.memoryAccessCount().toString()\r\n        // (document.getElementById(\"cacheDebug\") as HTMLDivElement).innerHTML = Driver.cache.getBlocksState().toString()\r\n        try {\r\n            updateAllCacheBlocks()\r\n        } catch (e: Throwable) {\r\n            makeCacheBlocks()\r\n            updateAllCacheBlocks()\r\n        }\r\n    }\r\n\r\n    fun renderSetCacheLevel(i: Int) {\r\n        val clvl = document.getElementById(\"cacheLevel\") as HTMLSelectElement\r\n        clvl.value = \"L\" + i.toString()\r\n    }\r\n\r\n    fun renderAddCacheLevel() {\r\n        val clvl = document.getElementById(\"cacheLevel\") as HTMLSelectElement\r\n        val newCacheNumber = clvl.options.length + 1\r\n        val option = document.createElement(\"option\") as HTMLOptionElement\r\n        option.innerHTML = \"L\" + newCacheNumber.toString()\r\n        clvl.options[clvl.options.length] = option\r\n    }\r\n\r\n    fun renderRemoveCacheLevel() {\r\n        val clvl = document.getElementById(\"cacheLevel\") as HTMLSelectElement\r\n        clvl.options[clvl.options.length - 1] = null\r\n    }\r\n\r\n    fun makeCacheBlocks() {\r\n        val t = document.createElement(\"table\")\r\n        t.setAttribute(\"style\", \"border-collapse: collapse;border: 1px solid black;width:100%;\")\r\n        val bs = Driver.cache.getBlocksState()\r\n        val b = Driver.cache.currentState().getChangedBlockState()\r\n        for (i in bs.indices) {\r\n            val tr = document.createElement(\"tr\")\r\n            val th = document.createElement(\"th\")\r\n            if (!b.noChange && b.block == i) {\r\n                tr.setAttribute(\"style\", \"border: 2px solid black;\")\r\n            } else {\r\n                tr.setAttribute(\"style\", \"border: 1px solid black;\")\r\n            }\r\n            th.id = \"cache-block-\" + i.toString()\r\n            th.innerHTML = i.toString() + \") \" + bs[i]\r\n            tr.appendChild(th)\r\n            t.appendChild(tr)\r\n        }\r\n        val cb = (document.getElementById(\"cacheBlocks\") as HTMLDivElement)\r\n        cb.innerHTML = \"\"\r\n        cb.appendChild(t)\r\n    }\r\n\r\n    fun updateCacheBlocks(b: ChangedBlockState = Driver.cache.currentState().getChangedBlockState()) {\r\n        if (!b.noChange) {\r\n            val pb = Driver.cache.currentState().getPrevChangedBlock()\r\n            if (pb != -1) {\r\n                val prevelm = document.getElementById(\"cache-block-\" + pb.toString())\r\n                prevelm?.parentElement?.setAttribute(\"style\", \"border: 1px solid black;\")\r\n            }\r\n            val elm = document.getElementById(\"cache-block-\" + b.block.toString())\r\n            elm?.parentElement?.setAttribute(\"style\", \"border: 2px solid black;\")\r\n            if (b.state == BlockState.HIT) {\r\n                elm?.innerHTML = b.block.toString() + \") HIT\"\r\n                elm?.setAttribute(\"style\", \"background-color:#00d1b2;\")\r\n            } else if (b.state == BlockState.MISS) {\r\n                elm?.innerHTML = b.block.toString() + \") MISS\"\r\n                elm?.setAttribute(\"style\", \"background-color:#ff4e4e;\")\r\n            } else {\r\n                elm?.innerHTML = b.block.toString() + \") EMPTY\"\r\n                elm?.setAttribute(\"style\", \"\")\r\n            }\r\n        }\r\n    }\r\n\r\n    fun updateAllCacheBlocks() {\r\n        val bs = Driver.cache.currentState().getBlocksState()\r\n        for (i in bs.indices) {\r\n            val elm = document.getElementById(\"cache-block-\" + i.toString())\r\n            elm?.parentElement?.setAttribute(\"style\", \"border: 1px solid black;\")\r\n            if (BlockState.valueOf(bs[i]) == BlockState.HIT) {\r\n                elm?.innerHTML = i.toString() + \") HIT\"\r\n                elm?.setAttribute(\"style\", \"background-color:#00d1b2;\")\r\n            } else if (BlockState.valueOf(bs[i]) == BlockState.MISS) {\r\n                elm?.innerHTML = i.toString() + \") MISS\"\r\n                elm?.setAttribute(\"style\", \"background-color:#ff4e4e;\")\r\n            } else {\r\n                elm?.innerHTML = i.toString() + \") EMPTY\"\r\n                elm?.setAttribute(\"style\", \"\")\r\n            }\r\n        }\r\n        updateCacheBlocks()\r\n    }\r\n\r\n    /**\r\n     * Updates the PC to the given value. It also highlights the to-be-executed instruction.\r\n     *\r\n     * @param pc the new PC\r\n     * @todo abstract away instruction length\r\n     */\r\n    fun updatePC(pc: Number) {\r\n//        val idx = (pc.toInt() - MemorySegments.TEXT_BEGIN) / 4\r\n//        val idx = sim.invInstOrderMapping[pc.toInt()]\r\n        val idx = pc.toInt()\r\n        activeInstruction?.classList?.remove(\"is-selected\")\r\n        val newActiveInstruction = document.getElementById(\"instruction-$idx\") as HTMLElement?\r\n        newActiveInstruction?.classList?.add(\"is-selected\")\r\n        newActiveInstruction?.scrollIntoView(false)\r\n        activeInstruction = newActiveInstruction\r\n    }\r\n\r\n    /**\r\n     * Prints the given thing to the console as a string.\r\n     *\r\n     * @param thing the thing to print\r\n     */\r\n    internal fun printConsole(thing: Any) {\r\n        val console = getElement(\"console-output\") as HTMLTextAreaElement\r\n        console.value += thing.toString()\r\n    }\r\n\r\n    /**\r\n     * Clears the console\r\n     */\r\n    fun clearConsole() {\r\n        val console = getElement(\"console-output\") as HTMLTextAreaElement\r\n        console.value = \"\"\r\n    }\r\n\r\n    /**\r\n     * Sets whether the run button is spinning.\r\n     *\r\n     * @param spinning whether the button should be spin\r\n     */\r\n    fun setRunButtonSpinning(spinning: Boolean) {\r\n        val runButton = getElement(\"simulator-run\")\r\n        if (spinning) {\r\n            runButton.classList.add(\"is-loading\")\r\n            disableControlButtons()\r\n        } else {\r\n            runButton.classList.remove(\"is-loading\")\r\n            updateControlButtons()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets whether the name button is spinning.\r\n     *\r\n     * @param spinning whether the button should be spin\r\n     */\r\n    fun setNameButtonSpinning(name: String, spinning: Boolean) {\r\n        val runButton = getElement(name)\r\n        if (spinning) {\r\n            runButton.classList.add(\"is-loading\")\r\n            disableControlButtons()\r\n        } else {\r\n            runButton.classList.remove(\"is-loading\")\r\n            updateControlButtons()\r\n        }\r\n    }\r\n    /**\r\n     * Sets whether a button is disabled.\r\n     *\r\n     * @param id the id of the button to change\r\n     * @param disabled whether or not to disable the button\r\n     */\r\n    private fun setButtonDisabled(id: String, disabled: Boolean) {\r\n        val button = getElement(id) as HTMLButtonElement\r\n        button.disabled = disabled\r\n    }\r\n\r\n    /**\r\n     * Renders the control buttons to be enabled / disabled appropriately.\r\n     */\r\n    fun updateControlButtons() {\r\n        setButtonDisabled(\"simulator-reset\", !sim.canUndo())\r\n        setButtonDisabled(\"simulator-undo\", !sim.canUndo())\r\n        setButtonDisabled(\"simulator-step\", sim.isDone())\r\n        setButtonDisabled(\"simulator-run\", sim.isDone())\r\n        setButtonDisabled(\"simulator-trace\", sim.instOrderMapping.isEmpty() or sim.isDone())\r\n    }\r\n\r\n    /**\r\n     * Disables the step, undo and reset buttons.\r\n     *\r\n     * Used while running, see [Driver.runStart].\r\n     */\r\n    fun disableControlButtons() {\r\n        setButtonDisabled(\"simulator-reset\", true)\r\n        setButtonDisabled(\"simulator-undo\", true)\r\n        setButtonDisabled(\"simulator-step\", true)\r\n    }\r\n\r\n    /**\r\n     * Renders a change in breakpoint status\r\n     *\r\n     * @param idx the index to render\r\n     * @param state whether or not there is a breakpoint\r\n     */\r\n    fun renderBreakpointAt(idx: Int, state: Boolean) {\r\n        val row = getElement(\"instruction-$idx\")\r\n        if (state) {\r\n            row.classList.add(\"is-breakpoint\")\r\n        } else {\r\n            row.classList.remove(\"is-breakpoint\")\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Number of rows to show around the current address\r\n     */\r\n    const val MEMORY_CONTEXT = 6\r\n\r\n    /** Show the memory sidebar tab */\r\n    fun renderMemoryTab() {\r\n        tabSetVisibility(\"memory\", \"block\")\r\n        tabSetVisibility(\"register\", \"none\")\r\n        tabSetVisibility(\"cache\", \"none\")\r\n    }\r\n\r\n    /** Show the register sidebar tab */\r\n    fun renderRegisterTab() {\r\n        tabSetVisibility(\"register\", \"block\")\r\n        tabSetVisibility(\"memory\", \"none\")\r\n        tabSetVisibility(\"cache\", \"none\")\r\n    }\r\n\r\n    fun renderCacheTab() {\r\n        tabSetVisibility(\"cache\", \"block\")\r\n        tabSetVisibility(\"memory\", \"none\")\r\n        tabSetVisibility(\"register\", \"none\")\r\n    }\r\n\r\n    fun renderSettingsTab() {\r\n        tabSetVisibility(\"settings\", \"block\")\r\n    }\r\n\r\n    fun renderGeneralSettingsTab() {\r\n        tabSetVisibility(\"general-settings\", \"block\")\r\n        tabSetVisibility(\"tracer-settings\", \"none\")\r\n        tabSetVisibility(\"packages\", \"none\")\r\n    }\r\n\r\n    /**\r\n     * Show the tracer settings tab\r\n     */\r\n    fun renderTracerSettingsTab() {\r\n        tabSetVisibility(\"general-settings\", \"none\")\r\n        tabSetVisibility(\"tracer-settings\", \"block\")\r\n        tabSetVisibility(\"packages\", \"none\")\r\n    }\r\n\r\n    fun renderPackagesTab() {\r\n        tabSetVisibility(\"general-settings\", \"none\")\r\n        tabSetVisibility(\"tracer-settings\", \"none\")\r\n        tabSetVisibility(\"packages\", \"block\")\r\n    }\r\n\r\n    fun renderRegsTab() {\r\n        tabSetVisibility(\"regs\", \"block\")\r\n        tabSetVisibility(\"fregs\", \"none\")\r\n    }\r\n\r\n    fun renderFRegsTab() {\r\n        tabSetVisibility(\"regs\", \"none\")\r\n        tabSetVisibility(\"fregs\", \"block\")\r\n    }\r\n\r\n    fun rendererAddPackage(pid: String, enabled: Boolean, removable: Boolean = true) {\r\n        val rp = document.createElement(\"div\")\r\n        rp.addClass(\"panel-block\")\r\n        rp.id = \"package-$pid\"\r\n\r\n        val name = document.createElement(\"div\")\r\n        name.innerHTML = pid\r\n        rp.appendChild(name)\r\n\r\n        val enabledButton = document.createElement(\"button\")\r\n        enabledButton.id = \"penable-button-$pid\"\r\n        enabledButton.addClass(\"button\")\r\n        if (enabled) {\r\n            enabledButton.addClass(\"is-primary\")\r\n        }\r\n        enabledButton.setAttribute(\"onclick\", \"this.classList.add('is-loading');driver.togglePackage('$pid')\")\r\n        enabledButton.innerHTML = \"Enabled\"\r\n        rp.appendChild(enabledButton)\r\n\r\n        if (removable) {\r\n            val deleteButton = document.createElement(\"button\")\r\n            deleteButton.id = \"pdelete-button-$pid\"\r\n            deleteButton.addClass(\"button\")\r\n            deleteButton.setAttribute(\"onclick\", \"this.classList.add('is-loading');driver.removePackage('$pid')\")\r\n            deleteButton.setAttribute(\"style\", \"background-color: red;\")\r\n            deleteButton.innerHTML = \"Delete\"\r\n            rp.appendChild(deleteButton)\r\n        }\r\n\r\n        document.getElementById(\"package-list\")?.appendChild(rp)\r\n    }\r\n\r\n    fun rendererRemovePackage(pid: String) {\r\n        document.getElementById(\"package-$pid\")?.remove()\r\n    }\r\n\r\n    fun rendererUpdatePackage(pid: String, state: Boolean) {\r\n        val p = document.getElementById(\"penable-button-$pid\")\r\n        if (p != null) {\r\n            if (state) {\r\n                p.addClass(\"is-primary\")\r\n            } else {\r\n                p.removeClass(\"is-primary\")\r\n            }\r\n            p.removeClass(\"is-loading\")\r\n        } else {\r\n            console.log(\"Could not find package '$pid!'\")\r\n        }\r\n    }\r\n\r\n    var pkgmsgTimeout: Int? = null\r\n    fun pkgMsg(m: String) {\r\n        if (pkgmsgTimeout != null) {\r\n            window.clearTimeout(pkgmsgTimeout ?: -1)\r\n        }\r\n        val d = document.getElementById(\"package-msgs\")\r\n        d?.innerHTML = m\r\n        pkgmsgTimeout = window.setTimeout(Renderer::clearPkgMsg, 10000)\r\n    }\r\n\r\n    fun clearPkgMsg() {\r\n        document.getElementById(\"package-msgs\")?.innerHTML = \"\"\r\n    }\r\n\r\n    /**\r\n     * Update the [MEMORY_CONTEXT] words above and below the given address.\r\n     *\r\n     * Does not shift the memory display if it can be avoided\r\n     *\r\n     * @param addr the address to update around\r\n     */\r\n    fun updateMemory(addr: Int) {\r\n        val wordAddress = (addr shr 2) shl 2\r\n        if (mustMoveMemoryDisplay(wordAddress)) {\r\n            activeMemoryAddress = wordAddress\r\n        }\r\n\r\n        for (rowIdx in -MEMORY_CONTEXT..MEMORY_CONTEXT) {\r\n            val row = getElement(\"mem-row-$rowIdx\")\r\n            val rowAddr = activeMemoryAddress + 4 * rowIdx\r\n            renderMemoryRow(row, rowAddr)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines if we need to move the memory display to show the address\r\n     *\r\n     * @param wordAddress the address we want to show\r\n     * @return true if we need to move the display\r\n     */\r\n    private fun mustMoveMemoryDisplay(wordAddress: Int) =\r\n            (activeMemoryAddress - wordAddress) shr 2 !in -MEMORY_CONTEXT..MEMORY_CONTEXT\r\n\r\n    /**\r\n     * Renders a row of the memory.\r\n     *\r\n     * @param row the HTML element of the row to render\r\n     * @param rowAddr the new address of that row\r\n     */\r\n    private fun renderMemoryRow(urow: HTMLElement, rowAddr: Int) {\r\n        val row = cleanTableRow(urow)\r\n        val tdAddress = row.childNodes[0] as HTMLTableCellElement\r\n        if (rowAddr >= 0) {\r\n            tdAddress.innerText = toHex(rowAddr)\r\n            for (i in 1..4) {\r\n                val tdByte = row.childNodes[i] as HTMLTableCellElement\r\n                val byte = sim.loadByte(rowAddr + i - 1)\r\n                tdByte.innerText = when (displayType) {\r\n                    \"Hex\" -> byteToHex(byte)\r\n                    \"Decimal\" -> byteToDec(byte)\r\n                    \"Unsigned\" -> byteToUnsign(byte)\r\n                    \"ASCII\" -> toAscii(byte, 2)\r\n                    else -> byteToHex(byte)\r\n                }\r\n            }\r\n        } else {\r\n            tdAddress.innerText = \"----------\"\r\n            for (i in 1..4) {\r\n                val tdByte = row.childNodes[i] as HTMLTableCellElement\r\n                tdByte.innerText = \"--\"\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun cleanTableRow(row: HTMLElement): HTMLElement {\r\n        for (n in row.childNodes.asList()) {\r\n            if (n !is HTMLTableCellElement) {\r\n                row.removeChild(n)\r\n            }\r\n        }\r\n        return row\r\n    }\r\n\r\n    /** a map from integers to the corresponding hex digits */\r\n    private val hexMap = listOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n        'A', 'B', 'C', 'D', 'E', 'F')\r\n\r\n    /**\r\n     * Convert a certain byte to hex\r\n     *\r\n     * @param b the byte to convert\r\n     * @return a hex string for the byte\r\n     *\r\n     * @throws IndexOutOfBoundsException if b is not in -127..255\r\n     */\r\n    private fun byteToHex(b: Int): String {\r\n        val leftNibble = hexMap[b ushr 4]\r\n        val rightNibble = hexMap[b and 15]\r\n        return \"$leftNibble$rightNibble\"\r\n    }\r\n\r\n    private fun byteToDec(b: Int): String = b.toByte().toString()\r\n\r\n    private fun byteToUnsign(b: Int): String = b.toString()\r\n\r\n    /**\r\n     * Converts a value to a two's complement hex number.\r\n     *\r\n     * By two's complement, I mean that -1 becomes 0xFFFFFFFF not -0x1.\r\n     *\r\n     * @param value the value to convert\r\n     * @return the hexadecimal string corresponding to that value\r\n     * @todo move this?\r\n     */\r\n    fun toHex(value: Int, num_nibbles: Int = 8, add_prefix: Boolean = true): String {\r\n        var remainder = value.toLong()\r\n        var suffix = \"\"\r\n\r\n        repeat(num_nibbles) {\r\n            val hexDigit = hexMap[(remainder and 15).toInt()]\r\n            suffix = hexDigit + suffix\r\n            remainder = remainder ushr 4\r\n        }\r\n\r\n        if (add_prefix) {\r\n            suffix = \"0x\" + suffix\r\n        }\r\n\r\n        return suffix\r\n    }\r\n\r\n    fun toHex(value: Number): String {\r\n        return toHex(value.toInt())\r\n    }\r\n\r\n    private fun toUnsigned(value: Int): String =\r\n            if (value >= 0) value.toString() else (value + 0x1_0000_0000L).toString()\r\n\r\n    private fun toAscii(value: Int, num_nibbles: Int = 8): String {\r\n        var s = \"\"\r\n//        for (i in 0..3) {\r\n//            val v = (value shr i * 8) and 0xFF\r\n            val v = value\r\n            s += when (v) {\r\n                !in 0..255 -> toHex(v, num_nibbles = num_nibbles)\r\n//                !in 32..126 -> \"\\uFFFD\"\r\n                !in 32..126 -> toHex(v, num_nibbles = num_nibbles)\r\n                else -> \"${v.toChar()}\"\r\n            }\r\n//        }\r\n        return s\r\n    }\r\n\r\n    /**\r\n     * Sets the display type for all of the registers and memory\r\n     * Rerenders after\r\n     */\r\n    fun updateRegMemDisplay() {\r\n        val displaySelect = getElement(\"display-settings\") as HTMLSelectElement\r\n        displayType = displaySelect.value\r\n        updateAll()\r\n    }\r\n\r\n    fun moveMemoryJump() {\r\n        val jumpSelect = getElement(\"address-jump\") as HTMLSelectElement\r\n        val where = jumpSelect.value\r\n        activeMemoryAddress = when (where) {\r\n            \"Text\" -> MemorySegments.TEXT_BEGIN\r\n            \"Data\" -> MemorySegments.STATIC_BEGIN\r\n            \"Heap\" -> MemorySegments.HEAP_BEGIN\r\n            \"Stack\" -> MemorySegments.STACK_BEGIN\r\n            else -> MemorySegments.TEXT_BEGIN\r\n        }\r\n        updateMemory(activeMemoryAddress)\r\n        jumpSelect.selectedIndex = 0\r\n    }\r\n\r\n    private fun moveMemoryBy(rows: Int) {\r\n        val bytes = 4 * rows\r\n        if (activeMemoryAddress + bytes < 0) return\r\n        activeMemoryAddress += bytes\r\n        updateMemory(activeMemoryAddress)\r\n    }\r\n\r\n    fun moveMemoryUp() = moveMemoryBy(MEMORY_CONTEXT)\r\n    fun moveMemoryDown() = moveMemoryBy(-MEMORY_CONTEXT)\r\n\r\n    fun updateText() {\r\n        var t = (document.getElementById(\"text-start\") as HTMLInputElement)\r\n        t.value = intToString(userStringToInt(t.value))\r\n    }\r\n\r\n    fun renderButton(e: HTMLButtonElement, b: Boolean) {\r\n        if (b) {\r\n            e.classList.add(\"is-primary\")\r\n        } else {\r\n            e.classList.remove(\"is-primary\")\r\n        }\r\n        e.value = b.toString()\r\n    }\r\n\r\n    fun addObjectToDisplay(obj: VFSObject, special: String = \"\") {\r\n        val b = document.getElementById(\"files-listing-body\")!!\r\n        var elm = document.createElement(\"tr\")\r\n        if (special == \"\") {\r\n            elm.setAttribute(\"id\", obj.label)\r\n            elm.innerHTML = \"<td>${obj.label}</td>\"\r\n            elm.innerHTML += \"<td>${obj.type.name}</td>\"\r\n            var options = \"<td>\"\r\n\r\n            when (obj) {\r\n                is VFSDrive -> {\r\n                    options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.openVFObject('${obj.getPath()}')\\\">Open</button>\\n\"\r\n                }\r\n                is VFSFile -> {\r\n                    options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.editVFObject('${obj.getPath()}')\\\">Edit</button>\\n\"\r\n                    options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.saveVFObject('${obj.getPath()}')\\\">Save</button>\\n\"\r\n                    options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.vdbVFObject('${obj.getPath()}')\\\">VDB</button>\\n\"\r\n                }\r\n                is VFSFolder -> {\r\n                    options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.openVFObject('${obj.getPath()}')\\\">Open</button>\\n\"\r\n                }\r\n                is VFSLinkedProgram -> {\r\n                    // TODO\r\n                }\r\n                is VFSProgram -> {\r\n                    // TODO\r\n                }\r\n                else -> {\r\n                    // TODO\r\n                }\r\n            }\r\n            options += \"<button class=\\\"button is-primary\\\" style=\\\"background-color:red;\\\" \" +\r\n                    \"onclick=\\\"driver.deleteVFObject('${obj.getPath()}')\\\">Delete</button>\"\r\n            options += \"</td>\"\r\n\r\n            elm.innerHTML += options\r\n        } else {\r\n            elm.setAttribute(\"id\", special)\r\n            elm.innerHTML = \"<td>$special</td>\"\r\n            elm.innerHTML += \"<td>${obj.type.name}</td>\"\r\n            var options = \"<td>\"\r\n            options += \"<button class=\\\"button is-primary\\\" onclick=\\\"driver.openVFObject('$special')\\\">Open</button>\\n\"\r\n            options += \"</td>\"\r\n            elm.innerHTML += options\r\n        }\r\n        b.appendChild(elm)\r\n    }\r\n\r\n    fun addFilePWD(obj: VFSObject) {\r\n        var b = document.getElementById(\"files-listing-pwd\")!!\r\n        var pwd = \"\"\r\n        var o = obj\r\n        while (o !is VFSDrive) {\r\n            val path = o.getPath()\r\n            pwd = \"<a onclick=\\\"driver.openVFObject('$path')\\\">${o.label}</a>/\" + pwd\r\n            o = o.parent\r\n        }\r\n        val path = o.getPath()\r\n        pwd = \"<a onclick=\\\"driver.openVFObject('$path')\\\">${o.label}</a>/\" + pwd\r\n        b.innerHTML = pwd\r\n    }\r\n\r\n    fun clearObjectsFromDisplay() {\r\n        var b = document.getElementById(\"files-listing-body\")!!\r\n        b.innerHTML = \"\"\r\n        b = document.getElementById(\"files-listing-pwd\")!!\r\n        b.innerHTML = \"\"\r\n    }\r\n}\r\n","package venus.terminal.cmds\r\n\r\nimport venusbackend.assembler.Assembler\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSObject\r\nimport venus.vfs.VFSProgram\r\nimport venus.vfs.VFSType\r\n\r\nvar assemble = Command(\r\n        name = \"assemble\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size !in listOf(1, 2)) {\r\n                return Command[\"assemble\"].help\r\n            }\r\n            val filein = args[0]\r\n            val programout = if (args.size == 2) args[1] else \"a.out\"\r\n            val file = t.vfs.getObjectFromPath(filein)\r\n            if (file === null) {\r\n                return \"venusbackend.assembler: Could not find file $filein\"\r\n            }\r\n            if (file.type != VFSType.File) {\r\n                return \"assemble: $filein: Is a directory\"\r\n            }\r\n            if (!file.contents.containsKey(VFSFile.innerTxt)) {\r\n                return \"assemble: $filein: COULD NOT FIND FILE CONTENTS!\"\r\n            }\r\n            if (!VFSObject.isValidName(programout)) {\r\n                return \"assemble: $programout: Invalid name\"\r\n            }\r\n            var msg = \"\"\r\n            val (prog, errors, warnings) = Assembler.assemble(file.contents.get(VFSFile.innerTxt) as String, programout, file.getPath())\r\n            if (errors.isNotEmpty()) {\r\n                msg += \"assemble: Could not assemble file! Here are the errors:\"\r\n                for (error in errors) {\r\n                    msg += \"\\n\" + error.toString()\r\n                }\r\n                return msg\r\n            }\r\n            if (warnings.isNotEmpty()) {\r\n                msg += \"assemble: Assembled file with a few warnings:\"\r\n                for (warning in warnings) {\r\n                    msg += \"\\n\" + warning.toString()\r\n                }\r\n            }\r\n            val p = VFSProgram(programout, file.parent, prog)\r\n            file.parent.addChild(p)\r\n            return msg\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"assemble: takes in two arguments: [text in] {[program out], a.out}\r\n            |Returns a.out if no second argument exists\"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar cat = Command(\r\n        name = \"cat\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            return t.vfs.cat(args.joinToString(\" \"))\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"cat: takes in one argument (a file or path to a file) and prints out the contents of the file.\" +\r\n                \"\\nEx cat foo.txt\" +\r\n                \"\\nUsage: cat [path to file]\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar cd = Command(\r\n        name = \"cd\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            return t.vfs.cd(args.joinToString(\" \"))\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"cd takes in one argument (a path) and goes to the directory.\" +\r\n                \"\\nUsage: cd [path]\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\n\r\nvar cp = Command(\r\n        name = \"cp\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return Command[\"cp\"].help\r\n            }\r\n            var result = \"\"\r\n            var f = t.vfs.getObjectFromPath(args[0]) ?: return \"cp: could not find the source file!\"\r\n            var d = t.vfs.getObjectFromPath(args[1]) ?: return \"cp: could not find the destination folder!\"\r\n            if (f is VFSFile) {\r\n                val text = f.readText()\r\n                val new_f = VFSFile(f.label, d)\r\n                new_f.setText(text)\r\n                new_f.permissions = f.permissions\r\n                d.addChild(new_f)\r\n            } else {\r\n                result = \"cp: Copy currently only works on files!\"\r\n            }\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Copies a text/data file to a new location.\r\n            |Usage: cp [src] [dst]\r\n            |NOTE: This is a very dumb copy. It does not work on folders yet or many files!\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSDummy\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSType\r\n\r\nvar download = Command(\r\n        name = \"download\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            val s: StringBuilder = StringBuilder()\r\n            for (fname: String in args) {\r\n                val f = t.vfs.getObjectFromPath(fname) ?: VFSDummy()\r\n                if (f.type == VFSType.File) {\r\n                    downloadFile(fname, (f as VFSFile).readText())\r\n                } else {\r\n                    s.append(\"'$fname' is not a path to a file!\")\r\n                }\r\n            }\r\n            return s.toString()\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        }\r\n)\r\n\r\nfun downloadFile(filename: String, text: String) {\r\n    js(\"\"\"\r\n        var element = document.createElement('a');\r\n        // Due to chars being 16 bytes, we cannot do standard encoding :'(\r\n//        var encoded = encodeURIComponent(text);\r\n        var encoded = \"\";\r\n        for (var i = 0; i < text.length; i++) {\r\n            var byte = (text.charCodeAt(i)).toString(16)\r\n            if (byte.length == 1) {\r\n                byte = \"0\" + byte;\r\n            }\r\n            encoded += \"%\" + byte;\r\n        }\r\n        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encoded);\r\n        element.setAttribute('download', filename);\r\n        \r\n        element.style.display = 'none';\r\n        document.body.appendChild(element);\r\n        \r\n        element.click();\r\n        \r\n        document.body.removeChild(element);\r\n    \"\"\")\r\n}","package venus.terminal.cmds\r\n\r\nimport venus.Driver\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSType\r\n\r\nvar edit = Command(\r\n        name = \"edit\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size != 1) {\r\n                return \"edit: Takes in one argument [filename]\"\r\n            }\r\n            var obj = t.vfs.getObjectFromPath(args[0])\r\n            if (obj === null) {\r\n                val tout = t.vfs.touch(args[0])\r\n                if (tout != \"\") {\r\n                    return \"edit: $tout\"\r\n                }\r\n                obj = t.vfs.getObjectFromPath(args[0]) ?: return \"edit: Failed to make the file!\"\r\n            }\r\n            if (obj.type !== VFSType.File) {\r\n                return \"edit: Only files can be loaded into the editor.\"\r\n            }\r\n            try {\r\n                Driver.editVFObjectfromObj(obj)\r\n            } catch (e: Throwable) {\r\n                return \"edit: Could not load file to the editor!\"\r\n            }\r\n            return \"\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"edit: Takes in one argument [filename] and will copy the contents to the editor tab and then go to the editor tab.\" +\r\n                \"\\nUsage: edit [filename]\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.CommandNotFoundError\r\nimport venus.terminal.Terminal\r\n\r\nvar help = Command(\r\n        name = \"help\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size != 1) {\r\n                return Command[\"help\"].help\r\n            }\r\n            return try {\r\n                Command[args[0]].help\r\n            } catch (e: CommandNotFoundError) {\r\n                \"help: Could not find command '${args[0]}'\"\r\n            }\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return if (args.size == 1) {\r\n                val possibleCommands = ArrayList<String>()\r\n                val prefix = args[0]\r\n                for (c in Command.getCommands()) {\r\n                    if (c.startsWith(prefix)) {\r\n                        possibleCommands.add(c)\r\n                    }\r\n                }\r\n                arrayListOf(prefix, possibleCommands)\r\n            } else {\r\n                arrayListOf(\"\", ArrayList<String>())\r\n            }\r\n        },\r\n        help = \"help: This command takes in zero or one argument.\\nIf you do not have any arguments, all of the commands\" +\r\n                \" will be listed.\\nIf you have one argument, then this will print out the help message of that command.\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSLinkedProgram\r\nimport venus.vfs.VFSObject\r\nimport venus.vfs.VFSProgram\r\nimport venus.vfs.VFSType\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.linker.Linker\r\nimport venusbackend.linker.ProgramAndLibraries\r\nimport venusbackend.riscv.Program\r\n\r\nvar link = Command(\r\n        name = \"link\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size == 0) {\r\n                return \"link: Takes in names of programs which you want to link together. EG link out.l a.out b.out c.out\"\r\n            }\r\n            if (args.size == 1) {\r\n                return \"link: Takes in a minimum of two args link [output] [input], ...\"\r\n            }\r\n            val progs = ArrayList<Program>()\r\n            val output = args.first()\r\n            args.removeAt(0)\r\n            for (program in args) {\r\n                val obj = t.vfs.getObjectFromPath(program)\r\n                if (obj === null) {\r\n                    return \"link: Could not find file at path to $program\"\r\n                }\r\n                if (obj.type != VFSType.Program) {\r\n                    return \"link: The inputs must be programs! ($program)\"\r\n                }\r\n                progs.add((obj as VFSProgram).getProgram())\r\n            }\r\n            val PandL = try {\r\n                ProgramAndLibraries(progs, t.vfs)\r\n            } catch (e: AssertionError) {\r\n                return \"link: An error occurred when getting the imports: $e\"\r\n            }\r\n            val linkedProgram: LinkedProgram\r\n            try {\r\n                linkedProgram = Linker.link(PandL)\r\n            } catch (e: Throwable) {\r\n                return \"link: An error occurred when running the linked program: $e\"\r\n            }\r\n            if (!VFSObject.isValidName(output)) {\r\n                return \"link: The name of the output file is not valid! ($output)\"\r\n            }\r\n            val obj = VFSLinkedProgram(output, t.vfs.currentLocation, linkedProgram)\r\n            return if (t.vfs.currentLocation.addChild(obj)) \"\" else \"link: Could not add linked program to the files!\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"This command takes in names of programs which you want to link together.\" +\r\n                \"It only requires one program but takes in an arbitrary number of programs.\" +\r\n                \"\\nEG link out.l a.out b.out c.out\" +\r\n                \"\\nUsage: link [output] [input program 1] {[input program 2] ... [input program n]}\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar ls = Command(\r\n        name = \"ls\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            return t.vfs.ls()\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            throw NotImplementedError()\r\n        },\r\n        help = \"This command prints out the contents of the current folder.\" +\r\n                \"\\nIt currently does not take in any arguments.\" +\r\n                \"\\nUsage: ls\"\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar mkdir = Command(\r\n        name = \"mkdir\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return \"mkdir: mkdir takes in a folder name.\"\r\n            }\r\n            val result = t.vfs.mkdir(args[0])\r\n            if (result == \"\") {\r\n                t.vfs.save()\r\n            }\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"This command makes a folder in the current directory or path.\r\n            |Usage: mkdir [new folder name]\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar mv = Command(\r\n        name = \"mv\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return Command[\"cp\"].help\r\n            }\r\n            var result = \"\"\r\n            var f = t.vfs.getObjectFromPath(args[0]) ?: return \"mv: could not find the source file!\"\r\n            var d = t.vfs.getObjectFromPath(args[1]) ?: return \"mv: could not find the destination folder!\"\r\n            f.parent.removeChild(f.label)\r\n            f.parent = d\r\n            d.addChild(f)\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Moves a file/folder to a new location.\r\n            |Usage: mv [source] [destination]\r\n            |NOTE: This is a very dumb implementation of move and does not do any fancy things linux move does.\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar pwd = Command(\r\n        name = \"pwd\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            return t.vfs.path()\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"This command prints out the path of the current directory.\r\n            |It does not take any arguments.\r\n            |Usage: path\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar rm = Command(\r\n        name = \"rm\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            var output = \"\"\r\n            var fails = 0\r\n            var attempts = 0\r\n            for (arg in args) {\r\n                attempts++\r\n                val out = t.vfs.remove(arg)\r\n                if (out != \"\") {\r\n                    output += out + \"\\n\"\r\n                    fails++\r\n                }\r\n            }\r\n            if (fails < attempts) {\r\n                t.vfs.save()\r\n            }\r\n            return output\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 0) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Remove (unlink) the FILE(s),\r\n            |Usage: rm [OPTION]... [FILE]...\r\n            |NOTE: Options and multiple file input is currently not implemented yet.\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venusbackend.assembler.Assembler\r\nimport venus.Driver\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSLinkedProgram\r\nimport venus.vfs.VFSProgram\r\nimport venus.vfs.VFSType\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.linker.Linker\r\nimport venusbackend.linker.ProgramAndLibraries\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.simulator.Simulator\r\n\r\nvar run = Command(\r\n        name = \"run\",\r\n        // @TODO Fix how will intemperate files vs args.\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size == 0) {\r\n                return \"run: Takes in names of programs which you want to link together and run.\"\r\n            }\r\n            val file = args.removeAt(0)\r\n            val linkedprogs = ArrayList<LinkedProgram>()\r\n            val progs = ArrayList<Program>()\r\n            val files = ArrayList<VFSFile>()\r\n//            for (file in fs) {\r\n                val obj = t.vfs.getObjectFromPath(file)\r\n                if (obj == null) {\r\n                    return \"run: Could not find file $file\"\r\n                } else {\r\n                    when (obj.type) {\r\n                        VFSType.File -> {\r\n                            files.add(obj as VFSFile)\r\n                        }\r\n                        VFSType.Program -> {\r\n                            progs.add((obj as VFSProgram).getProgram())\r\n                        }\r\n                        VFSType.LinkedProgram -> {\r\n                            if (files.size + progs.size + linkedprogs.size > 0) {\r\n                                return \"run: You must either have no linked programs or just one linked program!\"\r\n                            }\r\n                            linkedprogs.add((obj as VFSLinkedProgram).getLinkedProgram())\r\n                        }\r\n                        else -> {\r\n                            return \"run: Unsupported type: ${obj.type}\"\r\n                        }\r\n                    }\r\n                }\r\n//            }\r\n            if (files.size + progs.size + linkedprogs.size == 0) {\r\n                return \"run: Could not find any of the inputted files!\"\r\n            }\r\n\r\n            // Assembly stage for any files\r\n            var msg = \"\"\r\n            for (file in files) {\r\n                val (prog, errors, warnings) = Assembler.assemble(file.contents.get(VFSFile.innerTxt) as String, file.label, file.getPath())\r\n                if (errors.isNotEmpty()) {\r\n                    msg += \"assemble: Could not assemble file! Here are the errors:\"\r\n                    for (error in errors) {\r\n                        msg += \"\\n\" + error.toString()\r\n                    }\r\n                    return msg\r\n                }\r\n                if (warnings.isNotEmpty()) {\r\n                    msg += \"assemble: Assembled file with a few warnings:\"\r\n                    for (warning in warnings) {\r\n                        msg += \"\\n\" + warning.toString()\r\n                    }\r\n                }\r\n                progs.add(prog)\r\n            }\r\n\r\n            // Linking Stage for any programs\r\n            if (progs.size > 0) {\r\n                val PandL = try {\r\n                    ProgramAndLibraries(progs, t.vfs)\r\n                } catch (e: AssemblerError) {\r\n                    return \"run: An error occurred when getting the imports: $e\"\r\n                }\r\n                val linkedProgram: LinkedProgram\r\n                try {\r\n                    linkedProgram = Linker.link(PandL)\r\n                } catch (e: Throwable) {\r\n                    return \"run: An error occurred when running the linked program: $e\"\r\n                }\r\n                linkedprogs.add(linkedProgram)\r\n            }\r\n\r\n            // Getting the LinkedProgram which we want to simulate\r\n            if (linkedprogs.size != 1) {\r\n                return msg + \"run: There must only be one linked program!\"\r\n            }\r\n            val linkedProgram = linkedprogs[0]\r\n            val sim: Simulator\r\n            try {\r\n                Driver.loadSim(linkedProgram)\r\n                Driver.sim.addArg(args)\r\n                Driver.runStart(false)\r\n            } catch (e: Throwable) {\r\n                return \"run: An error occurred when running the programs execution: $e\"\r\n            }\r\n            return \"VDIRECTIVE:RUNNING...\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 0) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Runs the inputed linked program with given arguments.\r\n            |Usage: run [program name] [argument]...\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.Driver\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar save = Command(\r\n        name = \"save\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size != 1) {\r\n                return \"save: Takes in one argument [filename] which you want to save the editor to.\"\r\n            }\r\n            val txt: String\r\n            try {\r\n                js(\"codeMirror.save();\")\r\n                txt = Driver.getText()\r\n            } catch (e: Throwable) {\r\n                console.error(e)\r\n                return \"save: Could not save file!\"\r\n            }\r\n            var result = t.vfs.write(args[0], txt)\r\n            if (result != \"\") {\r\n                result = t.vfs.touch(args[0])\r\n                if (result == \"\") {\r\n                    result = t.vfs.write(args[0], txt)\r\n                }\r\n            }\r\n            if (result == \"\") {\r\n                t.vfs.save()\r\n                val obj = t.vfs.getObjectFromPath(args[0])!!\r\n                Driver.saveVFObjectfromObj(obj, false)\r\n            }\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size == 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Saves the data in the editor to the specified file.\r\n            |Usage: save [filename]\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\n\r\nvar touch = Command(\r\n        name = \"touch\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return Command[\"touch\"].help\r\n            }\r\n            val result = t.vfs.touch(args[0])\r\n            if (result == \"\") {\r\n                t.vfs.save()\r\n            }\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Creates a text/data file.\r\n            |Usage: touch [filename]\r\n            |NOTE: Does not modify the timestamp at the moment because that is not implemented yet in the VFS.\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.CommandNotImplementedError\r\nimport venus.terminal.Terminal\r\n\r\nvar tree = Command(\r\n        name = \"tree\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            throw CommandNotImplementedError(\"tree\")\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            throw NotImplementedError()\r\n        }\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSFolder\r\nimport venus.vfs.VFSType\r\nimport venus.zip.Zip\r\n\r\nvar unzip = Command(\r\n        name = \"unzip\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size != 1) {\r\n                return \"unzip: Takes one arg. The file to unzip.\"\r\n            }\r\n            val s = StringBuilder()\r\n            var filename = args.removeAt(0)\r\n            var file = t.vfs.getObjectFromPath(filename) ?: return \"unzip: Could not find the file specified!\"\r\n            if (file.type != VFSType.File) {\r\n                return \"unzip: The specified file is not a file.\"\r\n            }\r\n            val z = Zip()\r\n            z.loadZip(file as VFSFile, t.vfs, t.vfs.currentLocation as VFSFolder)\r\n            return \"VDIRECTIVE:EXEFN...\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 0) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"This command will unzip the file specified into the current directory.\"\r\n)","package venus.terminal.cmds\r\n\r\nimport org.w3c.dom.HTMLInputElement\r\nimport org.w3c.files.File\r\nimport org.w3c.files.FileList\r\nimport org.w3c.files.FileReader\r\nimport org.w3c.files.get\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport kotlin.browser.document\r\nimport kotlin.browser.window\r\n\r\nvar upload = Command(\r\n        name = \"upload\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            val uploadbtn = document.getElementById(\"venus_upload\") as HTMLInputElement\r\n            uploadbtn.click()\r\n            window.setTimeout({ e: HTMLInputElement, t: Terminal -> handleFileUploads(e, t) }, 100, uploadbtn, t)\r\n            return \"\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        }\r\n)\r\n\r\nfun handleFileUploads(e: HTMLInputElement, t: Terminal) {\r\n    if (e.files !== null && (e.files as FileList).length > 0) {\r\n        val files = (e.files as FileList)\r\n        for (i in 0 until files.length) {\r\n            val file = files[i] as File\r\n            setup_reader(file)\r\n        }\r\n        /* This is to clear the upload button of files. */\r\n        e.value = \"\"\r\n        // Need to save the vfs after we upload all the files.\r\n        t.vfs.save()\r\n    } else {\r\n        window.setTimeout({ e: HTMLInputElement, t: Terminal -> handleFileUploads(e, t) }, 100, e, t)\r\n    }\r\n}\r\n\r\nfun setup_reader(file: File) {\r\n    var name = file.name\r\n    var reader = FileReader()\r\n    js(\"\"\"reader.onload = function(e){\r\n            var contents = e.target.result;\r\n            driver.VFS.touch(name);\r\n            driver.VFS.write(name, contents);\r\n        }\"\"\")\r\n    reader.readAsBinaryString(file)\r\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.files\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\n/**\n * Exposes the JavaScript [Blob](https://developer.mozilla.org/en/docs/Web/API/Blob) to Kotlin\n */\npublic external open class Blob(blobParts: Array<dynamic> = definedExternally, options: BlobPropertyBag = definedExternally) : ImageBitmapSource {\n    open val size: Number\n    open val type: String\n    open val isClosed: Boolean\n    fun slice(start: Int = definedExternally, end: Int = definedExternally, contentType: String = definedExternally): Blob\n    fun close()\n}\n\npublic external interface BlobPropertyBag {\n    var type: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun BlobPropertyBag(type: String? = \"\"): BlobPropertyBag {\n    val o = js(\"({})\")\n    o[\"type\"] = type\n    return o\n}\n\n/**\n * Exposes the JavaScript [File](https://developer.mozilla.org/en/docs/Web/API/File) to Kotlin\n */\npublic external open class File(fileBits: Array<dynamic>, fileName: String, options: FilePropertyBag = definedExternally) : Blob {\n    open val name: String\n    open val lastModified: Int\n}\n\npublic external interface FilePropertyBag : BlobPropertyBag {\n    var lastModified: Int?\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun FilePropertyBag(lastModified: Int? = undefined, type: String? = \"\"): FilePropertyBag {\n    val o = js(\"({})\")\n    o[\"lastModified\"] = lastModified\n    o[\"type\"] = type\n    return o\n}\n\n/**\n * Exposes the JavaScript [FileList](https://developer.mozilla.org/en/docs/Web/API/FileList) to Kotlin\n */\npublic external abstract class FileList : ItemArrayLike<File> {\n    override fun item(index: Int): File?\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun FileList.get(index: Int): File? = asDynamic()[index]\n\n/**\n * Exposes the JavaScript [FileReader](https://developer.mozilla.org/en/docs/Web/API/FileReader) to Kotlin\n */\npublic external open class FileReader : EventTarget {\n    open val readyState: Short\n    open val result: dynamic\n    open val error: dynamic\n    var onloadstart: ((ProgressEvent) -> dynamic)?\n    var onprogress: ((ProgressEvent) -> dynamic)?\n    var onload: ((Event) -> dynamic)?\n    var onabort: ((Event) -> dynamic)?\n    var onerror: ((Event) -> dynamic)?\n    var onloadend: ((Event) -> dynamic)?\n    fun readAsArrayBuffer(blob: Blob)\n    fun readAsBinaryString(blob: Blob)\n    fun readAsText(blob: Blob, label: String = definedExternally)\n    fun readAsDataURL(blob: Blob)\n    fun abort()\n\n    companion object {\n        val EMPTY: Short\n        val LOADING: Short\n        val DONE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [FileReaderSync](https://developer.mozilla.org/en/docs/Web/API/FileReaderSync) to Kotlin\n */\npublic external open class FileReaderSync {\n    fun readAsArrayBuffer(blob: Blob): ArrayBuffer\n    fun readAsBinaryString(blob: Blob): String\n    fun readAsText(blob: Blob, label: String = definedExternally): String\n    fun readAsDataURL(blob: Blob): String\n}","package venus.terminal.cmds\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.Assembler\r\nimport venus.Driver\r\nimport venus.Renderer\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSLinkedProgram\r\nimport venus.vfs.VFSProgram\r\nimport venus.vfs.VFSType\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.linker.Linker\r\nimport venusbackend.linker.ProgramAndLibraries\r\nimport venusbackend.riscv.Address\r\nimport venusbackend.riscv.MemSize\r\nimport venusbackend.riscv.Program\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\nvar vdb = Command(\r\n        name = \"vdb\",\r\n        // @TODO Fix how will intemperate files vs args.\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return \"vdb: Takes in at least one File/Program or a single LinkedProgram\"\r\n            }\r\n            val file = args.removeAt(0)\r\n            val linkedprogs = ArrayList<LinkedProgram>()\r\n            val progs = ArrayList<Program>()\r\n            val files = ArrayList<VFSFile>()\r\n//            for (file in fs) {\r\n                val obj = t.vfs.getObjectFromPath(file)\r\n                if (obj == null) {\r\n                    return \"vdb: Could not find file $file\"\r\n                } else {\r\n                    when (obj.type) {\r\n                        VFSType.File -> {\r\n                            files.add(obj as VFSFile)\r\n                        }\r\n                        VFSType.Program -> {\r\n                            progs.add((obj as VFSProgram).getProgram())\r\n                        }\r\n                        VFSType.LinkedProgram -> {\r\n                            if (files.size + progs.size + linkedprogs.size > 0) {\r\n                                return \"vdb: You must either have no linked programs or just one linked program!\"\r\n                            }\r\n                            linkedprogs.add((obj as VFSLinkedProgram).getLinkedProgram())\r\n                        }\r\n                        else -> {\r\n                            return \"vdb: Unsupported type: ${obj.type}\"\r\n                        }\r\n                    }\r\n                }\r\n//            }\r\n            if (files.size + progs.size + linkedprogs.size == 0) {\r\n                return \"vdb: Could not find any of the inputted files!\"\r\n            }\r\n\r\n            // Assembly stage for any files\r\n            var msg = \"\"\r\n            for (file in files) {\r\n                val (prog, errors, warnings) = Assembler.assemble(file.contents.get(VFSFile.innerTxt) as String, file.label, file.getPath())\r\n                if (errors.isNotEmpty()) {\r\n                    msg += \"assemble: Could not assemble file! Here are the errors:\"\r\n                    for (error in errors) {\r\n                        msg += \"\\n\" + error.toString()\r\n                    }\r\n                    return msg\r\n                }\r\n                if (warnings.isNotEmpty()) {\r\n                    msg += \"assemble: Assembled file with a few warnings:\"\r\n                    for (warning in warnings) {\r\n                        msg += \"\\n\" + warning.toString()\r\n                    }\r\n                }\r\n                progs.add(prog)\r\n            }\r\n\r\n            // Linking Stage for any programs\r\n            if (progs.size > 0) {\r\n                val PandL = try {\r\n                    ProgramAndLibraries(progs, t.vfs)\r\n                } catch (e: AssemblerError) {\r\n                    return \"vdb: An error occurred when getting the imports: $e\"\r\n                }\r\n                val linkedProgram: LinkedProgram\r\n                try {\r\n                    linkedProgram = Linker.link(PandL)\r\n                } catch (e: Throwable) {\r\n                    return \"vdb: An error occurred when running the linked program: $e\"\r\n                }\r\n                linkedprogs.add(linkedProgram)\r\n            }\r\n\r\n            // Getting the LinkedProgram which we want to simulate\r\n            if (linkedprogs.size != 1) {\r\n                return msg + \"vdb: There must only be one linked program!\"\r\n            }\r\n            val lp = linkedprogs[0]\r\n            try {\r\n                Driver.loadSim(lp)\r\n                Driver.sim.addArg(args)\r\n                Renderer.loadSimulator(Driver.sim)\r\n                Driver.setCacheSettings()\r\n                Renderer.updateCache(Address(0, MemSize.WORD))\r\n                Driver.openSimulator()\r\n            } catch (e: Throwable) {\r\n                console.error(e)\r\n                return \"vdb: An error has occurred\"\r\n            }\r\n            return \"\"\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 0) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        }\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.Renderer\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSFile\r\n\r\n@ExperimentalStdlibApi\r\nvar xxd = Command(\r\n        name = \"xxd\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 1) {\r\n                return Command[\"xxd\"].help\r\n            }\r\n            var result = \"\"\r\n            val charchunk = 2\r\n            val charsperline = 16\r\n            var f = t.vfs.getObjectFromPath(args[0]) ?: return \"xxd: could not find the file!\"\r\n            if (f is VFSFile) {\r\n                val text = f.readText()\r\n                var i = 0\r\n                var curline = \"\"\r\n                if (text.length > 0) {\r\n                    result += Renderer.toHex(0, add_prefix = false) + \":\"\r\n                }\r\n                for (chr: Char in text.toCharArray()) {\r\n                    if (curline.length == charsperline) {\r\n                        result += \"  $curline\\n\"\r\n                        result += Renderer.toHex(i, add_prefix = false) + \":\"\r\n                        curline = \"\"\r\n                    }\r\n                    if (curline.length % charchunk == 0) {\r\n                        result += \" \"\r\n                    }\r\n                    val cv = chr.toInt()\r\n                    result += Renderer.toHex(cv, 2, false)\r\n                    curline += when (cv) {\r\n                        !in 32..126 -> \".\"\r\n                        else -> chr.toString()\r\n                    }\r\n                    i++\r\n                }\r\n                if (curline.length > 0) {\r\n                    var charsLeft = charsperline - curline.length\r\n                    if (charsLeft % 2 == 1) {\r\n                        charsLeft--\r\n                        result += \"  \"\r\n                    }\r\n                    charsLeft /= 2\r\n                    for (j in 0 until charsLeft) {\r\n                        result += \"     \"\r\n                    }\r\n                    result += \"  $curline\"\r\n                }\r\n            } else {\r\n                result = \"xxd: only works on files!\"\r\n            }\r\n            return result\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 0) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"\"\"Takes a file and prints it out in hex.\r\n            |Usage: xxd file\r\n            |NOTE: This is a very dumb xxd and does not have full features.\r\n        \"\"\".trimMargin()\r\n)","package venus.terminal.cmds\r\n\r\nimport venus.terminal.Command\r\nimport venus.terminal.Terminal\r\nimport venus.vfs.VFSDummy\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSFolder\r\nimport venus.vfs.VFSType\r\nimport venus.zip.Zip\r\n\r\nvar zip = Command(\r\n        name = \"zip\",\r\n        execute = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): String {\r\n            if (args.size < 2) {\r\n                return \"zip: Takes at least two arguments, the zip file name and the file you want to add to the zip.\"\r\n            }\r\n            val s = StringBuilder()\r\n            var output = args.removeAt(0)\r\n            val z = Zip()\r\n            for (fname in args) {\r\n                val f = t.vfs.getObjectFromPath(fname) ?: VFSDummy()\r\n                if (f.type == VFSType.File) {\r\n                    z.addFile(fname, (f as VFSFile).readText())\r\n                } else if (f.type == VFSType.Folder) {\r\n                    z.addFolder((f as VFSFolder))\r\n                } else {\r\n                    s.append(\"'$fname' is not a path to a file! For now, this function only accepts files.\\n\")\r\n                }\r\n            }\r\n\r\n            z.save(output)\r\n            return s.toString()\r\n        },\r\n        tab = fun(args: MutableList<String>, t: Terminal, sudo: Boolean): ArrayList<Any> {\r\n            if (args.size > 1) {\r\n                val prefix = args[args.size - 1]\r\n                return arrayListOf(prefix, t.vfs.filesFromPrefix(prefix))\r\n            }\r\n            return arrayListOf(\"\", ArrayList<String>())\r\n        },\r\n        help = \"This command creates a zip file.\"\r\n)","package venus.terminal\r\n\r\nopen class Command(\r\n    val name: String,\r\n    val execute: (parsedInput: MutableList<String>, t: Terminal, sudo: Boolean) -> String =\r\n            { a, b, c -> throw NotImplementedError() },\r\n    val tab: (parsedInput: MutableList<String>, t: Terminal, sudo: Boolean) -> MutableList<Any> =\r\n            { a, b, c -> throw NotImplementedError() },\r\n    val help: String = \"Command does not have a help yet!\"\r\n) {\r\n    companion object {\r\n        private val allCommands = arrayListOf<Command>()\r\n\r\n        fun getCommands(): ArrayList<String> {\r\n            val cmds = ArrayList<String>()\r\n            for (cmd in allCommands) {\r\n                cmds.add(cmd.name)\r\n            }\r\n            return cmds\r\n        }\r\n\r\n        operator fun get(name: String) =\r\n                allCommands.firstOrNull { it.name == name }\r\n                        ?: throw CommandNotFoundError(name)\r\n    }\r\n\r\n    init {\r\n        allCommands.add(this)\r\n    }\r\n\r\n    override fun toString() = name\r\n}","package venus.terminal\r\n\r\nclass CommandNotFoundError : Throwable {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n\r\n    constructor(command: String? = null) : super(command + \": command not found\")\r\n}","package venus.terminal\r\n\r\nclass CommandNotImplementedError : Throwable {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n\r\n    constructor(command: String? = null) : super(command + \": command found but not implemented yet!\")\r\n}","package venus.terminal\r\n\r\nimport venus.vfs.VFSDummy\r\nimport venus.vfs.VFSType\r\nimport venusbackend.assembler.Lexer\r\nimport venus.vfs.VirtualFileSystem\r\n\r\nclass Terminal(var vfs: VirtualFileSystem) {\r\n\r\n    @JsName(\"processInput\") fun processInput(input: String): String {\r\n        try {\r\n            val args = this.extractArgs(input)\r\n            var sudo = if (args[0].toLowerCase() === \"sudo\") {\r\n                args.removeAt(0)\r\n                true\r\n            } else {\r\n                false\r\n            }\r\n            val prog = if (args.size > 0) {\r\n                args[0]\r\n            } else {\r\n                \"\"\r\n            }\r\n            try {\r\n                val cmd = Command[args.removeAt(0)]\r\n                return cmd.execute(args, this, sudo)\r\n            } catch (e: CommandNotFoundError) {\r\n                val obj = vfs.getObjectFromPath(prog) ?: VFSDummy()\r\n                if (obj.type in listOf(VFSType.File, VFSType.LinkedProgram, VFSType.Program)) {\r\n                    val r = Command[venus.terminal.cmds.run.name]\r\n                    args.add(0, prog)\r\n                    return r.execute(args, this, sudo)\r\n                }\r\n                return e.message ?: \": command not found\"\r\n            }\r\n        } catch (e: Throwable) {\r\n            console.error(e)\r\n            return \"Unknown error occurred: \" + e.toString()\r\n        }\r\n    }\r\n\r\n    fun extractArgs(input: String): ArrayList<String> {\r\n        return Lexer.lex(input) as ArrayList<String>\r\n    }\r\n\r\n    @JsName(\"getCommands\") fun getCommands() {\r\n        js(\"var cmds = []\")\r\n        var ktcmds = Command.getCommands()\r\n        for (c in ktcmds) {\r\n            js(\"cmds.push(c)\")\r\n        }\r\n        return js(\"cmds\")\r\n    }\r\n\r\n    private val externalCommands = listOf(\"clear\", \"clock\", \"date\", \"exit\", \"help\", \"uname\", \"sudo\")\r\n\r\n    @JsName(\"tab\") fun tab(lineinput: String): Any? {\r\n        val ktcmds = Command.getCommands().union(externalCommands)\r\n        val args = this.extractArgs(lineinput)\r\n        try {\r\n            if (args.isNotEmpty()) {\r\n                val sudo = if (args[0] === \"sudo\") {\r\n                    args.removeAt(0)\r\n                    true\r\n                } else {\r\n                    false\r\n                }\r\n                if (args.isEmpty()) {\r\n                    return js(\"[];\")\r\n                }\r\n                if (args.size == 1) {\r\n                    val possibleCommands = ArrayList<String>()\r\n                    val prefix = args[0]\r\n                    for (c in ktcmds) {\r\n                        if (c.startsWith(prefix)) {\r\n                            possibleCommands.add(c)\r\n                        }\r\n                    }\r\n                    return listTojsList(listOf(prefix, listTojsList(possibleCommands)))\r\n                } else {\r\n                    val cmd = Command[args.removeAt(0)]\r\n                    val options = cmd.tab(args, this, sudo)\r\n                    return listTojsList(listOf(options[0], listTojsList(options[1] as List<Any?>)))\r\n                }\r\n            }\r\n        } catch (e: Throwable) {\r\n            console.error(e)\r\n            return \"An error occurred! $e\"\r\n        }\r\n        return \"Something bad happened!\"\r\n    }\r\n\r\n    fun listTojsList(l: List<Any?>): Any? {\r\n        js(\"var list = [];\")\r\n        for (i in l) {\r\n            js(\"list.push(i);\")\r\n        }\r\n        return js(\"list;\")\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n@ExperimentalStdlibApi\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","package venus.vfs\r\n\r\nclass JsonContainer {\r\n    var type = \"Dummy\"\r\n    var label = \"DUMMY\"\r\n    var contents = ArrayList<JsonContainer>()\r\n    var permissions = VFSPermissions()\r\n    var innerobj: Any = \"\"\r\n}","package venus.vfs\r\n\r\nclass VFSDrive(val n: String, override var parent: VFSObject) : VFSFolder(n, parent) {\r\n    override val type = VFSType.Drive\r\n    init {\r\n        this.contents[\"..\"] = this\r\n    }\r\n\r\n    companion object {\r\n        fun inflate(jsonContainer: JsonContainer, parent: VFSObject): VFSObject {\r\n            val folder = VFSDrive(jsonContainer.label, parent)\r\n            for (i in 0 until js(\"jsonContainer.contents.length\")) {\r\n                val value = js(\"jsonContainer.contents[i]\")\r\n                var addchild = true\r\n                val obj = when (value.type) {\r\n                    VFSType.Folder.toString() -> {\r\n                        VFSFolder.inflate(value, folder)\r\n                    }\r\n                    VFSType.Program.toString() -> {\r\n                        addchild = false\r\n                        VFSProgram.inflate(value, folder)\r\n                    }\r\n                    VFSType.LinkedProgram.toString() -> {\r\n                        addchild = false\r\n                        VFSLinkedProgram.inflate(value, folder)\r\n                    }\r\n                    VFSType.File.toString() -> {\r\n                        VFSFile.inflate(value, folder)\r\n                    }\r\n                    VFSType.Drive.toString() -> {\r\n                        inflate(value, folder)\r\n                    }\r\n                    else -> {\r\n                        VFSDummy()\r\n                    }\r\n                }\r\n                if (addchild) {\r\n                    folder.addChild(obj)\r\n                }\r\n            }\r\n            return folder\r\n        }\r\n    }\r\n}","package venus.vfs\r\n\r\n/**\r\n * This class is meant to just be a dummy class to allow for VFS init.\r\n */\r\nclass VFSDummy() : VFSObject {\r\n    override val type = VFSType.Dummy\r\n    override var label = \"DUMMY\"\r\n    override var contents = HashMap<String, Any>()\r\n    override var permissions = VFSPermissions()\r\n    override lateinit var parent: VFSObject\r\n}","package venus.vfs\r\n\r\nclass VFSFile(override var label: String, override var parent: VFSObject) : VFSObject {\r\n    override val type = VFSType.File\r\n    override var contents = HashMap<String, Any>()\r\n    override var permissions = VFSPermissions()\r\n    companion object {\r\n        val innerTxt = \"innertext\"\r\n        fun inflate(jsonContainer: JsonContainer, parent: VFSObject): VFSObject {\r\n            val file = VFSFile(jsonContainer.label, parent)\r\n            file.setText(jsonContainer.innerobj as String)\r\n            return file\r\n        }\r\n    }\r\n    init {\r\n        contents[innerTxt] = \"\"\r\n    }\r\n    fun readText(): String {\r\n        return contents[innerTxt] as String\r\n    }\r\n    @JsName(\"setText\") fun setText(s: String) {\r\n        contents[innerTxt] = s\r\n    }\r\n\r\n    override fun stringify(): JsonContainer {\r\n        val me = JsonContainer()\r\n        me.label = this.label\r\n        me.permissions = this.permissions\r\n        me.type = this.type.toString()\r\n        me.innerobj = this.contents[innerTxt] as String\r\n        return me\r\n    }\r\n}","package venus.vfs\r\n\r\nimport venus.vfs.VFSObject.Companion.isValidName\r\n\r\nopen class VFSFolder(var name: String, override var parent: VFSObject) : VFSObject {\r\n    override val type = VFSType.Folder\r\n    override var label = name\r\n    override var contents = HashMap<String, Any>()\r\n    override var permissions = VFSPermissions()\r\n    init {\r\n        contents[\"..\"] = parent\r\n        contents[\".\"] = this\r\n    }\r\n    fun addFile(name: String): Boolean {\r\n        if (isValidName(name) && !contents.containsKey(name)) {\r\n            contents[name] = VFSFile(name, this)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n    fun addFolder(name: String): Boolean {\r\n        if (isValidName(name) && !contents.containsKey(name)) {\r\n            contents[name] = VFSFolder(name, this)\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    override fun stringify(): JsonContainer {\r\n        val me = JsonContainer()\r\n        me.label = this.label\r\n        me.permissions = this.permissions\r\n        me.type = this.type.toString()\r\n        for (item in this.contents.keys) {\r\n            if (item !in listOf(\".\", \"..\")) {\r\n                me.contents.add((this.contents[item] as VFSObject).stringify())\r\n            }\r\n        }\r\n        return me\r\n    }\r\n\r\n    companion object {\r\n        fun inflate(jsonContainer: JsonContainer, parent: VFSObject): VFSObject {\r\n            val folder = VFSFolder(jsonContainer.label, parent)\r\n            for (i in 0 until js(\"jsonContainer.contents.length\")) {\r\n                val value = js(\"jsonContainer.contents[i]\")\r\n                var addchild = true\r\n                val obj = when (value.type) {\r\n                    VFSType.Folder.toString() -> {\r\n                        inflate(value, folder)\r\n                    }\r\n                    VFSType.Program.toString() -> {\r\n                        addchild = false\r\n                        VFSProgram.inflate(value, folder)\r\n                    }\r\n                    VFSType.LinkedProgram.toString() -> {\r\n                        addchild = false\r\n                        VFSLinkedProgram.inflate(value, folder)\r\n                    }\r\n                    VFSType.File.toString() -> {\r\n                        VFSFile.inflate(value, folder)\r\n                    }\r\n                    VFSType.Drive.toString() -> {\r\n                        VFSDrive.inflate(value, folder)\r\n                    }\r\n                    else -> {\r\n                        VFSDummy()\r\n                    }\r\n                }\r\n                if (addchild) {\r\n                    folder.addChild(obj)\r\n                }\r\n            }\r\n            return folder\r\n        }\r\n    }\r\n}\r\n","package venus.vfs\r\n\r\nimport venusbackend.linker.LinkedProgram\r\n\r\nclass VFSLinkedProgram(override var label: String, override var parent: VFSObject, prog: LinkedProgram = LinkedProgram()) : VFSObject {\r\n    override val type = VFSType.LinkedProgram\r\n    override var contents = HashMap<String, Any>()\r\n    override var permissions = VFSPermissions()\r\n    companion object {\r\n        val innerProgram = \"innerprogram\"\r\n        fun inflate(jsonContainer: JsonContainer, parent: VFSObject): VFSObject {\r\n            val file = VFSLinkedProgram(jsonContainer.label, parent)\r\n            // file.setLinkedProgram(jsonContainer.innerobj as LinkedProgram)\r\n            return file\r\n        }\r\n    }\r\n    init {\r\n        contents[innerProgram] = prog\r\n    }\r\n    fun getLinkedProgram(): LinkedProgram {\r\n        return contents[innerProgram] as LinkedProgram\r\n    }\r\n    fun setLinkedProgram(p: LinkedProgram) {\r\n        contents[innerProgram] = p\r\n    }\r\n\r\n    override fun stringify(): JsonContainer {\r\n        val me = JsonContainer()\r\n        me.label = this.label\r\n        me.permissions = this.permissions\r\n        me.type = this.type.toString()\r\n        me.innerobj = this.contents[VFSProgram.innerProgram] as Any\r\n        return me\r\n    }\r\n}","package venus.vfs\r\n\r\ninterface VFSObject {\r\n    val type: VFSType\r\n    var label: String\r\n    var contents: HashMap<String, Any>\r\n    var permissions: VFSPermissions\r\n    var parent: VFSObject\r\n    companion object {\r\n        fun isValidName(name: String): Boolean {\r\n            return !name.contains(Regex(\"[\" + separator + \":\\\"><]\"))\r\n        }\r\n        const val separator = \"/\"\r\n    }\r\n\r\n    fun getPath(): String {\r\n        var path = \"\"\r\n        var node: VFSObject? = this\r\n        while (node != null && node.type != VFSType.Drive) {\r\n            path = separator + node.label + path\r\n            node = node.parent\r\n        }\r\n        return (path)\r\n    }\r\n\r\n    fun addChild(child: VFSObject): Boolean {\r\n        if (this.contents.containsKey(child.label) || !isValidName(child.label)) {\r\n            return false\r\n        } else {\r\n            this.contents.put(child.label, child)\r\n            return true\r\n        }\r\n    }\r\n\r\n    fun removeChild(name: String): Boolean {\r\n        if (!contents.containsKey(name) || name == \"\" || name == \"\") {\r\n            return false\r\n        }\r\n        contents.remove(name)\r\n        return true\r\n    }\r\n    fun stringify(): JsonContainer {\r\n        val me = JsonContainer()\r\n        me.label = this.label\r\n        me.permissions = this.permissions\r\n        me.type = this.type.toString()\r\n        return me\r\n    }\r\n}","package venus.vfs\r\n\r\nclass VFSPermissions {\r\n    var write = true\r\n    var read = true\r\n    var execute = true\r\n    init {\r\n        //\r\n    }\r\n}","package venus.vfs\r\n\r\nimport venusbackend.riscv.Program\r\n\r\nclass VFSProgram(override var label: String, override var parent: VFSObject, prog: Program = Program(absPath = \"\")) : VFSObject {\r\n    override val type = VFSType.Program\r\n    override var contents = HashMap<String, Any>()\r\n    override var permissions = VFSPermissions()\r\n    companion object {\r\n        val innerProgram = \"innerprogram\"\r\n        fun inflate(jsonContainer: JsonContainer, parent: VFSObject): VFSObject {\r\n            val file = VFSProgram(jsonContainer.label, parent)\r\n            // file.setProgram(jsonContainer.innerobj as Program)\r\n            return file\r\n        }\r\n    }\r\n    init {\r\n        contents[innerProgram] = prog\r\n    }\r\n    fun getProgram(): Program {\r\n        return contents[innerProgram] as Program\r\n    }\r\n    fun setProgram(p: Program) {\r\n        contents[innerProgram] = p\r\n    }\r\n\r\n    override fun stringify(): JsonContainer {\r\n        val me = JsonContainer()\r\n        me.label = this.label\r\n        me.permissions = this.permissions\r\n        me.type = this.type.toString()\r\n        me.innerobj = this.contents[innerProgram] as Any\r\n        return me\r\n    }\r\n}","package venus.vfs\r\n\r\nenum class VFSType {\r\n    Drive,\r\n    Folder,\r\n    File,\r\n    Program,\r\n    LinkedProgram,\r\n    Dummy\r\n}","package venus.vfs\r\n\r\nimport venus.Driver\r\nimport venusbackend.simulator.SimulatorSettings\r\nimport kotlin.browser.window\r\n\r\n@JsName(\"VirtualFileSystem\") class VirtualFileSystem(val defaultDriveName: String, val simSettings: SimulatorSettings = SimulatorSettings()) {\r\n    var sentinel = VFSDrive(defaultDriveName, VFSDummy())\r\n    var currentLocation: VFSObject = sentinel\r\n\r\n    companion object {\r\n        val LSName = \"VFS_DATA\"\r\n\r\n        fun getPath(path: String): ArrayList<String> {\r\n            return path.split(VFSObject.separator) as ArrayList\r\n        }\r\n    }\r\n\r\n    init {\r\n        sentinel.parent = sentinel\r\n    }\r\n\r\n    fun makeFileInDir(path: String): VFSFile? {\r\n        val obj = getObjectFromPath(path)\r\n        if (obj == null) {\r\n            val nobj = getObjectFromPath(path, true) as VFSObject\r\n            return if (nobj.type != VFSType.File) {\r\n                val name = nobj.label\r\n                val parent = nobj.parent\r\n                parent.removeChild(name)\r\n                val newfile = VFSFile(name, parent)\r\n                parent.addChild(newfile)\r\n                newfile\r\n            } else {\r\n                nobj as VFSFile\r\n            }\r\n        } else {\r\n            if (obj.type == VFSType.File) {\r\n                return obj as VFSFile\r\n            }\r\n            return null\r\n        }\r\n    }\r\n\r\n    @JsName(\"reset\") fun reset() {\r\n        this.currentLocation = sentinel\r\n    }\r\n\r\n    @JsName(\"mkdir\") fun mkdir(dirName: String): String {\r\n        val newdir = VFSFolder(dirName, currentLocation)\r\n        return if (currentLocation.addChild(newdir)) {\r\n            \"\"\r\n        } else {\r\n            \"Could not make directory: $dirName\"\r\n        }\r\n    }\r\n\r\n    @JsName(\"cd\") fun cd(dir: String): String {\r\n        var tmp = chdir(dir, currentLocation)\r\n        if (tmp is VFSObject) {\r\n            if (tmp.type !in listOf(VFSType.Folder, VFSType.Drive)) {\r\n                return \"Can only go into folders and drives.\"\r\n            }\r\n            currentLocation = tmp\r\n        } else {\r\n            return tmp.toString()\r\n        }\r\n        return \"\"\r\n    }\r\n\r\n    fun chdir(dir: String, curloc: VFSObject): Any {\r\n        val splitpath = getPath(dir)\r\n        var templocation = if (dir.startsWith(\"/\") || dir == \"\") {\r\n            if (splitpath.size > 0) {\r\n                splitpath.removeAt(0)\r\n            }\r\n            sentinel\r\n        } else {\r\n            curloc\r\n        }\r\n        for (dir in splitpath) {\r\n            if (dir == \"\") {\r\n                continue\r\n            }\r\n            if (!templocation.contents.containsKey(dir)) {\r\n                return \"cd: $dir: No such file or directory\"\r\n            }\r\n            templocation = templocation.contents.get(dir) as VFSObject\r\n            if (templocation.type in listOf(VFSType.File, VFSType.Program)) {\r\n                return \"cd: $dir: Not a directory\"\r\n            }\r\n        }\r\n        return templocation\r\n    }\r\n\r\n    @JsName(\"touch\") fun touch(filename: String): String {\r\n        val newfile = VFSFile(filename, currentLocation)\r\n        return if (currentLocation.addChild(newfile)) {\r\n            \"\"\r\n        } else {\r\n            \"Could not make file: $filename\"\r\n        }\r\n    }\r\n\r\n    @JsName(\"ls\") fun ls(): String {\r\n        var str = \"\"\r\n        for (s in currentLocation.contents.keys) {\r\n            str += s + (if ((currentLocation.contents[s] as VFSObject).type in listOf(VFSType.Folder, VFSType.Drive)) VFSObject.separator else \"\") + \"\\n\"\r\n        }\r\n        return str\r\n    }\r\n\r\n    @JsName(\"cat\") fun cat(filedir: String): String {\r\n        val splitpath = getPath(filedir)\r\n        var templocation = if (filedir.startsWith(\"/\")) {\r\n            splitpath.removeAt(0)\r\n            sentinel\r\n        } else {\r\n            currentLocation\r\n        }\r\n        for (obj in splitpath) {\r\n            if (obj == \"\") {\r\n                continue\r\n            }\r\n            if (!templocation.contents.containsKey(obj)) {\r\n                return \"cat: $filedir: No such file or directory\"\r\n            }\r\n            templocation = templocation.contents[obj] as VFSObject\r\n        }\r\n        if (templocation.type != VFSType.File) {\r\n            return \"cat: $filedir: Is not a file!\"\r\n        }\r\n        if (!templocation.contents.containsKey(VFSFile.innerTxt)) {\r\n            return \"cat: $filedir: COULD NOT FIND FILE CONTENTS!\"\r\n        }\r\n        return templocation.contents.get(VFSFile.innerTxt) as String\r\n    }\r\n\r\n    @JsName(\"path\") fun path(): String {\r\n        return currentLocation.getPath() + VFSObject.separator\r\n    }\r\n    // @FIXME There is a bug for going into a file\r\n    @JsName(\"remove\") fun remove(path: String): String {\r\n        return rm(path, currentLocation)\r\n    }\r\n\r\n    fun rm(path: String, curloc: VFSObject): String {\r\n        val templocation = this.getObjectFromPath(path)\r\n        if (templocation === null) {\r\n            return \"rm: cannot remove '$path': No such file or directory\"\r\n        }\r\n        if (curloc.getPath().contains(templocation.getPath())) {\r\n            return \"rm: cannot remove '$path': Path is currently active\"\r\n        }\r\n        val p = templocation.parent\r\n\r\n        return (if (p.removeChild(templocation.label)) \"\" else \"rm: could not remove file\")\r\n    }\r\n\r\n    @JsName(\"write\") fun write(path: String, msg: String): String {\r\n        val splitpath = getPath(path)\r\n        var templocation = if (splitpath.size > 0 && splitpath[0] == sentinel.label) {\r\n            splitpath.removeAt(0)\r\n            sentinel\r\n        } else {\r\n            currentLocation\r\n        }\r\n        for (obj in splitpath) {\r\n            if (obj == \"\") {\r\n                continue\r\n            }\r\n            if (!templocation.contents.containsKey(obj)) {\r\n                return \"write: cannot write to '$path': No such file or directory\"\r\n            }\r\n            templocation = templocation.contents[obj] as VFSObject\r\n        }\r\n        if (templocation.type != VFSType.File) {\r\n            return \"cat: $path: Is not a file!\"\r\n        }\r\n        (templocation as VFSFile).setText(msg)\r\n        return \"\"\r\n    }\r\n\r\n    @JsName(\"addFile\") fun addFile(path: String, data: String, loc: VFSObject = currentLocation): String {\r\n        val splitpath = getPath(path)\r\n        if (splitpath.size == 0) {\r\n            return \"There was no file passed in!\"\r\n        }\r\n        val fname = splitpath.removeAt(splitpath.size - 1)\r\n        var curloc = loc\r\n        for (p in splitpath) {\r\n            curloc = if (curloc.contents.containsKey(p)) {\r\n                val next = curloc.contents[p]!! as VFSObject\r\n                if (next.type !in listOf(VFSType.Folder, VFSType.Drive)) {\r\n                    return \"Could not create folder due to a non folder existing in the path.\"\r\n                }\r\n                next\r\n            } else {\r\n                val fold = VFSFolder(p, curloc)\r\n                curloc.addChild(fold)\r\n                fold\r\n            }\r\n        }\r\n        val f = VFSFile(fname, curloc)\r\n        f.setText(data)\r\n        curloc.addChild(f)\r\n        return \"\"\r\n    }\r\n\r\n    fun getParentFromObject(obj: VFSObject): VFSObject? {\r\n        return obj.parent\r\n    }\r\n\r\n    fun getObjectFromPath(path: String, make: Boolean = false, location: VFSObject? = null): VFSObject? {\r\n        val splitpath = getPath(path)\r\n        var templocation = if (path.startsWith(\"/\")) {\r\n            splitpath.removeAt(0)\r\n            sentinel\r\n        } else {\r\n            location ?: currentLocation\r\n        }\r\n        for (obj in splitpath) {\r\n            if (obj == \"\") {\r\n                continue\r\n            }\r\n            if (!templocation.contents.containsKey(obj)) {\r\n                if (make) {\r\n                    templocation.addChild(VFSFile(obj, templocation))\r\n                } else {\r\n                    return null\r\n                }\r\n            }\r\n            templocation = templocation.contents[obj] as VFSObject\r\n        }\r\n        return templocation\r\n    }\r\n\r\n    fun filesFromPrefix(prefix: String): ArrayList<String> {\r\n        val fnames = ArrayList<String>()\r\n        for (key: String in this.currentLocation.contents.keys) {\r\n            if (key.startsWith(prefix)) {\r\n                val obj = this.currentLocation.contents[key] as VFSObject\r\n                var k = key\r\n                if (obj.type in listOf(VFSType.Folder, VFSType.Drive)) {\r\n                    k += \"/\"\r\n                }\r\n                fnames.add(k)\r\n            }\r\n        }\r\n        return fnames\r\n    }\r\n\r\n    fun stringify(): String {\r\n        return JSON.stringify(sentinel.stringify())\r\n    }\r\n\r\n    fun parse(vfsString: String) {\r\n        val raw = JSON.parse<JsonContainer>(vfsString)\r\n        val temp = VFSDrive.inflate(raw, VFSDummy())\r\n        val newsent = temp as VFSDrive\r\n        newsent.parent = newsent\r\n        this.sentinel = newsent\r\n        this.currentLocation = this.sentinel\r\n    }\r\n\r\n    fun load() {\r\n        val vfsJSON = window.localStorage.getItem(LSName)\r\n        if (vfsJSON != undefined) {\r\n            this.parse(vfsJSON)\r\n        }\r\n    }\r\n\r\n    fun save() {\r\n        if (Driver.useLS) {\r\n            val vfsJSON = this.stringify()\r\n            window.localStorage.setItem(LSName, vfsJSON)\r\n        }\r\n    }\r\n}","package venus.zip\r\n\r\nimport venus.vfs.VFSFolder\r\nimport venus.vfs.VFSObject\r\nimport venus.vfs.VFSType\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VirtualFileSystem\r\n\r\nclass Zip {\r\n    var internal_zip = JSZip()\r\n    fun addFile(name: String, data: Any) {\r\n        this.addFileHelper(name, data, internal_zip)\r\n    }\r\n\r\n    private fun addFileHelper(name: String, data: Any, int_zip: JSZip) {\r\n        int_zip.file(name, data, js(\"\"\"{\"binary\":true}\"\"\"))\r\n    }\r\n\r\n    fun save(name: String): String {\r\n        val z = internal_zip\r\n        js(\"\"\"\r\n           z.generateAsync({\"type\": \"blob\"}).then(function(data){\r\n            saveAs(data, name);\r\n           });\r\n        \"\"\")\r\n        return \"\"\r\n    }\r\n\r\n    fun addFolder(folder: VFSFolder) {\r\n        val newf = internal_zip.folder(folder.name)\r\n        this.addFolderHelper(folder, newf)\r\n    }\r\n\r\n    private fun addFolderHelper(folder: VFSFolder, int_zip: JSZip) {\r\n        for (s in folder.contents.keys) {\r\n            if (s !in listOf(\".\", \"..\")) {\r\n                val type = (folder.contents[s] as VFSObject).type\r\n                if (type == VFSType.File) {\r\n                    val file = folder.contents[s] as VFSFile\r\n                    this.addFileHelper(file.label, file.readText(), int_zip)\r\n                } else if (type == VFSType.Folder) {\r\n                    val fold = folder.contents[s] as VFSFolder\r\n                    val newf = int_zip.folder(fold.name)\r\n                    this.addFolderHelper(fold, newf)\r\n                } else {\r\n                    console.error(\"Currently, we only support zipping files and folders!\")\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fun loadZip(zipfile: VFSFile, vfs: VirtualFileSystem, folder: VFSFolder) {\r\n        val content = zipfile.readText()\r\n        js(\"\"\"\r\n            var new_zip = new JSZip();\r\n            window.VENUSLOADZIPCOUNTER = 0;\r\n            new_zip.loadAsync(content).then(function(zip) {\r\n                // you now have every files contained in the loaded zip\r\n                new_zip.forEach(function (relativePath, file){\r\n                    if (!relativePath.endsWith(\"/\")) {\r\n                        window.VENUSLOADZIPCOUNTER++;\r\n                        file.async(\"uint8array\").then(function (data) {\r\n                            var result = \"\";\r\n                              for (var i = 0; i < data.length; i++) {\r\n                                result += String.fromCharCode(data[i]);\r\n                              }\r\n                          var out = vfs.addFile(relativePath, result, folder);\r\n                            if (out != \"\") {\r\n                                window.VENUSFNOUTPUT += out + \"\\n\";\r\n                            }\r\n                            window.VENUSLOADZIPCOUNTER--;\r\n                        });\r\n                    }\r\n                });\r\n                function timeoutcheck() {\r\n                    if (window.VENUSLOADZIPCOUNTER == 0) {\r\n                        window.VENUSFNDONE = true;\r\n                    } else {\r\n                        setTimeout(timeoutcheck, 25);\r\n                    }\r\n                }\r\n                timeoutcheck();\r\n            });\r\n        \"\"\")\r\n    }\r\n}\r\n\r\nexternal class JSZip {\r\n    companion object {\r\n        val version: String\r\n    }\r\n    fun file(name: String): JSZip\r\n    fun file(name: String, data: Any, options: Any): JSZip\r\n    fun folder(name: String): JSZip\r\n    fun remove(name: String): JSZip\r\n}","package venusbackend.assembler\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.riscv.InitInstructions\r\nimport venusbackend.assembler.pseudos.checkArgsLength\r\nimport venus.Renderer\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.InstructionNotFoundError\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.getImmWarning\r\nimport venusbackend.riscv.insts.dsl.relocators.Relocator\r\nimport venusbackend.simulator.SimulatorError\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n/**\r\n * This singleton implements a simple two-pass assembler to transform files into programs.\r\n */\r\nobject Assembler {\r\n    val defaultDefines: MutableMap<String, String> = HashMap()\r\n    /**\r\n     * Assembles the given code into an unlinked Program.\r\n     *\r\n     * @param text the code to assemble.\r\n     * @return an unlinked program.\r\n     * @see venus.linker.Linker\r\n     * @see venus.simulator.Simulator\r\n     */\r\n    fun assemble(text: String, name: String = \"main.S\", abspath: String = \"\"): AssemblerOutput {\r\n        InitInstructions() // This is due to how some method of compilation handle all of the code.\r\n        var (passOneProg, talInstructions, passOneErrors, warnings) = AssemblerPassOne(text.replace(\"\\r\", \"\"), name, abspath).run()\r\n\r\n        /* This will force pc to be word aligned. Removed it because I guess you could custom it.\r\n        if (passOneProg.insts.size > 0) {\r\n            val l = passOneProg.insts[0].length\r\n            if (MemorySegments.TEXT_BEGIN % l != 0) {\r\n                /*This will align the pc so we do not have invalid stuffs.*/\r\n                MemorySegments.setTextBegin(MemorySegments.TEXT_BEGIN - (MemorySegments.TEXT_BEGIN % l))\r\n            }\r\n        }*/\r\n\r\n        if (passOneErrors.isNotEmpty()) {\r\n            return AssemblerOutput(passOneProg, passOneErrors, ArrayList<AssemblerWarning>())\r\n        }\r\n        var passTwoOutput = AssemblerPassTwo(passOneProg, talInstructions).run()\r\n        if (passTwoOutput.prog.textSize + MemorySegments.TEXT_BEGIN > MemorySegments.STATIC_BEGIN) {\r\n            try {\r\n                MemorySegments.setTextBegin(MemorySegments.STATIC_BEGIN - passOneProg.textSize)\r\n                Renderer.updateText()\r\n                val pone = AssemblerPassOne(text, name, abspath).run()\r\n                passOneProg = pone.prog\r\n                passOneErrors = pone.errors\r\n                talInstructions = pone.talInstructions\r\n                if (passOneErrors.isNotEmpty()) {\r\n                    return AssemblerOutput(passOneProg, passOneErrors, ArrayList<AssemblerWarning>())\r\n                }\r\n                passTwoOutput = AssemblerPassTwo(passOneProg, talInstructions).run()\r\n            } catch (e: SimulatorError) {\r\n                throw SimulatorError(\"Could not change the text size so could not fit the program because the static is too low and the text would be below zero!\")\r\n            }\r\n        }\r\n        if (warnings.isNotEmpty()) {\r\n            val arr = passTwoOutput.warnings.toMutableList()\r\n            arr.addAll(warnings)\r\n            passTwoOutput = AssemblerOutput(passTwoOutput.prog, passTwoOutput.errors, arr)\r\n        }\r\n        return passTwoOutput\r\n    }\r\n}\r\n\r\ndata class DebugInfo(val lineNo: Int, val line: String, val address: Int, val prog: Program)\r\ndata class DebugInstruction(val debug: DebugInfo, val LineTokens: List<String>)\r\ndata class PassOneOutput(\r\n    val prog: Program,\r\n    val talInstructions: List<DebugInstruction>,\r\n    val errors: List<AssemblerError>,\r\n    val warnings: List<AssemblerWarning>\r\n)\r\ndata class AssemblerOutput(val prog: Program, val errors: List<AssemblerError>, val warnings: List<AssemblerWarning>)\r\n\r\n/**\r\n * Pass #1 of our two pass assembler.\r\n *\r\n * It parses labels, expands pseudo-instructions and follows assembler directives.\r\n * It populations [talInstructions], which is then used by [AssemblerPassTwo] in order to actually assemble the code.\r\n */\r\nval p1warnings = ArrayList<AssemblerWarning>()\r\ninternal class AssemblerPassOne(private val text: String, name: String = \"anonymous\", abspath: String) {\r\n    /** The program we are currently assembling */\r\n    private val prog = Program(name, abspath)\r\n    /** The text offset where the next instruction will be written */\r\n    private var currentTextOffset = 0 // MemorySegments.TEXT_BEGIN\r\n    /** The data offset where more data will be written */\r\n    private var currentDataOffset = MemorySegments.STATIC_BEGIN\r\n    /** The allows user to set custom memory segments until the assembler has used an offset. */\r\n    private var allow_custom_memory_segments = true\r\n    /** Whether or not we are currently in the text segment */\r\n    private var inTextSegment = true\r\n    /** TAL Instructions which will be added to the program */\r\n    private val talInstructions = ArrayList<DebugInstruction>()\r\n    /** The current line number (for user-friendly errors) */\r\n    private var currentLineNumber = 0\r\n    /** List of all errors encountered */\r\n    private val errors = ArrayList<AssemblerError>()\r\n    private val warnings = ArrayList<AssemblerWarning>()\r\n    /** Preprocessor defines */\r\n    private val defines = HashMap<String, String>(Assembler.defaultDefines)\r\n\r\n    fun run(): PassOneOutput {\r\n        doPassOne()\r\n        return PassOneOutput(prog, talInstructions, errors, warnings)\r\n    }\r\n\r\n    private fun doPassOne() {\r\n        for (line in text.lines()) {\r\n            try {\r\n                currentLineNumber++\r\n                val dbg = DebugInfo(currentLineNumber, line, currentTextOffset, prog)\r\n\r\n                val offset = getOffset()\r\n\r\n                var pline = line\r\n                defines.forEach { (token: String, value: String) ->\r\n                    val splitline = pline.split(Regex(\"\\\\s\")).toMutableList()\r\n                    val tokens = ArrayList<String>()\r\n                    var diff = false\r\n                    for (v in splitline) {\r\n                        if (v == token) {\r\n                            tokens.add(value)\r\n                            diff = true\r\n                        } else {\r\n                            tokens.add(v)\r\n                        }\r\n                    }\r\n                    if (diff) {\r\n                        pline = tokens.joinToString(\" \")\r\n                    }\r\n                }\r\n\r\n                preprocess(line, dbg)\r\n\r\n                val (labels, args) = Lexer.lexLine(pline, dbg)\r\n                for (label in labels) {\r\n                    allow_custom_memory_segments = false\r\n                    val oldOffset = prog.addLabel(label, offset)\r\n                    if (oldOffset != null) {\r\n                        throw AssemblerError(\"label $label defined twice\", dbg)\r\n                    }\r\n                }\r\n\r\n                if (args.isEmpty() || args[0].isEmpty()) continue // empty line\r\n\r\n                if (isAssemblerDirective(args[0])) {\r\n                    parseAssemblerDirective(args[0], args.drop(1), pline, dbg)\r\n                } else {\r\n                    allow_custom_memory_segments = false\r\n                    val expandedInsts = replacePseudoInstructions(args, dbg)\r\n                    for (inst in expandedInsts) {\r\n//                        val dbg = DebugInfo(currentLineNumber, line, currentTextOffset, prog)\r\n                        val instsize = try {\r\n                            Instruction[getInstruction(inst), dbg].format.length\r\n                        } catch (e: AssemblerError) {\r\n                            4\r\n                        }\r\n                        talInstructions.add(DebugInstruction(dbg, inst))\r\n                        currentTextOffset += instsize\r\n                    }\r\n                }\r\n                for (p1warning in p1warnings) {\r\n                    p1warning.line = currentLineNumber\r\n                }\r\n                warnings.addAll(p1warnings)\r\n                p1warnings.clear()\r\n            } catch (e: AssemblerError) {\r\n                errors.add(AssemblerError(currentLineNumber, e))\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun preprocess(line: String, dbg: DebugInfo) {\r\n        val DIRECTIVE_DEFINE = \"define\"\r\n        val DIRECTIVE_UNDEF = \"undef\"\r\n        var pline = line.trim()\r\n        if (pline.startsWith(\"#\")) {\r\n            pline = pline.removePrefix(\"#\").trim()\r\n            if (pline.startsWith(DIRECTIVE_DEFINE)) {\r\n                pline = pline.removePrefix(DIRECTIVE_DEFINE).trim()\r\n                val tokens = pline.split(\" \").toMutableList()\r\n                defines[tokens.removeAt(0)] = tokens.joinToString(\" \")\r\n            }\r\n            if (pline.startsWith(DIRECTIVE_UNDEF)) {\r\n                pline = pline.removePrefix(DIRECTIVE_UNDEF).trim()\r\n                val tokens = pline.split(\" \")\r\n                checkArgsLength(tokens, 1, dbg)\r\n                defines.remove(tokens[0])\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Gets the current offset (either text or data) depending on where we are writing */\r\n    fun getOffset() = if (inTextSegment) currentTextOffset else currentDataOffset\r\n\r\n    /**\r\n     * Determines if the given token is an assembler directive\r\n     *\r\n     * @param cmd the token to check\r\n     * @return true if the token is an assembler directive\r\n     * @see parseAssemblerDirective\r\n     */\r\n    private fun isAssemblerDirective(cmd: String) = cmd.startsWith(\".\")\r\n\r\n    /**\r\n     * Replaces any pseudoinstructions which occur in our program.\r\n     *\r\n     * @param tokens a list of strings corresponding to the space delimited line\r\n     * @return the corresponding TAL instructions (possibly unchanged)\r\n     */\r\n    private fun replacePseudoInstructions(tokens: LineTokens, dbg: DebugInfo): List<LineTokens> {\r\n        try {\r\n            val cmd = getInstruction(tokens)\r\n            // This is meant to allow for cmds with periods since the pseudodispatcher does not allow for special chars.\r\n            val cleanedCMD = cmd.replace(\".\", \"\")\r\n            val pw = PseudoDispatcher.valueOf(cleanedCMD).pw\r\n            return pw(tokens, this, dbg)\r\n        } catch (t: Throwable) {\r\n            /* TODO: don't use throwable here */\r\n            /* not a pseudoinstruction, or expansion failure */\r\n            val linetokens = parsePossibleMachineCode(tokens, dbg)\r\n            return linetokens\r\n        }\r\n    }\r\n\r\n    private fun parsePossibleMachineCode(tokens: LineTokens, dbg: DebugInfo): List<LineTokens> {\r\n        val c = getInstruction(tokens)\r\n        if (c in listOf(\"beq\", \"bge\", \"bgeu\", \"blt\", \"bltu\", \"bne\")) {\r\n            try {\r\n                val loc = getOffset() + userStringToInt(tokens[3])\r\n                prog.addLabel(venusInternalLabels + loc.toString(), loc)\r\n//                warnings.add(AssemblerWarning(\"Interpreting label as immediate\"))\r\n//                return listOf(listOf(tokens[0], tokens[1], tokens[2], \"L\" + loc.toString()))\r\n            } catch (e: Throwable) {\r\n                //\r\n            }\r\n        } else if (c == \"jal\") {\r\n            try {\r\n                val loc = getOffset() + userStringToInt(tokens[2])\r\n                prog.addLabel(venusInternalLabels + loc.toString(), loc)\r\n//                warnings.add(AssemblerWarning(\"Interpreting label as immediate\"))\r\n//                return listOf(listOf(tokens[0], tokens[1], \"L\" + loc.toString()))\r\n            } catch (e: Throwable) {\r\n                //\r\n            }\r\n        } else {\r\n            try {\r\n                var cmd = userStringToInt(c)\r\n                try {\r\n                    val decoded = Instruction[MachineCode(cmd)].disasm(MachineCode(cmd))\r\n                    val lex = Lexer.lexLine(decoded, dbg).second.toMutableList()\r\n                    if (lex[0] == \"jal\") {\r\n                        val loc = getOffset() + lex[2].toInt()\r\n                        prog.addLabel(\"L$loc\", loc)\r\n                        lex[2] = \"L$loc\"\r\n                    }\r\n                    if (lex[0] in listOf(\"beq\", \"bge\", \"bgeu\", \"blt\", \"bltu\", \"bne\")) {\r\n                        val loc = getOffset() + lex[3].toInt()\r\n                        prog.addLabel(\"L$loc\", loc)\r\n                        lex[3] = \"L$loc\"\r\n                    }\r\n                    val t = listOf(lex)\r\n                    return t\r\n                } catch (e: SimulatorError) {\r\n                    errors.add(AssemblerError(currentLineNumber, e))\r\n                }\r\n            } catch (e: NumberFormatException) {\r\n                if (c.startsWith(\"0x\") || c.startsWith(\"0b\") || c.matches(Regex(\"\\\\d+\"))) {\r\n                    errors.add(AssemblerError(currentLineNumber, e))\r\n                }\r\n            }\r\n        }\r\n        return listOf(tokens)\r\n    }\r\n\r\n    /**\r\n     * Changes the assembler state in response to directives\r\n     *\r\n     * @param directive the assembler directive, starting with a \".\"\r\n     * @param args any arguments following the directive\r\n     * @param line the original line (which is needed for some directives)\r\n     */\r\n    private fun parseAssemblerDirective(directive: String, args: LineTokens, line: String, dbg: DebugInfo) {\r\n        when (directive) {\r\n            \".data\" -> inTextSegment = false\r\n            \".text\" -> {\r\n                inTextSegment = true\r\n            }\r\n\r\n            \".register_size\" -> {\r\n                if (!allow_custom_memory_segments) {\r\n                    throw AssemblerError(\"\"\"You can only set the register size address BEFORE any labels or\r\n                        |instructions have been processed\"\"\".trimMargin(), dbg)\r\n                }\r\n                try {\r\n                    checkArgsLength(args, 1, dbg)\r\n                } catch (e: AssemblerError) {\r\n                    throw AssemblerError(\"$directive takes in zero or one argument(s) to specify encoding!\", dbg)\r\n                }\r\n                val instwidth = userStringToInt(args[0])\r\n                if (!listOf(16, 32, 64, 128).contains(instwidth)) {\r\n                    throw AssemblerError(\"Unknown instruction size!\", dbg)\r\n                }\r\n                Renderer.displayWarning(\"Will set width to $instwidth!\")\r\n            }\r\n\r\n            \".data_start\" -> {\r\n                if (!allow_custom_memory_segments) {\r\n                    throw AssemblerError(\"\"\"You can only set the data start address BEFORE any labels or\r\n                        |instructions have been processed\"\"\".trimMargin(), dbg)\r\n                }\r\n                checkArgsLength(args, 1, dbg)\r\n                val location = userStringToInt(args[0])\r\n                MemorySegments.STATIC_BEGIN = location\r\n            }\r\n\r\n            \".byte\" -> {\r\n                for (arg in args) {\r\n                    val byte = userStringToInt(arg)\r\n                    if (byte !in -127..255) {\r\n                        throw AssemblerError(\"invalid byte $byte too big\", dbg)\r\n                    }\r\n                    prog.addToData(byte.toByte())\r\n                    currentDataOffset++\r\n                }\r\n            }\r\n\r\n            \".string\", \".asciiz\" -> {\r\n                checkArgsLength(args, 1, dbg)\r\n                val ascii: String = try {\r\n                    val str = args[0]\r\n                    if (str.length < 2 || str[0] != str[str.length - 1] || str[0] != '\"') {\r\n                        throw IllegalArgumentException()\r\n                    }\r\n                    unescapeString(str.drop(1).dropLast(1))\r\n                } catch (e: Throwable) {\r\n                    throw AssemblerError(\"couldn't parse ${args[0]} as a string\", dbg)\r\n                }\r\n                for (c in ascii) {\r\n                    if (c.toInt() !in 0..127) {\r\n                        throw AssemblerError(\"unexpected non-ascii character: '$c'\", dbg)\r\n                    }\r\n                    prog.addToData(c.toByte())\r\n                    currentDataOffset++\r\n                }\r\n\r\n                /* Add NUL terminator */\r\n                prog.addToData(0)\r\n                currentDataOffset++\r\n            }\r\n\r\n            \".half\" -> {\r\n                for (arg in args) {\r\n                    try {\r\n                        val word = userStringToInt(arg)\r\n                        prog.addToData(word.toByte())\r\n                        prog.addToData((word shr 8).toByte())\r\n                    } catch (e: NumberFormatException) {\r\n                        /* arg is not a number; interpret as label */\r\n                        prog.addDataRelocation(\r\n                                prog.symbolPart(arg, dbg),\r\n                                prog.labelOffsetPart(arg, dbg),\r\n                                currentDataOffset - MemorySegments.STATIC_BEGIN,\r\n                                dbg)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                    }\r\n                    currentDataOffset += 2\r\n                }\r\n            }\r\n\r\n            \".word\" -> {\r\n                for (arg in args) {\r\n                    try {\r\n                        val word = userStringToInt(arg)\r\n                        prog.addToData(word.toByte())\r\n                        prog.addToData((word shr 8).toByte())\r\n                        prog.addToData((word shr 16).toByte())\r\n                        prog.addToData((word shr 24).toByte())\r\n                    } catch (e: NumberFormatException) {\r\n                        /* arg is not a number; interpret as label */\r\n                        prog.addDataRelocation(\r\n                                prog.symbolPart(arg, dbg),\r\n                                prog.labelOffsetPart(arg, dbg),\r\n                                currentDataOffset - MemorySegments.STATIC_BEGIN,\r\n                                dbg)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                    }\r\n                    currentDataOffset += 4\r\n                }\r\n            }\r\n\r\n            \".globl\", \"global\" -> {\r\n                args.forEach(prog::makeLabelGlobal)\r\n            }\r\n\r\n            \".import\" -> {\r\n                checkArgsLength(args, 1, dbg)\r\n                var filepath = args[0]\r\n                val relative = !filepath.startsWith(\"<\")\r\n                if (filepath.matches(Regex(\"\\\".*\\\"|'.*'|<.*>\"))) {\r\n                    filepath = filepath.slice(1..(filepath.length - 2))\r\n                }\r\n                prog.addImport(filepath, relative)\r\n            }\r\n\r\n            \".space\" -> {\r\n                checkArgsLength(args, 1, dbg)\r\n                try {\r\n                    val reps = userStringToInt(args[0])\r\n                    for (c in 1..reps) {\r\n                        prog.addToData(0)\r\n                    }\r\n                    currentDataOffset += reps\r\n                } catch (e: NumberFormatException) {\r\n                    throw AssemblerError(\"${args[0]} not a valid argument\", dbg)\r\n                }\r\n            }\r\n\r\n            \".align\" -> {\r\n                checkArgsLength(args, 1, dbg)\r\n                val pow2 = userStringToInt(args[0])\r\n                if (pow2 < 0 || pow2 > 8) {\r\n                    throw AssemblerError(\".align argument must be between 0 and 8, inclusive\", dbg)\r\n                }\r\n                val mask = (1 shl pow2) - 1 // Sets pow2 rightmost bits to 1\r\n                /* Add padding until data offset aligns with given power of 2 */\r\n                while ((currentDataOffset and mask) != 0) {\r\n                    prog.addToData(0)\r\n                    currentDataOffset++\r\n                }\r\n            }\r\n\r\n            \".equiv\", \".equ\", \".set\" -> {\r\n                checkArgsLength(args, 2, dbg)\r\n                val oldDefn = prog.addEqu(args[0], args[1])\r\n                if (directive == \".equiv\" && oldDefn != null) {\r\n                    throw AssemblerError(\"attempt to redefine ${args[0]}\", dbg)\r\n                }\r\n            }\r\n\r\n            \".float\" -> {\r\n                for (arg in args) {\r\n                    try {\r\n                        val float = userStringToFloat(arg)\r\n                        val bits = float.toRawBits()\r\n                        prog.addToData(bits.toByte())\r\n                        prog.addToData((bits shr 8).toByte())\r\n                        prog.addToData((bits shr 16).toByte())\r\n                        prog.addToData((bits shr 24).toByte())\r\n                    } catch (e: NumberFormatException) {\r\n                        /* arg is not a number; interpret as label */\r\n                        prog.addDataRelocation(arg, currentDataOffset - MemorySegments.STATIC_BEGIN,\r\n                                dbg = dbg)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                    }\r\n                    currentDataOffset += 4\r\n                }\r\n            }\r\n\r\n            \".double\" -> {\r\n                for (arg in args) {\r\n                    try {\r\n                        val double = userStringToDouble(arg)\r\n                        val bits = double.toRawBits()\r\n                        prog.addToData(bits.toByte())\r\n                        prog.addToData((bits shr 8).toByte())\r\n                        prog.addToData((bits shr 16).toByte())\r\n                        prog.addToData((bits shr 24).toByte())\r\n                        prog.addToData((bits shr 32).toByte())\r\n                        prog.addToData((bits shr 40).toByte())\r\n                        prog.addToData((bits shr 48).toByte())\r\n                        prog.addToData((bits shr 56).toByte())\r\n                    } catch (e: NumberFormatException) {\r\n                        /* arg is not a number; interpret as label */\r\n                        prog.addDataRelocation(arg, currentDataOffset - MemorySegments.STATIC_BEGIN,\r\n                                dbg = dbg)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                        prog.addToData(0)\r\n                    }\r\n                    currentDataOffset += 8\r\n                }\r\n            }\r\n\r\n            else -> throw AssemblerError(\"unknown assembler directive $directive\", dbg)\r\n        }\r\n    }\r\n\r\n    fun addRelocation(relocator: Relocator, offset: Int, label: String, dbg: DebugInfo) =\r\n            prog.addRelocation(\r\n                    relocator, prog.symbolPart(label, dbg),\r\n                    prog.labelOffsetPart(label, dbg), offset, dbg)\r\n}\r\n\r\n/**\r\n * Pass #2 of our two pass assembler.\r\n *\r\n * It writes TAL instructions to the program, and also adds debug info to the program.\r\n * @see addInstruction\r\n * @see venus.riscv.Program.addDebugInfo\r\n */\r\n\r\ninternal class AssemblerPassTwo(val prog: Program, val talInstructions: List<DebugInstruction>) {\r\n    private val errors = ArrayList<AssemblerError>()\r\n    private val warnings = ArrayList<AssemblerWarning>()\r\n    fun run(): AssemblerOutput {\r\n        resolveEquivs(prog)\r\n        for ((dbg, inst) in talInstructions) {\r\n            try {\r\n                addInstruction(inst, dbg)\r\n                prog.addDebugInfo(dbg)\r\n                if (getImmWarning != \"\") {\r\n                    val (lineNumber, _) = dbg\r\n                    warnings.add(AssemblerWarning(lineNumber, AssemblerWarning(getImmWarning)))\r\n                    getImmWarning = \"\"\r\n                }\r\n            } catch (e: AssemblerError) {\r\n                val (lineNumber, _) = dbg\r\n                if (e.errorType is InstructionNotFoundError) {\r\n                    val cmd = getInstruction(inst)\r\n                    // This is meant to allow for cmds with periods since the pseudodispatcher does not allow for special chars.\r\n                    val cleanedCMD = cmd.replace(\".\", \"\")\r\n                    val pw = try {\r\n                        PseudoDispatcher.valueOf(cleanedCMD).pw\r\n                    } catch (_: Throwable) {\r\n                        errors.add(AssemblerError(lineNumber, e))\r\n                        continue\r\n                    }\r\n                    try {\r\n                        pw(inst, AssemblerPassOne(\"\", abspath = \"\"), dbg)\r\n                        errors.add(AssemblerError(lineNumber, e))\r\n                    } catch (pe: Throwable) {\r\n                        errors.add(AssemblerError(lineNumber, pe))\r\n                    }\r\n                } else {\r\n                    errors.add(AssemblerError(lineNumber, e))\r\n                }\r\n            }\r\n        }\r\n        return AssemblerOutput(prog, errors, warnings)\r\n    }\r\n\r\n    /**\r\n     * Adds machine code corresponding to our instruction to the program.\r\n     *\r\n     * @param tokens a list of strings corresponding to the space delimited line\r\n     */\r\n    private fun addInstruction(tokens: LineTokens, dbg: DebugInfo) {\r\n        if (tokens.isEmpty() || tokens[0].isEmpty()) return\r\n        val cmd = getInstruction(tokens)\r\n        val inst = Instruction[cmd, dbg]\r\n        val mcode = inst.format.fill()\r\n        inst.parser(prog, mcode, tokens.drop(1), dbg)\r\n        prog.add(mcode)\r\n    }\r\n\r\n    /** Resolve all labels in PROG defined by .equiv, .equ, or .set and add\r\n     *  these to PROG as ordinary labels.  Checks for duplicate or\r\n     *  conflicting definition. */\r\n    private fun resolveEquivs(prog: Program) {\r\n        val conflicts = prog.labels.keys.intersect(prog.equivs.keys)\r\n        if (conflicts.isNotEmpty()) {\r\n            throw AssemblerError(\"conflicting definitions for $conflicts\")\r\n        }\r\n        val processing = HashSet<String>()\r\n        for (equiv in prog.equivs.keys) {\r\n            if (equiv !in prog.labels.keys) {\r\n                prog.labels[equiv] = findDefn(equiv, prog, processing)\r\n            }\r\n        }\r\n    }\r\n    /** Return the ultimate definition of SYM, an .equ-defined symbol, in\r\n     *  PROG, assuming that if SYM is in ACTIVE, it is part of a\r\n     *  circular chain of definitions. */\r\n    private fun findDefn(sym: String, prog: Program, active: HashSet<String>): Int {\r\n        // FIXME: Global symbols not defined in this program.\r\n        if (sym in active) {\r\n            throw AssemblerError(\"circularity in definition of $sym\")\r\n        }\r\n        val value = prog.equivs[sym]!!\r\n        if (isNumeral(value)) {\r\n            return userStringToInt(value)\r\n        } else if (value in prog.labels.keys) {\r\n            return prog.labels[value]!!\r\n        } else if (value in prog.equivs.keys) {\r\n            active.add(sym)\r\n            val result = findDefn(value, prog, active)\r\n            active.remove(sym)\r\n            return result\r\n        } else {\r\n            throw AssemblerError(\"undefined symbol: $value\")\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the instruction from a line of code\r\n *\r\n * @param tokens the tokens from the current line\r\n * @return the instruction (aka the first argument, in lowercase)\r\n */\r\nprivate fun getInstruction(tokens: LineTokens) = tokens[0].toLowerCase()","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxBy(selector)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWith(comparator)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minBy(selector)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWith(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","package venusbackend.assembler\r\n\r\n/**\r\n * Thrown when errors occur during assembly.\r\n *\r\n * @todo split this into AssemblerUserError and AssemblerError\r\n */\r\nclass AssemblerError : Throwable {\r\n    companion object {\r\n        fun parse_msg(msg: String? = null, dbg: DebugInfo? = null): String? {\r\n            val s = msg ?: return msg\r\n            val dbg = dbg ?: return msg\r\n            return \"${dbg.prog.name}:${dbg.lineNo}: $msg\\n${dbg.line.trim()}\"\r\n        }\r\n    }\r\n    var line: Int? = null\r\n    var errorType: Throwable? = null\r\n\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null, dbg: DebugInfo? = null) : super(parse_msg(msg, dbg))\r\n\r\n    /**\r\n     * @param errorLine the line the error occurred on\r\n     * @param e the original error to pass along\r\n     */\r\n    constructor(errorLine: Int, e: Throwable) : this(e.message) {\r\n        line = errorLine\r\n    }\r\n\r\n    constructor(msg: String? = null, errorType: Throwable, dbg: DebugInfo? = null) : this(msg, dbg) {\r\n        this.errorType = errorType\r\n    }\r\n\r\n    override fun toString(): String {\r\n        return super.toString()\r\n//        if (line == null) return super.toString()\r\n//        else return \"${super.toString()} on line $line\"\r\n    }\r\n}\r\n","package venusbackend.assembler\r\n\r\n/**\r\n * Thrown when errors occur during assembly.\r\n *\r\n */\r\nclass AssemblerWarning : Throwable {\r\n    var line: Int? = null\r\n\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n\r\n    /**\r\n     * @param errorLine the line the error occurred on\r\n     * @param e the original error to pass along\r\n     */\r\n    constructor(errorLine: Int, e: Throwable) : this(e.message) {\r\n        line = errorLine\r\n    }\r\n\r\n    override fun toString(): String {\r\n        if (line == null) return super.toString()\r\n        else return \"${super.toString()} on line $line\"\r\n    }\r\n}\r\n","package venusbackend.assembler\r\n\r\ntypealias LineTokens = List<String>\r\n\r\n/**\r\n * A singleton which can be used to lex a given line.\r\n */\r\nobject Lexer {\r\n    private val charPatn = \"\"\"'(?:\\\\.|[^\\\\'])'\"\"\"\r\n    private val strPatn = \"\\\"(?:\\\\\\\\.|[^\\\\\\\\\\\"\\\"])*?\\\"\"\r\n    private val otherTokenPatn = \"\"\"[^:() \\t,#\"\"']+\"\"\"\r\n    private val tokenPatn = \"($charPatn|$strPatn|$otherTokenPatn)\"\r\n    private val labelPatn = \"($otherTokenPatn)\\\\s*:\"\r\n    private val baseRegPatn = \"\"\"\\(\\s*($otherTokenPatn)\\s*\\)\"\"\"\r\n    private val tokenRE =\r\n            Regex(\"\"\"(#.*)|$labelPatn|$tokenPatn|$baseRegPatn|(['\"\"])\"\"\")\r\n\r\n    fun lexLine(line: String, dbg: DebugInfo? = null): Pair<LineTokens, LineTokens> {\r\n        val labels = ArrayList<String>()\r\n        val insnTokens = ArrayList<String>()\r\n\r\n        for (mat in tokenRE.findAll(line)) {\r\n            val groups = mat.groups\r\n            when {\r\n                groups[1] != null -> Unit\r\n                groups[2] != null && !insnTokens.isEmpty() -> {\r\n                    throw AssemblerError(\"label ${groups[2]!!.value} in the middle of an instruction\", dbg)\r\n                }\r\n                groups[2] != null -> labels.add(groups[2]!!.value)\r\n                groups[3] != null -> insnTokens.add(groups[3]!!.value)\r\n                groups[4] != null -> {\r\n                    insnTokens.add(\"(\" + groups[4]!!.value + \")\")\r\n                }\r\n                else -> throw AssemblerError(\"unclosed string\", dbg)\r\n            }\r\n        }\r\n        return Pair(labels, insnTokens)\r\n    }\r\n\r\n    private fun addNonemptyWord(previous: ArrayList<String>, next: StringBuilder) {\r\n        val word = next.toString()\r\n        if (word.isNotEmpty()) {\r\n            previous += word\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lex a line into a label (if there) and a list of arguments.\r\n     *\r\n     * @param line the line to lex\r\n     * @return a pair containing the label and tokens\r\n     * @see LineTokens\r\n     */\r\n//    fun lexLine(line: String): Pair<LineTokens, LineTokens> {\r\n//        var currentWord = StringBuilder(\"\")\r\n//        val previousWords = ArrayList<String>()\r\n//        val labels = ArrayList<String>()\r\n//        var escaped = false\r\n//        var inCharacter = false\r\n//        var inString = false\r\n//        var foundComment = false\r\n//        var inParen = 0\r\n//\r\n//        for (ch in line) {\r\n//            var wasDelimiter = false\r\n//            var wasLabel = false\r\n//            when (ch) {\r\n//                '#' -> foundComment = !inString && !inCharacter\r\n//                '\\'' -> inCharacter = !(escaped xor inCharacter) && !inString\r\n//                '\"' -> inString = !(escaped xor inString) && !inCharacter\r\n//                ':' -> {\r\n//                    if (!inString && !inCharacter) {\r\n//                        wasLabel = true\r\n//                        if (previousWords.isNotEmpty()) {\r\n//                            throw AssemblerError(\"label $currentWord in the middle of an instruction\")\r\n//                        }\r\n//                    }\r\n//                }\r\n//                '(' -> {\r\n//                    inParen++\r\n//                    wasDelimiter = !inString && !inCharacter\r\n//                }\r\n//                ')' -> {\r\n//                    if (inParen == 0) {\r\n//                        throw AssemblerError(\"Cannot end a parentheses sequence which has not started yet.\")\r\n//                    }\r\n//                    inParen--\r\n//                    wasDelimiter = !inString && !inCharacter\r\n//                }\r\n//                ' ', '\\t', ',' -> wasDelimiter = !inString && !inCharacter\r\n//            }\r\n//            escaped = !escaped && ch == '\\\\'\r\n//\r\n//            if (foundComment) break\r\n//\r\n//            if (wasDelimiter) {\r\n//                addNonemptyWord(previousWords, currentWord)\r\n//                currentWord = StringBuilder(\"\")\r\n//            } else if (wasLabel) {\r\n//                addNonemptyWord(labels, currentWord)\r\n//                currentWord = StringBuilder(\"\")\r\n//            } else {\r\n//                currentWord.append(ch)\r\n//            }\r\n//        }\r\n//        if (inParen > 0) {\r\n//            throw AssemblerError(\"Mismatched number of parentheses!\")\r\n//        }\r\n//        addNonemptyWord(previousWords, currentWord)\r\n//\r\n//        return Pair(labels, previousWords)\r\n//    }\r\n    /**\r\n     * Lex a line into a label (if there) and a list of arguments.\r\n     *\r\n     * @param line the line to lex\r\n     * @return tokens\r\n     * @see LineTokens\r\n     */\r\n    fun lex(line: String): LineTokens {\r\n        var currentWord = StringBuilder(\"\")\r\n        val previousWords = ArrayList<String>()\r\n        var escaped = false\r\n        var inCharacter = false\r\n        var inString = false\r\n\r\n        for (ch in line) {\r\n            var wasDelimiter = false\r\n            when (ch) {\r\n                '\\'' -> inCharacter = !(escaped xor inCharacter) && !inString\r\n                '\"' -> inString = !(escaped xor inString) && !inCharacter\r\n                ' ' -> wasDelimiter = !inString && !inCharacter\r\n//                ' ', '\\t', '(', ')', ',' -> wasDelimiter = !inString && !inCharacter\r\n            }\r\n            escaped = !escaped && ch == '\\\\'\r\n\r\n            if (wasDelimiter) {\r\n                val l = currentWord.length\r\n                if (l > 2 && (currentWord[0].toString() in listOf(\"'\", \"\\\"\") && currentWord[l - 1] == currentWord[0])) {\r\n                    val cs = currentWord.subSequence(1, l - 1)\r\n                    currentWord = StringBuilder(cs)\r\n                }\r\n                addNonemptyWord(previousWords, currentWord)\r\n                currentWord = StringBuilder(\"\")\r\n            } else if (escaped) {} else {\r\n                currentWord.append(ch)\r\n            }\r\n        }\r\n        val l = currentWord.length\r\n        if (l > 2 && (currentWord[0].toString() in listOf(\"'\", \"\\\"\") && currentWord[l - 1] == currentWord[0])) {\r\n            val cs = currentWord.subSequence(1, l - 1)\r\n            currentWord = StringBuilder(cs)\r\n        }\r\n        addNonemptyWord(previousWords, currentWord)\r\n\r\n        return previousWords\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","package venusbackend.assembler\r\n\r\ndata class LintError(val lineNumber: Int, val message: String, val isError: Boolean = true)\r\n\r\n/**\r\n * Linter for RISC-V code\r\n *\r\n * At the moment this implemented by just running the venusbackend.assembler outright, unless the text is too long.\r\n * A more intelligent approach would run the linter on each line incrementally.\r\n */\r\nobject Linter {\r\n    /**\r\n     * Lints the given text, which is expected to be an entire assembly file\r\n     *\r\n     * @param text the text to lint\r\n     * @fixme this relies on Kotlin using JS array for Array, but it will probably remain that way\r\n     */\r\n    fun lint(text: String): Array<LintError> {\r\n        val (_, errors, warnings) = Assembler.assemble(text, abspath = \"\")\r\n        val linterErrors = ArrayList<LintError>()\r\n        for (error in errors) {\r\n            linterErrors.add(LintError(error.line ?: -1, error.message ?: \"\"))\r\n        }\r\n        for (warning in warnings) {\r\n            linterErrors.add(LintError(warning.line ?: -1, warning.message ?: \"\", false))\r\n        }\r\n        return linterErrors.toTypedArray()\r\n    }\r\n}\r\n","package venusbackend.assembler\r\n\r\nimport venusbackend.assembler.pseudos.* // ktlint-disable no-wildcard-imports\r\n\r\n/** Describes each instruction for writing */\r\nenum class PseudoDispatcher(val pw: PseudoWriter) {\r\n    beqz(BEQZ),\r\n    bgez(BGEZ),\r\n    bgt(BGT),\r\n    bgtu(BGTU),\r\n    bgtz(BGTZ),\r\n    ble(BLE),\r\n    bleu(BLEU),\r\n    blez(BLEZ),\r\n    bltz(BLTZ),\r\n    bnez(BNEZ),\r\n    call(CALL),\r\n    jal(JAL),\r\n    jalr(JALR),\r\n    j(J),\r\n    jr(JR),\r\n    la(LA),\r\n    lb(Load),\r\n    lbu(Load),\r\n    lh(Load),\r\n    lhu(Load),\r\n    li(LI),\r\n    lw(Load),\r\n    ld(Load),\r\n    mv(MV),\r\n    neg(NEG),\r\n    negw(NEGW),\r\n    nop(NOP),\r\n    not(NOT),\r\n    ret(RET),\r\n    sb(Store),\r\n    sextw(SEXTW),\r\n    seqz(SEQZ),\r\n    sgtz(SGTZ),\r\n    sh(Store),\r\n    sltz(SLTZ),\r\n    snez(SNEZ),\r\n    sw(Store),\r\n    sd(Store),\r\n    tail(TAIL),\r\n    /* nonstandard */\r\n    seq(SEQ),\r\n    sge(SGE),\r\n    sgeu(SGE),\r\n    sgt(SGT),\r\n    sgtu(SGT),\r\n    sle(SLE),\r\n    sleu(SLE),\r\n    sne(SNE),\r\n    fmvs(FMVS),\r\n    fabss(FABSS),\r\n    fnegs(FNEGS),\r\n    fmvd(FMVD),\r\n    fabsd(FABSD),\r\n    fnegd(FNEGD),\r\n    flw(Load),\r\n    fld(Load),\r\n    fsw(Store),\r\n    fsd(Store)\r\n    ;\r\n}\r\n","package venusbackend.assembler\r\n\r\n/**\r\n * Thrown when errors occur during assembly.\r\n *\r\n * @todo split this into AssemblerUserError and AssemblerError\r\n */\r\nclass PseudoDispatcherError : Throwable {\r\n    var line: Int? = null\r\n\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n\r\n    /**\r\n     * @param errorLine the line the error occurred on\r\n     * @param e the original error to pass along\r\n     */\r\n    constructor(errorLine: Int, e: Throwable) : this(e.message) {\r\n        line = errorLine\r\n    }\r\n\r\n    override fun toString(): String {\r\n        if (line == null) return super.toString()\r\n        else return \"${super.toString()} on line $line\"\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `beqz rs, label` */\r\nobject BEQZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"beq\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bgez rs, label` */\r\nobject BGEZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"bge\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bgt rs, rt, label` */\r\nobject BGT : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        return listOf(listOf(\"blt\", args[2], args[1], args[3]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bgtu rs, rt, label` */\r\nobject BGTU : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        return listOf(listOf(\"bltu\", args[2], args[1], args[3]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bgtz rs, label` */\r\nobject BGTZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"blt\", \"x0\", args[1], args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `ble rs, rt, label` */\r\nobject BLE : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        return listOf(listOf(\"bge\", args[2], args[1], args[3]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bleu rs, rt, label` */\r\nobject BLEU : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        return listOf(listOf(\"bgeu\", args[2], args[1], args[3]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `blez rs, label` */\r\nobject BLEZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"bge\", \"x0\", args[1], args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bltz rs, label` */\r\nobject BLTZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"blt\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `bnez rs, label` */\r\nobject BNEZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"bne\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelHiRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelLoRelocator\r\n\r\n/**\r\n * Writes pseudoinstruction `call label`.\r\n */\r\nobject CALL : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n\r\n        val auipc = listOf(\"auipc\", \"x6\", \"0\")\r\n        state.addRelocation(PCRelHiRelocator, state.getOffset(), args[1], dbg)\r\n\r\n        val jalr = listOf(\"jalr\", \"x1\", \"x6\", \"0\")\r\n        state.addRelocation(PCRelLoRelocator, state.getOffset() + 4, args[1], dbg)\r\n\r\n        return listOf(auipc, jalr)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fabs.d rd, rs` */\r\nobject FABSD : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fabs.d\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnjx.d\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fabs.s rd, rs` */\r\nobject FABSS : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fabs.s\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnjx.s\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fmv.d rd, rs` */\r\nobject FMVD : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fmv.d\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnj.d\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fmv.s rd, rs` */\r\nobject FMVS : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fmv.s\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnj.s\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fneg.d rd, rs` */\r\nobject FNEGD : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fmv.d\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnjn.d\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `fmv.s rd, rs` */\r\nobject FNEGS : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"fneg.s\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"fsgnjn.s\", args[1], args[2], args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `j label` */\r\nobject J : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n        return listOf(listOf(\"jal\", \"x0\", args[1]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `venusbackend.venusbackend.riscv.insts.integer.base.getJal label` */\r\nobject JAL : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n        return listOf(listOf(\"jal\", \"x1\", args[1]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `jalr reg` */\r\nobject JALR : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n        return listOf(listOf(\"jalr\", \"x1\", args[1], \"0\"))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `jr register` */\r\nobject JR : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n        return listOf(listOf(\"jalr\", \"x0\", args[1], \"0\"))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelHiRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelLoRelocator\r\n\r\n/**\r\n * Writes pseudoinstruction `la reg, label`.\r\n *\r\n * Uses a `auipc` / `addi` pair and adds them to the relocation table\r\n */\r\nobject LA : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n\r\n        val auipc = listOf(\"auipc\", args[1], \"0\")\r\n        state.addRelocation(PCRelHiRelocator, state.getOffset(), args[2], dbg = dbg)\r\n\r\n        val addi = listOf(\"addi\", args[1], args[1], \"0\")\r\n        state.addRelocation(PCRelLoRelocator, state.getOffset() + 4, args[2], dbg = dbg)\r\n\r\n        return listOf(auipc, addi)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.riscv.isNumeral\r\nimport venusbackend.riscv.userStringToInt\r\n\r\n/**\r\n * Writes pseudoinstruction `li rd, imm`.\r\n *\r\n * This either expands to an `addi` if `imm` is small or a `lui` / `addi` pair if `imm` is big.\r\n */\r\nobject LI : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        if (!isNumeral(args[2])) {\r\n            return listOf(listOf(\"addi\", args[1], \"x0\", args[2]))\r\n        }\r\n        val imm = try {\r\n            userStringToInt(args[2])\r\n        } catch (e: NumberFormatException) {\r\n            throw AssemblerError(\"immediate to li too large or NaN\", dbg)\r\n        }\r\n\r\n        if (imm in -2048..2047) {\r\n            return listOf(listOf(\"addi\", args[1], \"x0\", args[2]))\r\n        } else {\r\n            val imm_hi = (imm + 0x800) ushr 12\r\n            val imm_lo = imm - (imm_hi shl 12)\r\n            val lui = listOf(\"lui\", args[1], imm_hi.toString())\r\n            val addi = listOf(\"addi\", args[1], args[1], imm_lo.toString())\r\n            return listOf(lui, addi)\r\n        }\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelHiRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelLoRelocator\r\n\r\n/**\r\n * Writes a load pseudoinstruction. (Those applied to a label)\r\n */\r\nobject Load : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args.size == 4) {\r\n            if (args[3].startsWith('(')) {\r\n                return listOf(\r\n                        listOf(\r\n                                args[0], args[1], args[2],\r\n                                args[3].substring(1, args[3].length - 1)))\r\n            } else {\r\n                return listOf(args)\r\n            }\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        try {\r\n            regNameToNumber(args[2], dbg = dbg)\r\n            p1warnings.add(AssemblerWarning(\"You are using the load pseudoinstruction which takes in rd, symbol and the symbol matches a register name.\"))\r\n        } catch (e: AssemblerError) {}\r\n\r\n        val auipc = listOf(\"auipc\", args[1], \"0\")\r\n        state.addRelocation(PCRelHiRelocator, state.getOffset(), args[2], dbg = dbg)\r\n\r\n        val load = listOf(args[0], args[1], \"0\", args[1])\r\n        state.addRelocation(PCRelLoRelocator, state.getOffset() + 4, args[2], dbg = dbg)\r\n\r\n        return listOf(auipc, load)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `mv rd, rs1` */\r\nobject MV : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"addi\", args[1], args[2], \"0\"))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `neg rd, rs` */\r\nobject NEG : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"sub\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `negw rd, rs` */\r\nobject NEGW : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"subw\", args[1], \"x0\", args[2]))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `nop` */\r\nobject NOP : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 1, dbg)\r\n        return listOf(listOf(\"addi\", \"x0\", \"x0\", \"0\"))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `not rd, rs` */\r\nobject NOT : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"xori\", args[1], args[2], \"-1\"))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `ret` */\r\nobject RET : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 1, dbg)\r\n        return listOf(listOf(\"jalr\", \"x0\", \"x1\", \"0\"))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/**\r\n * Writes pseudoinstruction `seq` (set equal to)\r\n * @todo add a settings option for \"extended pseudoinstructions\"\r\n */\r\nobject SEQ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        checkStrictMode()\r\n        val subtract = listOf(\"sub\", args[1], args[2], args[3])\r\n        val checkZero = listOf(\"sltiu\", args[1], args[1], \"1\")\r\n        return listOf(subtract, checkZero)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `seqz rd, rs` */\r\nobject SEQZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"sltiu\", args[1], args[2], \"1\"))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.*\r\n/* ktlint-enable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerPassOne\r\n\r\n/** Writes pseudoinstruction `sext.w rd, rs` */\r\nobject SEXTW : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        if (args[0] !== \"sext.w\") {\r\n            throw AssemblerError(\"The format for this function is wrong!\", dbg)\r\n        }\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"addiw\", args[1], args[2], \"0\"))\r\n    }\r\n}","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/**\r\n * Writes pseudoinstruction `sge` (set greater than or equal to)\r\n * @todo add a settings option for \"extended pseudoinstructions\"\r\n */\r\nobject SGE : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        checkStrictMode()\r\n        val unsigned = if (args[0].endsWith(\"u\")) \"u\" else \"\"\r\n        val set = listOf(\"slt$unsigned\", args[1], args[2], args[3])\r\n        val invert = listOf(\"xori\", args[1], args[1], \"1\")\r\n        return listOf(set, invert)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/**\r\n * Writes pseudoinstruction `sgt` (set greater than)\r\n * @todo add a settings option for \"extended pseudoinstructions\"\r\n */\r\nobject SGT : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        checkStrictMode()\r\n        val unsigned = if (args[0].endsWith(\"u\")) \"u\" else \"\"\r\n        return listOf(listOf(\"slt$unsigned\", args[1], args[3], args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `sgtz rd, rs` */\r\nobject SGTZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"slt\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/**\r\n * Writes pseudoinstruction `sle` (set less than or equal to)\r\n * @todo add a settings option for \"extended pseudoinstructions\"\r\n */\r\nobject SLE : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        checkStrictMode()\r\n        val unsigned = if (args[0].endsWith(\"u\")) \"u\" else \"\"\r\n        val set = listOf(\"slt$unsigned\", args[1], args[3], args[2])\r\n        val invert = listOf(\"xori\", args[1], args[1], \"1\")\r\n        return listOf(set, invert)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `sltz rd, rs` */\r\nobject SLTZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"slt\", args[1], args[2], \"x0\"))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/**\r\n * Writes pseudoinstruction `sne` (set not equal to)\r\n * @todo add a settings option for \"extended pseudoinstructions\"\r\n */\r\nobject SNE : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        checkStrictMode()\r\n        val subtract = listOf(\"sub\", args[1], args[2], args[3])\r\n        val checkNonZero = listOf(\"sltu\", args[1], \"x0\", args[1])\r\n        return listOf(subtract, checkNonZero)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\n\r\n/** Writes pseudoinstruction `snez rd, rs` */\r\nobject SNEZ : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 3, dbg)\r\n        return listOf(listOf(\"sltu\", args[1], \"x0\", args[2]))\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\nimport venusbackend.riscv.insts.dsl.relocators.ImmAbsStoreRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelHiRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelLoStoreRelocator\r\nimport venusbackend.riscv.userStringToInt\r\n\r\n/**\r\n * Writes a store pseudoinstruction. (Those applied to a label)\r\n */\r\nobject Store : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 4, dbg)\r\n        val hasParens = args[3].startsWith('(')\r\n        val label = args[2]\r\n        val arg3 =\r\n                if (hasParens) args[3].substring(1, args[3].length - 1) else args[3]\r\n        try {\r\n            userStringToInt(label)\r\n            /* if it's a number, this is just an ordinary store instruction */\r\n            return listOf(listOf(args[0], args[1], label, arg3))\r\n        } catch (e: NumberFormatException) {\r\n            if (hasParens) {\r\n                state.addRelocation(ImmAbsStoreRelocator, state.getOffset(),\r\n                        label, dbg = dbg)\r\n                return listOf(listOf(args[0], args[1], \"0\", arg3))\r\n            }\r\n            /* assume it's a label */\r\n        }\r\n        val auipc = listOf(\"auipc\", arg3, \"0\")\r\n        state.addRelocation(PCRelHiRelocator, state.getOffset(), label, dbg = dbg)\r\n        val store = listOf(args[0], args[1], \"0\", arg3)\r\n        state.addRelocation(PCRelLoStoreRelocator, state.getOffset() + 4, label, dbg = dbg)\r\n        return listOf(auipc, store)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerPassOne\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.assembler.LineTokens\r\nimport venusbackend.assembler.PseudoWriter\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelHiRelocator\r\nimport venusbackend.riscv.insts.dsl.relocators.PCRelLoRelocator\r\n\r\n/**\r\n * Writes pseudoinstruction `tail label`.\r\n */\r\nobject TAIL : PseudoWriter() {\r\n    override operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens> {\r\n        checkArgsLength(args, 2, dbg)\r\n\r\n        val auipc = listOf(\"auipc\", \"x6\", \"0\")\r\n        state.addRelocation(PCRelHiRelocator, state.getOffset(), args[1], dbg = dbg)\r\n\r\n        val jalr = listOf(\"jalr\", \"x0\", \"x6\", \"0\")\r\n        state.addRelocation(PCRelLoRelocator, state.getOffset() + 4, args[1], dbg = dbg)\r\n\r\n        return listOf(auipc, jalr)\r\n    }\r\n}\r\n","package venusbackend.assembler.pseudos\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.Settings\r\n\r\nfun checkArgsLength(args: List<String>, required: Int, dbg: DebugInfo) {\r\n    if (args.size != required) throw AssemblerError(\"wrong # of arguments\", dbg)\r\n}\r\n\r\nfun checkStrictMode() {\r\n    if (Settings.strict) throw AssemblerError(\"can't use this instruction in strict mode\")\r\n}\r\n","package venusbackend.assembler\r\n\r\n/**\r\n * Converts a pseudoinstruction into TAL instructions.\r\n */\r\nabstract class PseudoWriter {\r\n    /**\r\n     * Transform a pseudoinstruction into TAL instructions.\r\n     *\r\n     * @param args the arguments originally given to the pseudoinstruction\r\n     * @param state the venusbackend.assembler's state\r\n     * @return a list of LineTokens corresponding to the TAL instruction\r\n     */\r\n    internal abstract operator fun invoke(args: LineTokens, state: AssemblerPassOne, dbg: DebugInfo): List<LineTokens>\r\n}\r\n","package venusbackend.cli\r\n\r\ninterface Action {\r\n    fun invoke(arguments: ListIterator<String>)\r\n}\r\n\r\ninterface FlagAction : Action {\r\n    override fun invoke(arguments: ListIterator<String>) {\r\n        invoke()\r\n    }\r\n\r\n    fun invoke()\r\n}\r\n\r\ninterface ArgumentAction : Action {\r\n    override fun invoke(arguments: ListIterator<String>) {\r\n        if (arguments.hasNext())\r\n            invoke(arguments.next())\r\n        else\r\n            throw MissingArgumentException()\r\n    }\r\n\r\n    fun invoke(argument: String)\r\n}\r\n\r\ninterface CommandAction : Action","package venusbackend.cli\r\n\r\nclass CommandLineException(message: String) : RuntimeException(message)\r\n\r\nopen class StopParsingException : RuntimeException()\r\n\r\nclass HelpPrintedException : StopParsingException()\r\n\r\nclass MissingArgumentException : RuntimeException()\r\n\r\nfun stopParsing() {\r\n    throw StopParsingException()\r\n}","package venusbackend.cli\r\n\r\nopen class CommandLineInterface(\r\n    val commandName: String,\r\n    private val usage: String? = null,\r\n    private val description: String? = null,\r\n    private val epilogue: String? = null,\r\n    addHelp: Boolean = true,\r\n    val defaultHelpPrinter: HelpPrinter? = SimpleHelpPrinter(24),\r\n    val printHelpByDefault: Boolean = true,\r\n    val argumentsAfterDoubleDashArePositional: Boolean = true,\r\n    val shortTagPrefix: String? = null,\r\n    val longTagPrefixes: List<String> = emptyList(),\r\n    val longTagValueDelimiter: String? = null\r\n) : CommandLineBuilder {\r\n    private val usageBuilder: StringBuilder? =\r\n            if (usage == null) StringBuilder(\"Usage: $commandName \") else null\r\n    private val actualUsage get() = usageBuilder?.toString() ?: usage!!\r\n\r\n    private val helpEntries = ArrayList<HelpEntry>()\r\n\r\n    private val positionalArguments = ArrayList<PositionalArgument>()\r\n    fun getPositionalArgumentsIterator(): ListIterator<PositionalArgument> = positionalArguments.listIterator()\r\n\r\n    private val flagActions = HashMap<String, Action>()\r\n\r\n    init {\r\n        if (addHelp && defaultHelpPrinter != null) {\r\n            help(listOf(\"-h\", \"--help\"), \"Prints help\", defaultHelpPrinter, true)\r\n        }\r\n    }\r\n\r\n    fun printHelp(helpPrinter: HelpPrinter? = defaultHelpPrinter) {\r\n        if (helpPrinter == null) return\r\n\r\n        with(helpPrinter) {\r\n            begin()\r\n\r\n            printText(actualUsage)\r\n            printSeparator()\r\n\r\n            description?.let {\r\n                printText(it)\r\n                printSeparator()\r\n            }\r\n\r\n            for (entry in helpEntries) {\r\n                entry.printHelp(helpPrinter)\r\n            }\r\n\r\n            epilogue?.let {\r\n                printSeparator()\r\n                printText(it)\r\n            }\r\n\r\n            end()\r\n        }\r\n    }\r\n\r\n    override fun addUsageEntry(entry: String) {\r\n        usageBuilder?.run {\r\n            append(entry).append(\" \")\r\n        }\r\n    }\r\n\r\n    override fun addHelpEntry(helpEntry: HelpEntry) {\r\n        helpEntries.add(helpEntry)\r\n    }\r\n\r\n    override fun addPositionalArgument(positionalArgument: PositionalArgument) {\r\n        positionalArguments.add(positionalArgument)\r\n    }\r\n\r\n    private fun checkNewFlag(flag: String) {\r\n        if (flag in flagActions) {\r\n            error(\"Flag is already set: $flag\")\r\n        }\r\n    }\r\n\r\n    override fun setFlagAction(flag: String, action: Action) {\r\n        checkNewFlag(flag)\r\n        flagActions[flag] = action\r\n    }\r\n\r\n    fun getFlagAction(flag: String): Action? =\r\n            flagActions[flag]\r\n}","package venusbackend.cli\r\n\r\nclass CommandLineParser internal constructor(\r\n    private val cli: CommandLineInterface\r\n) {\r\n    fun parse(args: Array<out String>) {\r\n        parse(args.asList())\r\n    }\r\n\r\n    fun parse(args: List<String>) {\r\n        parseTokenized(tokenizeArgs(args).listIterator())\r\n    }\r\n\r\n    fun parseTokenized(argsIterator: ListIterator<String>) {\r\n        if (!argsIterator.hasNext() && cli.printHelpByDefault) {\r\n            cli.printHelp()\r\n            throw HelpPrintedException()\r\n        }\r\n\r\n        try {\r\n            doParse(argsIterator)\r\n        } catch (e: StopParsingException) {\r\n            throw e\r\n        } catch (e: Throwable) {\r\n            // TODO better error reporting\r\n            e.message?.let { cli.defaultHelpPrinter?.printText(it) }\r\n            cli.printHelp()\r\n            throw e\r\n        }\r\n    }\r\n\r\n    private lateinit var positionalsIterator: ListIterator<PositionalArgument>\r\n    private var currentPositional: PositionalArgument? = null\r\n    private var currentPositionalCount = 0\r\n\r\n    private fun doParse(argsIterator: ListIterator<String>) {\r\n        positionalsIterator = cli.getPositionalArgumentsIterator()\r\n        currentPositional = positionalsIterator.nextOrNull()\r\n        currentPositionalCount = 0\r\n\r\n        while (argsIterator.hasNext()) {\r\n            val arg = argsIterator.next()\r\n\r\n            if (cli.argumentsAfterDoubleDashArePositional && arg == \"--\") {\r\n                while (argsIterator.hasNext()) {\r\n                    handlePositionalArgument(argsIterator.next())\r\n                }\r\n                return\r\n            }\r\n\r\n            val action = cli.getFlagAction(arg)\r\n            if (action == null) {\r\n                handlePositionalArgument(arg)\r\n            } else {\r\n                try {\r\n                    action.invoke(argsIterator)\r\n                } catch (e: MissingArgumentException) {\r\n                    throw CommandLineException(\"No argument for flag $arg\")\r\n                }\r\n            }\r\n        }\r\n\r\n        currentPositional?.let {\r\n            checkEnoughPositionals(it, currentPositionalCount)\r\n        }\r\n        while (positionalsIterator.hasNext()) {\r\n            checkEnoughPositionals(positionalsIterator.next(), 0)\r\n        }\r\n    }\r\n\r\n    private fun handlePositionalArgument(arg: String) {\r\n        currentPositional.let { cp ->\r\n            if (cp != null) {\r\n                cp.action.invoke(arg)\r\n                currentPositionalCount++\r\n                if (currentPositionalCount >= cp.maxArgs) {\r\n                    currentPositional = positionalsIterator.nextOrNull()\r\n                    currentPositionalCount = 0\r\n                }\r\n            } else {\r\n                throw CommandLineException(\"Unexpected positional argument: '$arg'\")\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun checkEnoughPositionals(positionalArgument: PositionalArgument, actualCount: Int) {\r\n        if (actualCount < positionalArgument.minArgs) {\r\n            throw CommandLineException(\r\n                    \"Not enough positional arguments for ${positionalArgument.name}: \" +\r\n                            \"$actualCount, expected at least ${positionalArgument.minArgs}\"\r\n            )\r\n        }\r\n    }\r\n\r\n    private fun tokenizeArgs(args: List<String>): List<String> =\r\n            args.flatMap { tokenizeArg(it) }\r\n\r\n    private fun tokenizeArg(arg: String): List<String> {\r\n        if (cli.getFlagAction(arg) != null) return listOf(arg)\r\n\r\n        if (cli.longTagValueDelimiter != null && cli.longTagPrefixes.any { arg.startsWith(it) }) {\r\n            val k = arg.indexOf(cli.longTagValueDelimiter)\r\n            if (k >= 0) {\r\n                val longTag = arg.substring(0, k)\r\n                val longValue = arg.substring(k + 1)\r\n                return listOf(longTag, longValue)\r\n            }\r\n        }\r\n\r\n        if (isShortTagPrefixed(arg)) {\r\n            return tokenizeShortTags(arg)\r\n        }\r\n\r\n        return listOf(arg)\r\n    }\r\n\r\n    private fun tokenizeShortTags(arg: String): List<String> {\r\n        val result = ArrayList<String>()\r\n        for (i in 1 until arg.length) {\r\n            val fullTag = \"${cli.shortTagPrefix}${arg[i]}\"\r\n            val action = cli.getFlagAction(fullTag) ?: return listOf(arg)\r\n            when (action) {\r\n                is FlagAction -> result.add(fullTag)\r\n\r\n                is ArgumentAction -> {\r\n                    result.add(fullTag)\r\n                    if (i < arg.lastIndex) {\r\n                        result.add(arg.substring(i + 1))\r\n                    }\r\n                    return result\r\n                }\r\n\r\n                else -> error(\"Unexpected short tag action: $fullTag => $action\")\r\n            }\r\n        }\r\n        return result\r\n    }\r\n\r\n    private fun isShortTagPrefixed(arg: String) =\r\n            cli.shortTagPrefix != null && arg.startsWith(cli.shortTagPrefix) &&\r\n            cli.longTagPrefixes.none { arg.startsWith(it) }\r\n}","package venusbackend.cli\r\n\r\ninterface Event<out T> {\r\n    fun addListener(listener: Listener<T>)\r\n}\r\n\r\ninterface Listener<in T> {\r\n    fun onEvent(value: T)\r\n}\r\n\r\ninline fun <T> Event<T>.add(crossinline listener: (T) -> Unit) {\r\n    addListener(object : Listener<T> {\r\n        override fun onEvent(value: T) {\r\n            listener(value)\r\n        }\r\n    })\r\n}\r\n\r\ninterface EventTrigger<in T> {\r\n    fun trigger(value: T)\r\n}\r\n\r\nopen class SimpleEvent<T> : Event<T>, EventTrigger<T> {\r\n    private var listener: Listener<T>? = null\r\n\r\n    override fun addListener(listener: Listener<T>) {\r\n        if (this.listener == null) {\r\n            this.listener = listener\r\n        } else {\r\n            throw IllegalStateException(\"SimpleEvent supports single listener only\")\r\n        }\r\n    }\r\n\r\n    override fun trigger(value: T) {\r\n        listener?.onEvent(value)\r\n    }\r\n}\r\n\r\nfun CommandLineInterface.onArgument(name: String, help: String, minArgs: Int = 0, maxArgs: Int = 1): Event<String> =\r\n        SimpleEvent<String>().apply {\r\n            positionalAction(name, help, minArgs, maxArgs) { trigger(it) }\r\n        }\r\n\r\nfun CommandLineInterface.onRemainingArguments(name: String, help: String): Event<String> =\r\n        onArgument(name, help, minArgs = 0, maxArgs = Int.MAX_VALUE)\r\n\r\nfun CommandLineInterface.onFlag(flag: String, help: String): Event<Nothing?> =\r\n        onFlag(listOf(flag), help)\r\n\r\nfun CommandLineInterface.onFlag(flags: List<String>, help: String): Event<Nothing?> =\r\n        SimpleEvent<Nothing?>().apply {\r\n            flagAction(flags, help) {\r\n                trigger(null)\r\n            }\r\n        }\r\n\r\nfun CommandLineInterface.onFlagValue(flag: String, valueSyntax: String, help: String): Event<String> =\r\n        onFlagValue(listOf(flag), valueSyntax, help)\r\n\r\nfun CommandLineInterface.onFlagValue(flags: List<String>, valueSyntax: String, help: String): Event<String> =\r\n        SimpleEvent<String>().apply {\r\n            flagValueAction(flags, valueSyntax, help) {\r\n                trigger(it)\r\n            }\r\n        }\r\n\r\nclass MappedEvent<in T, R>(private val transformation: (T) -> R) : SimpleEvent<R>(), Listener<T> {\r\n    override fun onEvent(value: T) {\r\n        trigger(transformation(value))\r\n    }\r\n}\r\n\r\nfun <T, R> Event<T>.map(transformation: (T) -> R): Event<R> =\r\n        MappedEvent(transformation).also {\r\n            this@map.addListener(it)\r\n        }\r\n\r\nfun <T> Event<T>.onEach(action: (T) -> Unit) =\r\n        apply { add(action) }\r\n\r\nfun <T> Event<T>.once(action: (T) -> Unit) =\r\n        apply {\r\n            add {\r\n                action(it)\r\n                stopParsing()\r\n            }\r\n        }\r\n\r\nclass ArgumentStorage<T>(private var value: T) : ArgumentValue<T> {\r\n    override fun getValue(thisRef: Any?, prop: Any?): T =\r\n            value\r\n\r\n    fun setValue(newValue: T) {\r\n        value = newValue\r\n    }\r\n}\r\n\r\nfun <T> Event<T>.store(initialValue: T): ArgumentValue<T> =\r\n        ArgumentStorage(initialValue).apply {\r\n            add { setValue(it) }\r\n        }\r\n\r\nfun <T : Any> Event<T>.store(): ArgumentValue<T?> =\r\n        store(null)\r\n\r\nfun <T> Event<*>.storeConst(initialValue: T, storeValue: T): ArgumentValue<T> =\r\n        ArgumentStorage(initialValue).apply {\r\n            add { setValue(storeValue) }\r\n        }\r\n\r\nfun Event<*>.storeTrue() =\r\n        storeConst(false, true)\r\n\r\nfun <T> Event<T>.addTo(list: MutableList<T>): ArgumentValue<List<T>> =\r\n        ArgumentStorage(list).apply {\r\n            add { list.add(it) }\r\n        }\r\n\r\nfun <T> Event<T>.addToList() =\r\n        addTo(ArrayList())\r\n","package venusbackend.cli\r\n\r\nabstract class FlagActionBase(\r\n    val flags: List<String>,\r\n    private val help: String\r\n) : FlagAction, HelpEntry {\r\n\r\n    init {\r\n        if (flags.isEmpty()) error(\"At least one flag required\")\r\n    }\r\n\r\n    private val syntax = flags.joinToString(\", \")\r\n\r\n    override fun printHelp(helpPrinter: HelpPrinter) {\r\n        helpPrinter.printEntry(syntax, help)\r\n    }\r\n}\r\n\r\nabstract class FlagArgumentBase<T>(\r\n    flags: List<String>,\r\n    help: String,\r\n    initialValue: T\r\n) : FlagActionBase(flags, help), ArgumentValue<T> {\r\n\r\n    protected var value = initialValue\r\n\r\n    override fun getValue(thisRef: Any?, prop: Any?): T =\r\n            value\r\n}\r\n\r\nfun <T : FlagActionBase> CommandLineBuilder.registerAction(action: T): T {\r\n    addUsageEntry(\"[${action.flags.first()}]\")\r\n    addHelpEntry(action)\r\n    for (flag in action.flags) {\r\n        setFlagAction(flag, action)\r\n    }\r\n    return action\r\n}\r\n\r\nfun <T> CommandLineBuilder.registerArgument(argument: FlagArgumentBase<T>): ArgumentValue<T> =\r\n        registerAction(argument)\r\n\r\nfun CommandLineBuilder.flagAction(flags: List<String>, help: String, action: () -> Unit) {\r\n    registerAction(object : FlagActionBase(flags, help) {\r\n        override fun invoke() {\r\n            action()\r\n        }\r\n    })\r\n}\r\n\r\nfun CommandLineBuilder.flagAction(flag: String, help: String, action: () -> Unit) {\r\n    flagAction(listOf(flag), help, action)\r\n}\r\n\r\nfun CommandLineBuilder.flagArgument(flag: String, help: String) =\r\n        flagArgument(flag, help, false, true)\r\n\r\nfun <T> CommandLineBuilder.flagArgument(flags: List<String>, help: String, initialValue: T, flagValue: T) =\r\n        registerArgument(object : FlagArgumentBase<T>(flags, help, initialValue) {\r\n            override fun invoke() {\r\n                value = flagValue\r\n            }\r\n        })\r\n\r\nfun <T> CommandLineBuilder.flagArgument(flag: String, help: String, initialValue: T, flagValue: T) =\r\n        flagArgument(listOf(flag), help, initialValue, flagValue)\r\n\r\nfun <T> CommandLineBuilder.foldFlagArguments(flags: List<String>, help: String, initialValue: T, fn: (T) -> T) =\r\n        registerArgument(object : FlagArgumentBase<T>(flags, help, initialValue) {\r\n            override fun invoke() {\r\n                value = fn(value)\r\n            }\r\n        })\r\n\r\nfun <T> CommandLineBuilder.foldFlagArguments(flag: String, help: String, initialValue: T, fn: (T) -> T) =\r\n        foldFlagArguments(listOf(flag), help, initialValue, fn)\r\n\r\nfun CommandLineInterface.help(flags: List<String>, help: String, helpPrinter: HelpPrinter, exitAfterHelp: Boolean = true) {\r\n    registerAction(object : FlagActionBase(flags, help) {\r\n        override fun invoke() {\r\n            this@help.printHelp(helpPrinter)\r\n            if (exitAfterHelp) {\r\n                throw HelpPrintedException()\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfun CommandLineInterface.help(helpPrinter: HelpPrinter = SimpleHelpPrinter(24), exitAfterHelp: Boolean = true) {\r\n    help(listOf(\"-h\", \"--help\"), \"Prints help page\", helpPrinter, exitAfterHelp)\r\n}","package venusbackend.cli\r\n\r\nabstract class FlagValueActionBase(\r\n    val flags: List<String>,\r\n    val valueSyntax: String,\r\n    private val help: String\r\n) : ArgumentAction, HelpEntry {\r\n\r\n    private val syntax = \"${flags.joinToString(\", \")} $valueSyntax\"\r\n\r\n    override fun printHelp(helpPrinter: HelpPrinter) {\r\n        helpPrinter.printEntry(syntax, help)\r\n    }\r\n}\r\n\r\nabstract class FlagValueArgumentBase<T>(\r\n    flags: List<String>,\r\n    valueSyntax: String,\r\n    help: String,\r\n    initialValue: T\r\n) : FlagValueActionBase(flags, valueSyntax, help), ArgumentValue<T> {\r\n\r\n    protected var value = initialValue\r\n\r\n    override fun getValue(thisRef: Any?, prop: Any?): T =\r\n            value\r\n}\r\n\r\nfun <T : FlagValueActionBase> CommandLineBuilder.registerAction(action: T): T {\r\n    addUsageEntry(\"[${action.flags.first()} ${action.valueSyntax}]\")\r\n    addHelpEntry(action)\r\n    for (flag in action.flags) {\r\n        setFlagAction(flag, action)\r\n    }\r\n    return action\r\n}\r\n\r\nfun <T> CommandLineBuilder.registerArgument(argument: FlagValueArgumentBase<T>): ArgumentValue<T> =\r\n        argument.also { registerAction(it) }\r\n\r\nfun CommandLineBuilder.flagValueAction(\r\n    flags: List<String>,\r\n    valueSyntax: String,\r\n    help: String,\r\n    action: (String) -> Unit\r\n) {\r\n    registerAction(object : FlagValueActionBase(flags, valueSyntax, help) {\r\n        override fun invoke(argument: String) {\r\n            action(argument)\r\n        }\r\n    })\r\n}\r\n\r\nfun CommandLineBuilder.flagValueAction(\r\n    flag: String,\r\n    valueSyntax: String,\r\n    help: String,\r\n    action: (String) -> Unit\r\n) =\r\n        flagValueAction(listOf(flag), valueSyntax, help, action)\r\n\r\nfun <T> CommandLineBuilder.flagValueArgument(\r\n    flags: List<String>,\r\n    valueSyntax: String,\r\n    help: String,\r\n    initialValue: T,\r\n    mapping: (String) -> T\r\n) = registerArgument(object : FlagValueArgumentBase<T>(flags, valueSyntax, help, initialValue) {\r\n            override fun invoke(argument: String) {\r\n                value = mapping(argument)\r\n            }\r\n        })\r\n\r\nfun <T> CommandLineBuilder.flagValueArgument(\r\n    flag: String,\r\n    valueSyntax: String,\r\n    help: String,\r\n    initialValue: T,\r\n    mapping: (String) -> T\r\n) =\r\n        flagValueArgument(listOf(flag), valueSyntax, help, initialValue, mapping)\r\n\r\nfun CommandLineBuilder.flagValueArgument(flags: List<String>, valueSyntax: String, help: String) =\r\n        flagValueArgument(flags, valueSyntax, help, null, { it })\r\n\r\nfun CommandLineBuilder.flagValueArgument(flag: String, valueSyntax: String, help: String) =\r\n        flagValueArgument(listOf(flag), valueSyntax, help)\r\n\r\nfun CommandLineBuilder.flagValueArgument(flags: List<String>, valueSyntax: String, help: String, initialValue: String) =\r\n        flagValueArgument(flags, valueSyntax, help, initialValue, { it })\r\n\r\nfun CommandLineBuilder.flagValueArgument(flag: String, valueSyntax: String, help: String, initialValue: String) =\r\n        flagValueArgument(listOf(flag), valueSyntax, help, initialValue)\r\n","package venusbackend.cli\r\n\r\nclass HelpEntriesGroup(\r\n    val parent: CommandLineInterface,\r\n    private val description: String\r\n) : CommandLineBuilder, HelpEntry {\r\n    private val helpEntries = ArrayList<HelpEntry>()\r\n\r\n    override fun addUsageEntry(entry: String) {\r\n        parent.addUsageEntry(entry)\r\n    }\r\n\r\n    override fun addHelpEntry(helpEntry: HelpEntry) {\r\n        helpEntries.add(helpEntry)\r\n    }\r\n\r\n    override fun addPositionalArgument(positionalArgument: PositionalArgument) {\r\n        parent.addPositionalArgument(positionalArgument)\r\n    }\r\n\r\n    override fun setFlagAction(flag: String, action: Action) {\r\n        parent.setFlagAction(flag, action)\r\n    }\r\n\r\n    override fun printHelp(helpPrinter: HelpPrinter) {\r\n        helpPrinter.printText(description)\r\n        for (helpEntry in helpEntries) {\r\n            helpEntry.printHelp(helpPrinter)\r\n        }\r\n        helpPrinter.printSeparator()\r\n    }\r\n}\r\n\r\nfun CommandLineInterface.helpEntriesGroup(description: String) =\r\n        HelpEntriesGroup(this, description).also { addHelpEntry(it) }\r\n\r\nfun HelpEntriesGroup.help(flags: List<String>, help: String, helpPrinter: HelpPrinter, exitAfterHelp: Boolean = true) =\r\n        registerAction(object : FlagActionBase(flags, help) {\r\n            override fun invoke() {\r\n                parent.printHelp(helpPrinter)\r\n                if (exitAfterHelp) {\r\n                    throw HelpPrintedException()\r\n                }\r\n            }\r\n        })\r\n\r\nfun HelpEntriesGroup.help(flags: List<String>, help: String, exitAfterHelp: Boolean = true) =\r\n        help(flags, help, parent.defaultHelpPrinter!!, exitAfterHelp)\r\n\r\nfun HelpEntriesGroup.help(exitAfterHelp: Boolean = true) =\r\n        help(listOf(\"-h\", \"--help\"), \"Prints help page\", parent.defaultHelpPrinter!!, exitAfterHelp)","package venusbackend.cli\r\n\r\ninterface HelpPrinter {\r\n    fun begin() {}\r\n    fun printText(text: String)\r\n    fun printSeparator()\r\n    fun printEntry(helpEntry: String, description: String)\r\n    fun end() {}\r\n}\r\n\r\nfun HelpPrinter.printSectionOrNothing(text: String?) {\r\n    if (text == null) return\r\n    printText(text)\r\n    printSeparator()\r\n}\r\n\r\nfun HelpPrinter.printSection(text: String) {\r\n    printText(text)\r\n    printSeparator()\r\n}\r\n\r\ninterface HelpEntry {\r\n    fun printHelp(helpPrinter: HelpPrinter)\r\n}\r\n\r\nclass SimpleHelpPrinter(private val syntaxWidth: Int) : HelpPrinter {\r\n    override fun printText(text: String) {\r\n        println(text)\r\n    }\r\n\r\n    override fun printSeparator() {\r\n        println()\r\n    }\r\n\r\n    override fun printEntry(helpEntry: String, description: String) {\r\n        if (helpEntry.length <= syntaxWidth) {\r\n            println(\"  ${helpEntry.padEnd(syntaxWidth)}  $description\")\r\n        } else {\r\n            println(\"  $helpEntry\")\r\n            println(\"  ${\"\".padEnd(syntaxWidth)}  $description\")\r\n        }\r\n    }\r\n}\r\n\r\nfun CommandLineInterface.helpSeparator() {\r\n    addHelpEntry(object : HelpEntry {\r\n        override fun printHelp(helpPrinter: HelpPrinter) {\r\n            helpPrinter.printSeparator()\r\n        }\r\n    })\r\n}","package venusbackend.cli\r\n\r\nfun CommandLineInterface.parseArgs(vararg args: String) {\r\n    CommandLineParser(this).parse(args)\r\n}\r\n\r\nfun CommandLineInterface.parse(args: Array<out String>) {\r\n    CommandLineParser(this).parse(args)\r\n}\r\n\r\nfun CommandLineInterface.parse(args: List<String>) {\r\n    CommandLineParser(this).parse(args)\r\n}","package venusbackend.cli\r\n\r\nabstract class PositionalActionBase(\r\n    override val name: String,\r\n    private val help: String,\r\n    override val minArgs: Int,\r\n    override val maxArgs: Int\r\n) : PositionalArgument, ArgumentAction, HelpEntry {\r\n\r\n    override val action: ArgumentAction get() = this\r\n\r\n    override fun printHelp(helpPrinter: HelpPrinter) {\r\n        helpPrinter.printEntry(name, help)\r\n    }\r\n}\r\n\r\nabstract class PositionalArgumentBase<T>(\r\n    name: String,\r\n    help: String,\r\n    initialValue: T,\r\n    minArgs: Int,\r\n    maxArgs: Int\r\n) : PositionalActionBase(name, help, minArgs, maxArgs), ArgumentValue<T> {\r\n\r\n    protected var value: T = initialValue\r\n\r\n    override fun getValue(thisRef: Any?, prop: Any?): T = value\r\n}\r\n\r\nabstract class SinglePositionalArgumentBase<T>(\r\n    name: String,\r\n    help: String,\r\n    initialValue: T,\r\n    minArgs: Int = 0\r\n) : PositionalArgumentBase<T>(name, help, initialValue, minArgs, 1)\r\n\r\nabstract class ListPositionalArgumentBase<T>(\r\n    name: String,\r\n    help: String,\r\n    destination: MutableList<T>,\r\n    minArgs: Int = 0,\r\n    maxArgs: Int = Int.MAX_VALUE\r\n) : PositionalActionBase(name, help, minArgs, maxArgs), ArgumentValue<List<T>> {\r\n\r\n    protected val value = destination\r\n\r\n    override fun getValue(thisRef: Any?, prop: Any?): List<T> = value\r\n}\r\n\r\nfun <T : PositionalActionBase> CommandLineBuilder.registerAction(action: T): T =\r\n        action.also {\r\n            addUsageEntry(it.name)\r\n            addHelpEntry(it)\r\n            addPositionalArgument(it)\r\n        }\r\n\r\nfun <T> CommandLineBuilder.registerArgument(positionalArgument: PositionalArgumentBase<T>): ArgumentValue<T> =\r\n        registerAction(positionalArgument)\r\n\r\nfun CommandLineBuilder.positionalAction(name: String, help: String, minArgs: Int = 0, maxArgs: Int = 1, action: (String) -> Unit) {\r\n    registerAction(object : PositionalActionBase(name, help, minArgs, maxArgs) {\r\n        override fun invoke(argument: String) {\r\n            action(argument)\r\n        }\r\n    })\r\n}\r\n\r\nfun CommandLineBuilder.positionalArgument(name: String, help: String, minArgs: Int = 0) =\r\n        positionalArgument(name, help, minArgs, { it })\r\n\r\nfun CommandLineBuilder.positionalArgument(name: String, help: String, initialValue: String, minArgs: Int = 0) =\r\n        positionalArgument(name, help, initialValue, minArgs, { it })\r\n\r\nfun <T : Any> CommandLineBuilder.positionalArgument(name: String, help: String, minArgs: Int = 0, mapping: (String) -> T) =\r\n        registerArgument(object : SinglePositionalArgumentBase<T?>(name, help, null, minArgs) {\r\n            override fun invoke(argument: String) {\r\n                value = mapping(argument)\r\n            }\r\n        })\r\n\r\nfun <T : Any> CommandLineBuilder.positionalArgument(name: String, help: String, initialValue: T, minArgs: Int = 0, mapping: (String) -> T) =\r\n        registerArgument(object : SinglePositionalArgumentBase<T>(name, help, initialValue, minArgs) {\r\n            override fun invoke(argument: String) {\r\n                value = mapping(argument)\r\n            }\r\n        })\r\n\r\nfun CommandLineBuilder.positionalArgumentsList(\r\n    name: String,\r\n    help: String,\r\n    destination: MutableList<String> = ArrayList(),\r\n    minArgs: Int = 0,\r\n    maxArgs: Int = Int.MAX_VALUE\r\n): ArgumentValue<List<String>> = positionalArgumentsList(name, help, destination, minArgs, maxArgs, { it })\r\n\r\nfun <T> CommandLineBuilder.positionalArgumentsList(\r\n    name: String,\r\n    help: String,\r\n    destination: MutableList<T> = ArrayList(),\r\n    minArgs: Int = 0,\r\n    maxArgs: Int = Int.MAX_VALUE,\r\n    mapping: (String) -> T\r\n): ArgumentValue<List<T>> = registerAction(object : ListPositionalArgumentBase<T>(name, help, destination, minArgs, maxArgs) {\r\n            override fun invoke(argument: String) {\r\n                value.add(mapping(argument))\r\n            }\r\n        })\r\n\r\nfun <T> CommandLineBuilder.foldPositionalArguments(\r\n    name: String,\r\n    help: String,\r\n    initialValue: T,\r\n    minArgs: Int = 0,\r\n    maxArgs: Int = Int.MAX_VALUE,\r\n    fn: (T, String) -> T\r\n) = registerArgument(object : PositionalArgumentBase<T>(name, help, initialValue, minArgs, maxArgs) {\r\n            override fun invoke(argument: String) {\r\n                value = fn(value, argument)\r\n            }\r\n        })\r\n","package venusbackend.cli\r\n\r\nclass SharedOptionBuilder<T>(private val storage: ArgumentStorage<T>) {\r\n    fun Event<T>.storeShared() {\r\n        add { storage.setValue(it) }\r\n    }\r\n\r\n    fun Event<*>.storeShared(value: T) {\r\n        add { storage.setValue(value) }\r\n    }\r\n}\r\n\r\ninline fun <T> sharedOption(initialValue: T, build: SharedOptionBuilder<T>.() -> Unit): ArgumentValue<T> {\r\n    val storage = ArgumentStorage(initialValue)\r\n    val builder = SharedOptionBuilder(storage)\r\n    builder.build()\r\n    return storage\r\n}","package venusbackend.cli\r\n\r\nclass Subcommand(\r\n    val cli: CommandLineInterface,\r\n    val help: String,\r\n    val action: () -> Unit\r\n) {\r\n    val name = cli.commandName\r\n}\r\n\r\nfun CommandLineInterface.subcommands(usage: String, helpCaption: String, vararg subcommands: Subcommand) {\r\n    for (subcommand in subcommands) {\r\n        setFlagAction(subcommand.name, object : CommandAction {\r\n            override fun invoke(arguments: ListIterator<String>) {\r\n                CommandLineParser(subcommand.cli).parseTokenized(arguments)\r\n                subcommand.action()\r\n            }\r\n        })\r\n    }\r\n\r\n    addUsageEntry(usage)\r\n\r\n    addHelpEntry(object : HelpEntry {\r\n        override fun printHelp(helpPrinter: HelpPrinter) {\r\n            helpPrinter.printText(helpCaption)\r\n            for (subcommand in subcommands) {\r\n                helpPrinter.printEntry(\"${subcommand.name} ...\", subcommand.help)\r\n            }\r\n            helpPrinter.printSeparator()\r\n        }\r\n    })\r\n}\r\n\r\nfun subcommand(cli: CommandLineInterface, help: String, action: () -> Unit) =\r\n        Subcommand(cli, help, action)\r\n","package venusbackend.cli\r\n\r\nfun <T : Any> Iterator<T>.nextOrNull(): T? =\r\n        if (hasNext()) next() else null","package venusbackend.linker\r\n\r\nimport venusbackend.riscv.Import\r\n\r\ndata class ImportProgramData(\r\n    val progImport: Import,\r\n    val importingProgram: Import,\r\n    val importingProgramAbsPath: String\r\n)","package venusbackend.linker\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.Program\r\n\r\n/**\r\n * Debug info with the program's name\r\n *\r\n * @param programName name of the program\r\n * @param dbg the debugging information\r\n */\r\ndata class ProgramDebugInfo(val programName: String, val dbg: DebugInfo)\r\n\r\n/**\r\n * A program which also has attached debugging information.\r\n *\r\n * Generated by the [Linker].\r\n */\r\nclass LinkedProgram {\r\n    val prog = Program(absPath = \"\")\r\n    val dbg = ArrayList<ProgramDebugInfo>()\r\n    var startPC: Int? = null\r\n}","package venusbackend.linker\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.riscv.insts.dsl.relocators.Relocator\r\n\r\n/**\r\n * Describes how to relocate a given instructions\r\n *\r\n * @param relocator the relocator to use\r\n * @param label the target label\r\n * @param offset the byte offset the instruction is at\r\n */\r\ndata class RelocationInfo(val relocator: Relocator, val offset: Int, val label: String, val labelOffset: Int, val dbg: DebugInfo)\r\n\r\n/**\r\n * Describes how to relocate data bytes\r\n *\r\n * @param offset the byte offset in the data segment\r\n * @param label the target label\r\n */\r\ndata class DataRelocationInfo(val offset: Int, val label: String, val labelOffset: Int, val dbg: DebugInfo)\r\n\r\n/**\r\n * A singleton which links a list of programs into one program.\r\n *\r\n * @see LinkedProgram\r\n */\r\nobject Linker {\r\n    /**\r\n     * Links together the given list of programs.\r\n     *\r\n     * This consists of several steps:\r\n     *      - Collect all the labels in each program.\r\n     *      - Keep track of all the instructions which need to be relocated.\r\n     *      - Append all the instructions together.\r\n     *      - Append all of the debugging info together.\r\n     *      - Append all of the data segments together\r\n     * Once the above is done, all the appropriate relocation is performed.\r\n     *\r\n     * @param progs a list of programs which will be linked\r\n     * @return a [LinkedProgram] which can be used in the [venus.simulator.Simulator]\r\n     * @todo refactor this into multiple functions\r\n     */\r\n    fun link(progsAndLibs: ProgramAndLibraries): LinkedProgram {\r\n        val linkedProgram = LinkedProgram()\r\n        val globalTable = HashMap<String, Int>()\r\n        val toRelocate = ArrayList<RelocationInfo>()\r\n        val toRelocateData = ArrayList<DataRelocationInfo>()\r\n        var textTotalOffset = 0\r\n        var dataTotalOffset = 0\r\n\r\n        val progs = progsAndLibs.AllProgs\r\n\r\n        if (progs.size > 0) {\r\n            linkedProgram.prog.name = progs[0].name\r\n        }\r\n        for (prog in progs) {\r\n            for ((label, offset) in prog.labels) {\r\n                val start = if (offset >= MemorySegments.STATIC_BEGIN) {\r\n                    dataTotalOffset\r\n                } else {\r\n                    textTotalOffset\r\n                }\r\n                val location = start + offset\r\n\r\n                if (prog.isGlobalLabel(label)) {\r\n                    val previousValue = globalTable.put(label, location)\r\n                    if (previousValue != null) {\r\n                        throw AssemblerError(\"label $label defined global in two different files\")\r\n                    }\r\n                    if (label == \"main\") {\r\n                        linkedProgram.prog.makeLabelGlobal(\"main\")\r\n                        linkedProgram.startPC = location + MemorySegments.TEXT_BEGIN\r\n                    }\r\n                }\r\n            }\r\n\r\n            prog.insts.forEach(linkedProgram.prog::add)\r\n            prog.debugInfo.forEach {\r\n                linkedProgram.dbg.add(ProgramDebugInfo(prog.name, it))\r\n            }\r\n            prog.dataSegment.forEach(linkedProgram.prog::addToData)\r\n\r\n            for ((relocator, offset, label, labelOffset, dbg) in prog.relocationTable) {\r\n                val location = textTotalOffset + offset\r\n                val mcode = linkedProgram.prog.insts[location / 4]\r\n                if (label == \"\") {\r\n                    relocator(mcode, location, labelOffset, dbg = dbg)\r\n                } else {\r\n                    val toAddress = prog.labels.get(label)\r\n                    if (toAddress != null) {\r\n                        /* TODO: fix this for variable length instructions */\r\n                        relocator(mcode, location, toAddress + labelOffset + textTotalOffset, dbg = dbg)\r\n                    } else {\r\n                        /* need to relocate globally */\r\n                        toRelocate.add(RelocationInfo(\r\n                                relocator, location,\r\n                                label, labelOffset, dbg))\r\n                    }\r\n                }\r\n\r\n//                val toAddress = prog.labels.get(label)\r\n//                val location = textTotalOffset + offset\r\n//                if (toAddress != null) {\r\n//                    /* TODO: fix this for variable length instructions */\r\n//                    val mcode = linkedProgram.prog.insts[location / 4]\r\n//                    relocator(mcode, location, toAddress + textTotalOffset)\r\n//                } else {\r\n//                    /* need to relocate globally */\r\n//                    toRelocate.add(RelocationInfo(relocator, location, label))\r\n//                }\r\n            }\r\n\r\n            for ((offset, label, labelOffset, dbg) in prog.dataRelocationTable) {\r\n                val toAddress0 = prog.labels.get(label)\r\n                val location = dataTotalOffset + offset\r\n                if (toAddress0 != null) {\r\n                    val toAddress = toAddress0 + labelOffset\r\n                    linkedProgram.prog.overwriteData(location, toAddress.toByte())\r\n                    linkedProgram.prog.overwriteData(\r\n                            location + 1,\r\n                            (toAddress shr 8).toByte())\r\n                    linkedProgram.prog.overwriteData(\r\n                            location + 2,\r\n                            (toAddress shr 16).toByte())\r\n                    linkedProgram.prog.overwriteData(\r\n                            location + 3,\r\n                            (toAddress shr 24).toByte())\r\n                } else {\r\n                    /* need to relocate globally */\r\n                    toRelocateData.add(DataRelocationInfo(\r\n                            location, label, labelOffset, dbg))\r\n                }\r\n            }\r\n            textTotalOffset += prog.textSize\r\n            dataTotalOffset += prog.dataSize\r\n            /* These two last lines are an ugly hack to fix the la of an import file generating a fixed offset already. */\r\n            dataTotalOffset += if (prog != progs.last()) {\r\n                for (i in 0 until prog.textSize) {\r\n                    linkedProgram.prog.addToData(0)\r\n                }\r\n                prog.dataSize + prog.textSize\r\n            } else {\r\n                prog.dataSize\r\n            }\r\n        }\r\n\r\n        for ((relocator, offset, label, labelOffset, dbg) in toRelocate) {\r\n            val toAddress = globalTable.get(label)\r\n                    ?: throw AssemblerError(\"label $label used but not defined\", dbg)\r\n\r\n            val mcode = linkedProgram.prog.insts[offset / 4]\r\n            relocator(mcode, offset, toAddress, dbg = dbg)\r\n        }\r\n\r\n        for ((location, label, labelOffset, dbg) in toRelocateData) {\r\n            val toAddress = globalTable.get(label) ?: throw AssemblerError(\"label $label used but not defined\", dbg)\r\n            linkedProgram.prog.overwriteData(location, toAddress.toByte())\r\n            linkedProgram.prog.overwriteData(location + 1, (toAddress shr 8).toByte())\r\n            linkedProgram.prog.overwriteData(location + 2, (toAddress shr 16).toByte())\r\n            linkedProgram.prog.overwriteData(location + 3, (toAddress shr 24).toByte())\r\n        }\r\n\r\n        return linkedProgram\r\n    }\r\n}\r\n","package venusbackend.linker\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venus.Driver.assemble\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSProgram\r\nimport venus.vfs.VFSType\r\nimport venus.vfs.VirtualFileSystem\r\nimport venusbackend.assembler.Assembler\r\nimport venusbackend.riscv.Import\r\nimport venusbackend.riscv.Program\r\n\r\nclass ProgramAndLibraries(val progs: List<Program>, vfs: VirtualFileSystem) {\r\n    val AllProgs = ArrayList<Program>()\r\n    init {\r\n        val seenPrograms = HashMap<Import, ImportProgramData>()\r\n        val needToImportPrograms = HashMap<Import, ImportProgramData>()\r\n//        val mainProg = \"the main program\"\r\n        for (prog in progs) {\r\n            val imp = Import(prog.name, false)\r\n            seenPrograms[imp] = ImportProgramData(imp, Import(prog.absPath, false), prog.absPath)\r\n            addProgramImports(prog, Import(prog.absPath, false), prog.absPath, seenPrograms, needToImportPrograms)\r\n            AllProgs.add(prog)\r\n        }\r\n        val keysToRemove = HashSet<Import>()\r\n        for (sprog in seenPrograms.values) {\r\n            if (needToImportPrograms.containsKey(sprog.progImport)) {\r\n                keysToRemove.add(sprog.progImport)\r\n            }\r\n        }\r\n        for (ktr in keysToRemove) {\r\n            needToImportPrograms.remove(ktr)\r\n        }\r\n        while (needToImportPrograms.isNotEmpty()) {\r\n            val progImport = needToImportPrograms.keys.elementAt(0)\r\n            val progname = progImport.path\r\n            val progData = needToImportPrograms[progImport]!!\r\n            needToImportPrograms.remove(progImport)\r\n            // Get the file\r\n            val obj = if (progImport.relative) {\r\n                val parentNode = vfs.getObjectFromPath(progData.importingProgramAbsPath, location = vfs.sentinel) ?: throw AssemblerError(\"Could not find the library: $progname from the relative path from the file. Parent file not found! This library was imported by ${progData.importingProgram}.\")\r\n                val loc = vfs.getParentFromObject(parentNode)\r\n                vfs.getObjectFromPath(progname, location = loc) ?: throw AssemblerError(\"Could not find the library: $progname from the relative path from the file. This library was imported by ${progData.importingProgram}.\")\r\n            } else {\r\n                vfs.getObjectFromPath(progname) ?: throw AssemblerError(\"Could not find the library: $progname from the absolute path (CWD). This library was imported by ${progData.importingProgram}.\")\r\n            }\r\n\r\n            val prog = when (obj.type) {\r\n                VFSType.File -> {\r\n                    // Get the text\r\n                    val progText = (obj as VFSFile).readText()\r\n                    val (prog, errors, warnings) = Assembler.assemble(progText, progname, obj.getPath())\r\n                    if (errors.isNotEmpty()) {\r\n                        var msgs = \"Could not load the library: $progname (Note: The library file was found but it could not be assembled) This library was imported by ${progData.importingProgram}. Here are a list of errors which may help:\\n\\n\"\r\n                        for (error in errors) {\r\n                            msgs += \"${error.message}\\n\\n\"\r\n                        }\r\n                        throw AssemblerError(msgs)\r\n                    }\r\n                    prog\r\n                }\r\n                VFSType.Program -> {\r\n                    (obj as VFSProgram).getProgram()\r\n                }\r\n                else -> {\r\n                    throw AssemblerError(\"The path for $progname is not a file or program! This library was imported by ${progData.importingProgram}.\")\r\n                }\r\n            }\r\n\r\n            // Add program to seen programs and All progs.\r\n            AllProgs.add(prog)\r\n            seenPrograms[progImport] = progData\r\n            addProgramImports(prog, progImport, obj.getPath(), seenPrograms, needToImportPrograms)\r\n        }\r\n    }\r\n\r\n    fun addProgramImports(prog: Program, progImport: Import, progImportAbsPath: String, SeenPrograms: HashMap<Import, ImportProgramData>, needToImportPrograms: HashMap<Import, ImportProgramData>) {\r\n        for (import in prog.imports) {\r\n            if (!SeenPrograms.contains(import)) {\r\n                needToImportPrograms[import] = ImportProgramData(import, progImport, progImportAbsPath)\r\n            }\r\n        }\r\n    }\r\n}","package venusbackend.numbers\r\n\r\nimport kotlin.math.sign\r\n\r\n// Fixme Need to actually implement this. I just copied it from Quadword.\r\nclass DoubleQuadWord(\r\n    var int0: Int = 0,\r\n    var int1: Int = 0,\r\n    var int2: Int = 0,\r\n    var int3: Int = 0,\r\n    var int4: Int = 0,\r\n    var int5: Int = 0,\r\n    var int6: Int = 0,\r\n    var int7: Int = 0\r\n) : Number(), Comparable<DoubleQuadWord> {\r\n    companion object {\r\n        /**\r\n         * The number of bytes used to represent an instance of Int in a binary form.\r\n         */\r\n        public const val SIZE_BYTES: Int = 32\r\n\r\n        /**\r\n         * The number of bits used to represent an instance of Int in a binary form.\r\n         */\r\n        public const val SIZE_BITS: Int = 256\r\n        /**\r\n         * A constant holding the minimum value an instance of Int can have.\r\n         */\r\n        public val MIN_VALUE: DoubleQuadWord = DoubleQuadWord(Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE)\r\n\r\n        /**\r\n         * A constant holding the maximum value an instance of Int can have.\r\n         */\r\n        public val MAX_VALUE: DoubleQuadWord = DoubleQuadWord(Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE)\r\n    }\r\n\r\n    override fun compareTo(other: DoubleQuadWord): Int {\r\n        val int3comp = this.int3.compareTo(other.int3)\r\n        if (int3comp == 0) {\r\n            val int2comp = this.int2.compareTo(other.int2)\r\n            if (int2comp == 0) {\r\n                val int1comp = this.int1.compareTo(other.int1)\r\n                if (int1comp == 0) {\r\n                    return this.int0.compareTo(other.int0)\r\n                }\r\n                return int1comp\r\n            }\r\n            return int2comp\r\n        }\r\n        return int3comp\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Byte): Int {\r\n        return this.toByte().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Short): Int {\r\n        return this.toShort().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Int): Int {\r\n        return this.toInt().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Long): Int {\r\n        return this.toLong().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Float): Int {\r\n        return this.toFloat().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Double): Int {\r\n        return this.toDouble().compareTo(other)\r\n    }\r\n\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Byte): DoubleQuadWord {\r\n        return this.plus(other.toDoubleQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Short): DoubleQuadWord {\r\n        return this.plus(other.toDoubleQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Int): DoubleQuadWord {\r\n        return this.plus(other.toDoubleQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Long): DoubleQuadWord {\r\n        return this.plus(other.toDoubleQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Float): Float {\r\n        return this.toFloat() + other\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Double): Double {\r\n        return this.toDouble() + other\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: DoubleQuadWord): DoubleQuadWord {\r\n        val long0 = this.int0.toLong() + other.int0.toLong()\r\n        val long1 = this.int1.toLong() + other.int1.toLong() + (long0 ushr 32)\r\n        val long2 = this.int2.toLong() + other.int2.toLong() + (long1 ushr 32)\r\n        val long3 = this.int3.toLong() + other.int3.toLong() + (long2 ushr 32)\r\n        return DoubleQuadWord(long0.toInt(), long1.toInt(), long2.toInt(), long3.toInt())\r\n    }\r\n\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Byte): DoubleQuadWord {\r\n        return this.minus(other.toDoubleQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Short): DoubleQuadWord {\r\n        return this.minus(other.toDoubleQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Int): DoubleQuadWord {\r\n        return this.minus(other.toDoubleQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Long): DoubleQuadWord {\r\n        return this.minus(other.toDoubleQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Float): Float {\r\n        return this.toFloat() - other\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Double): Double {\r\n        return this.toDouble() - other\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: DoubleQuadWord): DoubleQuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Byte): DoubleQuadWord {\r\n        return this.times(other.toDoubleQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Short): DoubleQuadWord {\r\n        return this.times(other.toDoubleQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Int): DoubleQuadWord {\r\n        return this.times(other.toDoubleQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Long): DoubleQuadWord {\r\n        return this.times(other.toDoubleQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Float): Float {\r\n        return this.toFloat() * other\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Double): Double {\r\n        return this.toDouble() * other\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: DoubleQuadWord): DoubleQuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Byte): DoubleQuadWord {\r\n        return this.div(other.toDoubleQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Short): DoubleQuadWord {\r\n        return this.div(other.toDoubleQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Int): DoubleQuadWord {\r\n        return this.div(other.toDoubleQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Long): DoubleQuadWord {\r\n        return this.div(other.toDoubleQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Float): Float {\r\n        return this.toFloat() / other\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Double): Double {\r\n        return this.toDouble() / other\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: DoubleQuadWord): DoubleQuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Byte): DoubleQuadWord {\r\n        return this.rem(other.toDoubleQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Short): DoubleQuadWord {\r\n        return this.rem(other.toDoubleQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Int): DoubleQuadWord {\r\n        return this.rem(other.toDoubleQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Long): DoubleQuadWord {\r\n        return this.rem(other.toDoubleQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Float): Float {\r\n        return this.toFloat().rem(other)\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Double): Double {\r\n        return this.toDouble().rem(other)\r\n    }\r\n\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: DoubleQuadWord): DoubleQuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Increments this value. */\r\n    public operator fun inc(): DoubleQuadWord {\r\n        return this.plus(1)\r\n    }\r\n    /** Decrements this value. */\r\n    public operator fun dec(): DoubleQuadWord {\r\n        return this.minus(1)\r\n    }\r\n    /** Returns this value. */\r\n    public operator fun unaryPlus(): DoubleQuadWord {\r\n        return this\r\n    }\r\n    /** Returns the negative of this value. */\r\n    public operator fun unaryMinus(): DoubleQuadWord {\r\n        return 0.toDoubleQuadWord() - this\r\n    }\r\n\r\n    /** Shifts this value left by the [bitCount] number of bits. */\r\n    public infix fun shl(bitCount: Int): DoubleQuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return DoubleQuadWord(0, 0, 0, 0)\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val msb0 = (qw.int0 shr 31)\r\n            val msb1 = (qw.int1 shr 31)\r\n            val msb2 = (qw.int2 shr 31)\r\n            qw.int0 = (qw.int0 shl 1)\r\n            qw.int1 = (qw.int1 shl 1) and msb0\r\n            qw.int2 = (qw.int2 shl 1) and msb1\r\n            qw.int3 = (qw.int2 shl 1) and msb2\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val msb0 = (qw.int0 shr 30)\r\n            val msb1 = (qw.int1 shr 30)\r\n            val msb2 = (qw.int2 shr 30)\r\n            qw.int0 = (qw.int0 shl 2)\r\n            qw.int1 = (qw.int1 shl 2) and msb0\r\n            qw.int2 = (qw.int2 shl 2) and msb1\r\n            qw.int3 = (qw.int2 shl 2) and msb2\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val msb0 = (qw.int0 shr 28)\r\n            val msb1 = (qw.int1 shr 28)\r\n            val msb2 = (qw.int2 shr 28)\r\n            qw.int0 = (qw.int0 shl 4)\r\n            qw.int1 = (qw.int1 shl 4) and msb0\r\n            qw.int2 = (qw.int2 shl 4) and msb1\r\n            qw.int3 = (qw.int2 shl 4) and msb2\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val msb0 = (qw.int0 shr 24)\r\n            val msb1 = (qw.int1 shr 24)\r\n            val msb2 = (qw.int2 shr 24)\r\n            qw.int0 = (qw.int0 shl 8)\r\n            qw.int1 = (qw.int1 shl 8) and msb0\r\n            qw.int2 = (qw.int2 shl 8) and msb1\r\n            qw.int3 = (qw.int2 shl 8) and msb2\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val msb0 = (qw.int0 shr 16)\r\n            val msb1 = (qw.int1 shr 16)\r\n            val msb2 = (qw.int2 shr 16)\r\n            qw.int0 = (qw.int0 shl 16)\r\n            qw.int1 = (qw.int1 shl 16) and msb0\r\n            qw.int2 = (qw.int2 shl 16) and msb1\r\n            qw.int3 = (qw.int2 shl 16) and msb2\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int3 = qw.int2\r\n            qw.int2 = qw.int1\r\n            qw.int1 = qw.int0\r\n            qw.int0 = 0\r\n        }\r\n        return qw\r\n    }\r\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with copies of the sign bit. */\r\n    public infix fun shr(bitCount: Int): DoubleQuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return if (this.int3.sign == -1) {\r\n                DoubleQuadWord(Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE)\r\n            } else {\r\n                DoubleQuadWord()\r\n            }\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val lsb1 = (qw.int1 and 0x1) shl 31\r\n            val lsb2 = (qw.int2 and 0x1) shl 31\r\n            val lsb3 = (qw.int3 and 0x1) shl 31\r\n            qw.int0 = (qw.int0 shr 1) and lsb1\r\n            qw.int1 = (qw.int1 shr 1) and lsb2\r\n            qw.int2 = (qw.int2 shr 1) and lsb3\r\n            qw.int3 = (qw.int2 shr 1)\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11) shl 30\r\n            val lsb2 = (qw.int2 and 0b11) shl 30\r\n            val lsb3 = (qw.int3 and 0b11) shl 30\r\n            qw.int0 = (qw.int0 shr 2) and lsb1\r\n            qw.int1 = (qw.int1 shr 2) and lsb2\r\n            qw.int2 = (qw.int2 shr 2) and lsb3\r\n            qw.int3 = (qw.int2 shr 2)\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111) shl 28\r\n            val lsb2 = (qw.int2 and 0b1111) shl 28\r\n            val lsb3 = (qw.int3 and 0b1111) shl 28\r\n            qw.int0 = (qw.int0 shr 4) and lsb1\r\n            qw.int1 = (qw.int1 shr 4) and lsb2\r\n            qw.int2 = (qw.int2 shr 4) and lsb3\r\n            qw.int3 = (qw.int2 shr 4)\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11111111) shr 24\r\n            val lsb2 = (qw.int2 and 0b11111111) shr 24\r\n            val lsb3 = (qw.int3 and 0b11111111) shr 24\r\n            qw.int0 = (qw.int0 shr 8) and lsb1\r\n            qw.int1 = (qw.int1 shr 8) and lsb2\r\n            qw.int2 = (qw.int2 shr 8) and lsb3\r\n            qw.int3 = (qw.int2 shr 8)\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111111111111111) shr 16\r\n            val lsb2 = (qw.int2 and 0b1111111111111111) shr 16\r\n            val lsb3 = (qw.int3 and 0b1111111111111111) shr 16\r\n            qw.int0 = (qw.int0 shr 16) and lsb1\r\n            qw.int1 = (qw.int1 shr 16) and lsb2\r\n            qw.int2 = (qw.int2 shr 16) and lsb3\r\n            qw.int3 = (qw.int2 shr 16)\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int0 = qw.int1\r\n            qw.int1 = qw.int2\r\n            qw.int2 = qw.int3\r\n            qw.int3 = 0\r\n        }\r\n        return qw\r\n    }\r\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\r\n    public infix fun ushr(bitCount: Int): DoubleQuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return DoubleQuadWord(0, 0, 0, 0)\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val lsb1 = (qw.int1 and 0x1) shl 31\r\n            val lsb2 = (qw.int2 and 0x1) shl 31\r\n            val lsb3 = (qw.int3 and 0x1) shl 31\r\n            qw.int0 = (qw.int0 ushr 1) and lsb1\r\n            qw.int1 = (qw.int1 ushr 1) and lsb2\r\n            qw.int2 = (qw.int2 ushr 1) and lsb3\r\n            qw.int3 = (qw.int2 ushr 1)\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11) shl 30\r\n            val lsb2 = (qw.int2 and 0b11) shl 30\r\n            val lsb3 = (qw.int3 and 0b11) shl 30\r\n            qw.int0 = (qw.int0 ushr 2) and lsb1\r\n            qw.int1 = (qw.int1 ushr 2) and lsb2\r\n            qw.int2 = (qw.int2 ushr 2) and lsb3\r\n            qw.int3 = (qw.int2 ushr 2)\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111) shl 28\r\n            val lsb2 = (qw.int2 and 0b1111) shl 28\r\n            val lsb3 = (qw.int3 and 0b1111) shl 28\r\n            qw.int0 = (qw.int0 ushr 4) and lsb1\r\n            qw.int1 = (qw.int1 ushr 4) and lsb2\r\n            qw.int2 = (qw.int2 ushr 4) and lsb3\r\n            qw.int3 = (qw.int2 ushr 4)\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11111111) shr 24\r\n            val lsb2 = (qw.int2 and 0b11111111) shr 24\r\n            val lsb3 = (qw.int3 and 0b11111111) shr 24\r\n            qw.int0 = (qw.int0 ushr 8) and lsb1\r\n            qw.int1 = (qw.int1 ushr 8) and lsb2\r\n            qw.int2 = (qw.int2 ushr 8) and lsb3\r\n            qw.int3 = (qw.int2 ushr 8)\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111111111111111) shr 16\r\n            val lsb2 = (qw.int2 and 0b1111111111111111) shr 16\r\n            val lsb3 = (qw.int3 and 0b1111111111111111) shr 16\r\n            qw.int0 = (qw.int0 ushr 16) and lsb1\r\n            qw.int1 = (qw.int1 ushr 16) and lsb2\r\n            qw.int2 = (qw.int2 ushr 16) and lsb3\r\n            qw.int3 = (qw.int2 ushr 16)\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int0 = qw.int1\r\n            qw.int1 = qw.int2\r\n            qw.int2 = qw.int3\r\n            qw.int3 = Int.MAX_VALUE\r\n        }\r\n        return qw\r\n    }\r\n    /** Performs a bitwise AND operation between the two values. */\r\n    public infix fun and(other: DoubleQuadWord): DoubleQuadWord {\r\n        val int0 = this.int0 and other.int0\r\n        val int1 = this.int1 and other.int1\r\n        val int2 = this.int2 and other.int2\r\n        val int3 = this.int3 and other.int3\r\n        return DoubleQuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Performs a bitwise OR operation between the two values. */\r\n    public infix fun or(other: DoubleQuadWord): DoubleQuadWord {\r\n        val int0 = this.int0 or other.int0\r\n        val int1 = this.int1 or other.int1\r\n        val int2 = this.int2 or other.int2\r\n        val int3 = this.int3 or other.int3\r\n        return DoubleQuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Performs a bitwise XOR operation between the two values. */\r\n    public infix fun xor(other: DoubleQuadWord): DoubleQuadWord {\r\n        val int0 = this.int0 xor other.int0\r\n        val int1 = this.int1 xor other.int1\r\n        val int2 = this.int2 xor other.int2\r\n        val int3 = this.int3 xor other.int3\r\n        return DoubleQuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Inverts the bits in this value. */\r\n    public fun inv(): DoubleQuadWord {\r\n        val int0 = this.int0.inv()\r\n        val int1 = this.int1.inv()\r\n        val int2 = this.int2.inv()\r\n        val int3 = this.int3.inv()\r\n        return DoubleQuadWord(int0, int1, int2, int3)\r\n    }\r\n\r\n    override fun toChar() = int0.toChar()\r\n    override fun toDouble() = this.toLong().toDouble()\r\n    override fun toFloat() = int0.toFloat()\r\n    override fun toInt() = int0\r\n    override fun toLong() = (int1.toLong() shl 32) or int0.toLong()\r\n    override fun toShort() = int0.toShort()\r\n    override fun toByte() = int0.toByte()\r\n\r\n    fun low(): Long {\r\n        return this.toLong()\r\n    }\r\n\r\n    fun high(): Long {\r\n        return (int3.toLong() shl 32) or int2.toLong()\r\n    }\r\n\r\n    public fun copy(): DoubleQuadWord {\r\n        return DoubleQuadWord(this.int0, this.int1, this.int2, this.int3)\r\n    }\r\n\r\n    override fun toString(): String {\r\n        throw NotImplementedError()\r\n//        return String.format(\"0x%016x%016x\", high(), low())\r\n    }\r\n}\r\n\r\nfun Number.toDoubleQuadWord(): DoubleQuadWord {\r\n    if (this is DoubleQuadWord) {\r\n        return this\r\n    }\r\n    if (this is QuadWord) {\r\n        return this.toQuadWord().toDoubleQuadWord()\r\n    }\r\n    if (this is Int) {\r\n        return this.toInt().toDoubleQuadWord()\r\n    }\r\n    if (this is Long) {\r\n        return this.toLong().toDoubleQuadWord()\r\n    }\r\n    if (this is Byte) {\r\n        return this.toByte().toDoubleQuadWord()\r\n    }\r\n    if (this is Short) {\r\n        return this.toShort().toDoubleQuadWord()\r\n    }\r\n    throw ClassCastException(\"Unknown number type!\")\r\n}\r\n\r\nfun Byte.toDoubleQuadWord(): DoubleQuadWord {\r\n    val num = this.toInt()\r\n    return if (num.sign == -1) {\r\n        DoubleQuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        DoubleQuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Short.toDoubleQuadWord(): DoubleQuadWord {\r\n    val num = this.toInt()\r\n    return if (num.sign == -1) {\r\n        DoubleQuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        DoubleQuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Int.toDoubleQuadWord(): DoubleQuadWord {\r\n    val num = this\r\n    return if (num.sign == -1) {\r\n        DoubleQuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        DoubleQuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Long.toDoubleQuadWord(): DoubleQuadWord {\r\n    val num = this\r\n    return if (num.sign == -1) {\r\n        DoubleQuadWord(int0 = num.toInt(), int1 = (num shr 32).toInt(), int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        DoubleQuadWord(int0 = num.toInt(), int1 = (num shr 32).toInt())\r\n    }\r\n}\r\n\r\nfun Byte.toUDoubleQuadWord(): DoubleQuadWord {\r\n    return DoubleQuadWord(int0 = this.toInt())\r\n}\r\n\r\nfun Short.toUDoubleQuadWord(): DoubleQuadWord {\r\n    return DoubleQuadWord(int0 = this.toInt())\r\n}\r\n\r\nfun Int.toUDoubleQuadWord(): DoubleQuadWord {\r\n    return DoubleQuadWord(int0 = this)\r\n}\r\n\r\nfun Long.toUDoubleQuadWord(): DoubleQuadWord {\r\n    return DoubleQuadWord(int0 = this.toInt(), int1 = (this shr 32).toInt())\r\n}\r\n\r\noperator fun Int.minus(other: DoubleQuadWord): DoubleQuadWord {\r\n    return this.toDoubleQuadWord() - other\r\n}\r\n\r\n// import kotlin.random.Random\r\n//\r\n// class DoubleQuadWord private constructor(n: Int) {\r\n//    internal val array:IntArray\r\n//    init{\r\n//        array = IntArray(n shl 2)\r\n//    }\r\n//    fun size():Int {\r\n//        return size(this.array)\r\n//    }\r\n//    /**\r\n//     * Main utility class - points to an index in the array\r\n//     * @param idx\r\n//     * @return\r\n//     */\r\n//    fun newIdx(idx:Int): Idx {\r\n//        return Idx(array).set(idx)\r\n//    }\r\n//    class Idx internal constructor(array: IntArray) {\r\n//        //dont make the field finals\r\n//        internal var idx: Int = 0\r\n//        internal var array: IntArray = array//keep ref. here, reduce the indirection\r\n//\r\n//        fun set(idx:Int): Idx {\r\n//            if (size(array) <= idx || idx < 0)\r\n//                throw IndexOutOfBoundsException((idx).toString())\r\n//            this.idx = idx shl 2\r\n//            return this\r\n//        }\r\n//        fun index(): Int {\r\n//            return idx shr 2\r\n//        }\r\n//        fun shl32(): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = 0\r\n//            return this\r\n//        }\r\n//        fun shr32(): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx + 3\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = 0\r\n//            return this\r\n//        }\r\n//        fun or(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            var idx2 = src.idx\r\n//            val array2 = src.array\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            return this\r\n//        }\r\n//        fun xor(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            var idx2 = src.idx\r\n//            val array2 = src.array\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            return this\r\n//        }\r\n//        fun add(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx + 3\r\n//            val array2 = src.array\r\n//            var idx2 = src.idx + 3\r\n//            var l: Long = 0\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong()\r\n//            array[idx] = (l and mask).toInt()\r\n//            // l>>>=32;\r\n//            return this\r\n//        }\r\n//        fun set(high:Long, low:Long): Idx {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            array[idx + 0] = ((high.ushr(32)) and mask).toInt()\r\n//            array[idx + 1] = ((high.ushr(0)) and mask).toInt()\r\n//            array[idx + 2] = ((low.ushr(32)) and mask).toInt()\r\n//            array[idx + 3] = ((low.ushr(0)) and mask).toInt()\r\n//            return this\r\n//        }\r\n//        fun high(): Long {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            val res = ((array[idx].toLong() and mask) shl 32) or (array[idx + 1].toLong() and mask)\r\n//            return res\r\n//        }\r\n//        fun low(): Long {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            val res = ((array[idx + 2].toLong() and mask) shl 32) or (array[idx + 3].toLong() and mask)\r\n//            return res\r\n//        }\r\n//        //ineffective but well\r\n//        public override fun toString():String {\r\n//            return String.format(\"0x%016x%016x\", high(), low())\r\n//        }\r\n//        companion object {\r\n//            private val mask = 0xFFFFFFFFL\r\n//        }\r\n//    }\r\n//    companion object {\r\n//        private fun size(array:IntArray):Int {\r\n//            return array.size shr 2\r\n//        }\r\n//        /**\r\n//         * allocates N 128bit elements. newIdx to create a pointer\r\n//         * @param n\r\n//         * @return\r\n//         */\r\n//        fun allocate(n:Int): DoubleQuadWord {\r\n//            return DoubleQuadWord(n)\r\n//        }\r\n//        @JvmStatic\r\n//        fun main(args:Array<String>) {\r\n//            val bitz = DoubleQuadWord.allocate(256)\r\n//            val idx = bitz.newIdx(0)\r\n//            val idx2 = bitz.newIdx(2)\r\n//            println(idx.set(0, 0xf))\r\n//            println(idx2.set(0, Long.MIN_VALUE).xor(idx))\r\n//            println(idx.set(0, Long.MAX_VALUE).add(idx2.set(0, 1)))\r\n//            println(\"==\")\r\n//            println(idx.add(idx))//can add itself\r\n//            println(idx.shl32())//left\r\n//            println(idx.shr32())//and right\r\n//            println(idx.shl32())//back left\r\n//            //w/ alloc\r\n//            println(idx.add(bitz.newIdx(4).set(0, Long.MAX_VALUE)))\r\n//            //self xor\r\n//            println(idx.xor(idx))\r\n//            //random xor\r\n//            println(\"===init random===\")\r\n//            val r = Random(1112)\r\n//            run({ var i = 0\r\n//                val s = bitz.size()\r\n//                while (i < s) {\r\n//                    idx.set(i).set(r.nextLong(), r.nextLong())\r\n//                    println(idx)\r\n//                    i++\r\n//                }})\r\n//            val theXor = bitz.newIdx(0)\r\n//            var i = 1\r\n//            val s = bitz.size()\r\n//            while (i < s)\r\n//            {\r\n//                theXor.xor(idx.set(i))\r\n//                i++\r\n//            }\r\n//            println(\"===XOR===\")\r\n//            println(theXor)\r\n//        }\r\n//    }\r\n// }","package venusbackend.numbers\r\n\r\nimport kotlin.math.sign\r\n\r\nclass QuadWord(var int0: Int = 0, var int1: Int = 0, var int2: Int = 0, var int3: Int = 0) : Number(), Comparable<QuadWord> {\r\n    companion object {\r\n        /**\r\n         * The number of bytes used to represent an instance of QuadWord in a binary form.\r\n         */\r\n        public const val SIZE_BYTES: Int = 16\r\n\r\n        /**\r\n         * The number of bits used to represent an instance of QuadWord in a binary form.\r\n         */\r\n        public const val SIZE_BITS: Int = 128\r\n        /**\r\n         * A constant holding the minimum value an instance of QuadWord can have.\r\n         */\r\n        public val MIN_VALUE: QuadWord = QuadWord(Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE)\r\n\r\n        /**\r\n         * A constant holding the maximum value an instance of QuadWord can have.\r\n         */\r\n        public val MAX_VALUE: QuadWord = QuadWord(Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE)\r\n    }\r\n\r\n    override fun compareTo(other: QuadWord): Int {\r\n        val int3comp = this.int3.compareTo(other.int3)\r\n        if (int3comp == 0) {\r\n            val int2comp = this.int2.compareTo(other.int2)\r\n            if (int2comp == 0) {\r\n                val int1comp = this.int1.compareTo(other.int1)\r\n                if (int1comp == 0) {\r\n                    return this.int0.compareTo(other.int0)\r\n                }\r\n                return int1comp\r\n            }\r\n            return int2comp\r\n        }\r\n        return int3comp\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Byte): Int {\r\n        return this.toByte().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Short): Int {\r\n        return this.toShort().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Int): Int {\r\n        return this.toInt().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Long): Int {\r\n        return this.toLong().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Float): Int {\r\n        return this.toFloat().compareTo(other)\r\n    }\r\n\r\n    /**\r\n     * Compares this value with the specified value for order.\r\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\r\n     * or a positive number if it's greater than other.\r\n     */\r\n    public operator fun compareTo(other: Double): Int {\r\n        return this.toDouble().compareTo(other)\r\n    }\r\n\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Byte): QuadWord {\r\n        return this.plus(other.toQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Short): QuadWord {\r\n        return this.plus(other.toQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Int): QuadWord {\r\n        return this.plus(other.toQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Long): QuadWord {\r\n        return this.plus(other.toQuadWord())\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Float): Float {\r\n        return this.toFloat() + other\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: Double): Double {\r\n        return this.toDouble() + other\r\n    }\r\n    /** Adds the other value to this value. */\r\n    public operator fun plus(other: QuadWord): QuadWord {\r\n        val long0 = this.int0.toLong() + other.int0.toLong()\r\n        val long1 = this.int1.toLong() + other.int1.toLong() + (long0 ushr 32)\r\n        val long2 = this.int2.toLong() + other.int2.toLong() + (long1 ushr 32)\r\n        val long3 = this.int3.toLong() + other.int3.toLong() + (long2 ushr 32)\r\n        return QuadWord(long0.toInt(), long1.toInt(), long2.toInt(), long3.toInt())\r\n    }\r\n\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Byte): QuadWord {\r\n        return this.minus(other.toQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Short): QuadWord {\r\n        return this.minus(other.toQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Int): QuadWord {\r\n        return this.minus(other.toQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Long): QuadWord {\r\n        return this.minus(other.toQuadWord())\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Float): Float {\r\n        return this.toFloat() - other\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: Double): Double {\r\n        return this.toDouble() - other\r\n    }\r\n    /** Subtracts the other value from this value. */\r\n    public operator fun minus(other: QuadWord): QuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Byte): QuadWord {\r\n        return this.times(other.toQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Short): QuadWord {\r\n        return this.times(other.toQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Int): QuadWord {\r\n        return this.times(other.toQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Long): QuadWord {\r\n        return this.times(other.toQuadWord())\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Float): Float {\r\n        return this.toFloat() * other\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: Double): Double {\r\n        return this.toDouble() * other\r\n    }\r\n    /** Multiplies this value by the other value. */\r\n    public operator fun times(other: QuadWord): QuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Byte): QuadWord {\r\n        return this.div(other.toQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Short): QuadWord {\r\n        return this.div(other.toQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Int): QuadWord {\r\n        return this.div(other.toQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Long): QuadWord {\r\n        return this.div(other.toQuadWord())\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Float): Float {\r\n        return this.toFloat() / other\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: Double): Double {\r\n        return this.toDouble() / other\r\n    }\r\n    /** Divides this value by the other value. */\r\n    public operator fun div(other: QuadWord): QuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Byte): QuadWord {\r\n        return this.rem(other.toQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Short): QuadWord {\r\n        return this.rem(other.toQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Int): QuadWord {\r\n        return this.rem(other.toQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Long): QuadWord {\r\n        return this.rem(other.toQuadWord())\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Float): Float {\r\n        return this.toFloat().rem(other)\r\n    }\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: Double): Double {\r\n        return this.toDouble().rem(other)\r\n    }\r\n\r\n    /** Calculates the remainder of dividing this value by the other value. */\r\n    public operator fun rem(other: QuadWord): QuadWord {\r\n        throw NotImplementedError()\r\n    }\r\n\r\n    /** Increments this value. */\r\n    public operator fun inc(): QuadWord {\r\n        return this.plus(1)\r\n    }\r\n    /** Decrements this value. */\r\n    public operator fun dec(): QuadWord {\r\n        return this.minus(1)\r\n    }\r\n    /** Returns this value. */\r\n    public operator fun unaryPlus(): QuadWord {\r\n        return this\r\n    }\r\n    /** Returns the negative of this value. */\r\n    public operator fun unaryMinus(): QuadWord {\r\n        return 0.toQuadWord() - this\r\n    }\r\n\r\n    /** Shifts this value left by the [bitCount] number of bits. */\r\n    public infix fun shl(bitCount: Int): QuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return QuadWord(0, 0, 0, 0)\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val msb0 = (qw.int0 shr 31)\r\n            val msb1 = (qw.int1 shr 31)\r\n            val msb2 = (qw.int2 shr 31)\r\n            qw.int0 = (qw.int0 shl 1)\r\n            qw.int1 = (qw.int1 shl 1) and msb0\r\n            qw.int2 = (qw.int2 shl 1) and msb1\r\n            qw.int3 = (qw.int2 shl 1) and msb2\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val msb0 = (qw.int0 shr 30)\r\n            val msb1 = (qw.int1 shr 30)\r\n            val msb2 = (qw.int2 shr 30)\r\n            qw.int0 = (qw.int0 shl 2)\r\n            qw.int1 = (qw.int1 shl 2) and msb0\r\n            qw.int2 = (qw.int2 shl 2) and msb1\r\n            qw.int3 = (qw.int2 shl 2) and msb2\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val msb0 = (qw.int0 shr 28)\r\n            val msb1 = (qw.int1 shr 28)\r\n            val msb2 = (qw.int2 shr 28)\r\n            qw.int0 = (qw.int0 shl 4)\r\n            qw.int1 = (qw.int1 shl 4) and msb0\r\n            qw.int2 = (qw.int2 shl 4) and msb1\r\n            qw.int3 = (qw.int2 shl 4) and msb2\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val msb0 = (qw.int0 shr 24)\r\n            val msb1 = (qw.int1 shr 24)\r\n            val msb2 = (qw.int2 shr 24)\r\n            qw.int0 = (qw.int0 shl 8)\r\n            qw.int1 = (qw.int1 shl 8) and msb0\r\n            qw.int2 = (qw.int2 shl 8) and msb1\r\n            qw.int3 = (qw.int2 shl 8) and msb2\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val msb0 = (qw.int0 shr 16)\r\n            val msb1 = (qw.int1 shr 16)\r\n            val msb2 = (qw.int2 shr 16)\r\n            qw.int0 = (qw.int0 shl 16)\r\n            qw.int1 = (qw.int1 shl 16) and msb0\r\n            qw.int2 = (qw.int2 shl 16) and msb1\r\n            qw.int3 = (qw.int2 shl 16) and msb2\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int3 = qw.int2\r\n            qw.int2 = qw.int1\r\n            qw.int1 = qw.int0\r\n            qw.int0 = 0\r\n        }\r\n        return qw\r\n    }\r\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with copies of the sign bit. */\r\n    public infix fun shr(bitCount: Int): QuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return if (this.int3.sign == -1) {\r\n                QuadWord(Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE, Int.MIN_VALUE)\r\n            } else {\r\n                QuadWord(0, 0, 0, 0)\r\n            }\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val lsb1 = (qw.int1 and 0x1) shl 31\r\n            val lsb2 = (qw.int2 and 0x1) shl 31\r\n            val lsb3 = (qw.int3 and 0x1) shl 31\r\n            qw.int0 = (qw.int0 shr 1) and lsb1\r\n            qw.int1 = (qw.int1 shr 1) and lsb2\r\n            qw.int2 = (qw.int2 shr 1) and lsb3\r\n            qw.int3 = (qw.int2 shr 1)\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11) shl 30\r\n            val lsb2 = (qw.int2 and 0b11) shl 30\r\n            val lsb3 = (qw.int3 and 0b11) shl 30\r\n            qw.int0 = (qw.int0 shr 2) and lsb1\r\n            qw.int1 = (qw.int1 shr 2) and lsb2\r\n            qw.int2 = (qw.int2 shr 2) and lsb3\r\n            qw.int3 = (qw.int2 shr 2)\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111) shl 28\r\n            val lsb2 = (qw.int2 and 0b1111) shl 28\r\n            val lsb3 = (qw.int3 and 0b1111) shl 28\r\n            qw.int0 = (qw.int0 shr 4) and lsb1\r\n            qw.int1 = (qw.int1 shr 4) and lsb2\r\n            qw.int2 = (qw.int2 shr 4) and lsb3\r\n            qw.int3 = (qw.int2 shr 4)\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11111111) shr 24\r\n            val lsb2 = (qw.int2 and 0b11111111) shr 24\r\n            val lsb3 = (qw.int3 and 0b11111111) shr 24\r\n            qw.int0 = (qw.int0 shr 8) and lsb1\r\n            qw.int1 = (qw.int1 shr 8) and lsb2\r\n            qw.int2 = (qw.int2 shr 8) and lsb3\r\n            qw.int3 = (qw.int2 shr 8)\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111111111111111) shr 16\r\n            val lsb2 = (qw.int2 and 0b1111111111111111) shr 16\r\n            val lsb3 = (qw.int3 and 0b1111111111111111) shr 16\r\n            qw.int0 = (qw.int0 shr 16) and lsb1\r\n            qw.int1 = (qw.int1 shr 16) and lsb2\r\n            qw.int2 = (qw.int2 shr 16) and lsb3\r\n            qw.int3 = (qw.int2 shr 16)\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int0 = qw.int1\r\n            qw.int1 = qw.int2\r\n            qw.int2 = qw.int3\r\n            qw.int3 = 0\r\n        }\r\n        return qw\r\n    }\r\n    /** Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros. */\r\n    public infix fun ushr(bitCount: Int): QuadWord {\r\n        val qw = this.copy()\r\n        if (bitCount >= 64) {\r\n            return QuadWord(0, 0, 0, 0)\r\n        }\r\n        if (bitCount and 0b1 == 1) {\r\n            val lsb1 = (qw.int1 and 0x1) shl 31\r\n            val lsb2 = (qw.int2 and 0x1) shl 31\r\n            val lsb3 = (qw.int3 and 0x1) shl 31\r\n            qw.int0 = (qw.int0 ushr 1) and lsb1\r\n            qw.int1 = (qw.int1 ushr 1) and lsb2\r\n            qw.int2 = (qw.int2 ushr 1) and lsb3\r\n            qw.int3 = (qw.int2 ushr 1)\r\n        }\r\n        if (bitCount % 2 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11) shl 30\r\n            val lsb2 = (qw.int2 and 0b11) shl 30\r\n            val lsb3 = (qw.int3 and 0b11) shl 30\r\n            qw.int0 = (qw.int0 ushr 2) and lsb1\r\n            qw.int1 = (qw.int1 ushr 2) and lsb2\r\n            qw.int2 = (qw.int2 ushr 2) and lsb3\r\n            qw.int3 = (qw.int2 ushr 2)\r\n        }\r\n        if (bitCount % 4 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111) shl 28\r\n            val lsb2 = (qw.int2 and 0b1111) shl 28\r\n            val lsb3 = (qw.int3 and 0b1111) shl 28\r\n            qw.int0 = (qw.int0 ushr 4) and lsb1\r\n            qw.int1 = (qw.int1 ushr 4) and lsb2\r\n            qw.int2 = (qw.int2 ushr 4) and lsb3\r\n            qw.int3 = (qw.int2 ushr 4)\r\n        }\r\n        if (bitCount % 8 == 0) {\r\n            val lsb1 = (qw.int1 and 0b11111111) shr 24\r\n            val lsb2 = (qw.int2 and 0b11111111) shr 24\r\n            val lsb3 = (qw.int3 and 0b11111111) shr 24\r\n            qw.int0 = (qw.int0 ushr 8) and lsb1\r\n            qw.int1 = (qw.int1 ushr 8) and lsb2\r\n            qw.int2 = (qw.int2 ushr 8) and lsb3\r\n            qw.int3 = (qw.int2 ushr 8)\r\n        }\r\n        if (bitCount % 16 == 0) {\r\n            val lsb1 = (qw.int1 and 0b1111111111111111) shr 16\r\n            val lsb2 = (qw.int2 and 0b1111111111111111) shr 16\r\n            val lsb3 = (qw.int3 and 0b1111111111111111) shr 16\r\n            qw.int0 = (qw.int0 ushr 16) and lsb1\r\n            qw.int1 = (qw.int1 ushr 16) and lsb2\r\n            qw.int2 = (qw.int2 ushr 16) and lsb3\r\n            qw.int3 = (qw.int2 ushr 16)\r\n        }\r\n        if (bitCount % 32 == 0) {\r\n            qw.int0 = qw.int1\r\n            qw.int1 = qw.int2\r\n            qw.int2 = qw.int3\r\n            qw.int3 = Int.MAX_VALUE\r\n        }\r\n        return qw\r\n    }\r\n    /** Performs a bitwise AND operation between the two values. */\r\n    public infix fun and(other: QuadWord): QuadWord {\r\n        val int0 = this.int0 and other.int0\r\n        val int1 = this.int1 and other.int1\r\n        val int2 = this.int2 and other.int2\r\n        val int3 = this.int3 and other.int3\r\n        return QuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Performs a bitwise OR operation between the two values. */\r\n    public infix fun or(other: QuadWord): QuadWord {\r\n        val int0 = this.int0 or other.int0\r\n        val int1 = this.int1 or other.int1\r\n        val int2 = this.int2 or other.int2\r\n        val int3 = this.int3 or other.int3\r\n        return QuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Performs a bitwise XOR operation between the two values. */\r\n    public infix fun xor(other: QuadWord): QuadWord {\r\n        val int0 = this.int0 xor other.int0\r\n        val int1 = this.int1 xor other.int1\r\n        val int2 = this.int2 xor other.int2\r\n        val int3 = this.int3 xor other.int3\r\n        return QuadWord(int0, int1, int2, int3)\r\n    }\r\n    /** Inverts the bits in this value. */\r\n    public fun inv(): QuadWord {\r\n        val int0 = this.int0.inv()\r\n        val int1 = this.int1.inv()\r\n        val int2 = this.int2.inv()\r\n        val int3 = this.int3.inv()\r\n        return QuadWord(int0, int1, int2, int3)\r\n    }\r\n\r\n    override fun toChar() = int0.toChar()\r\n    override fun toDouble() = this.toLong().toDouble()\r\n    override fun toFloat() = int0.toFloat()\r\n    override fun toInt() = int0\r\n    override fun toLong() = (int1.toLong() shl 32) or int0.toLong()\r\n    override fun toShort() = int0.toShort()\r\n    override fun toByte() = int0.toByte()\r\n\r\n    fun low(): Long {\r\n        return this.toLong()\r\n    }\r\n\r\n    fun high(): Long {\r\n        return (int3.toLong() shl 32) or int2.toLong()\r\n    }\r\n\r\n    public fun copy(): QuadWord {\r\n        return QuadWord(this.int0, this.int1, this.int2, this.int3)\r\n    }\r\n\r\n    override fun toString(): String {\r\n        throw NotImplementedError()\r\n//        return String.format(\"0x%016x%016x\", high(), low())\r\n    }\r\n}\r\n\r\nfun Number.toQuadWord(): QuadWord {\r\n    if (this is QuadWord) {\r\n        return this\r\n    }\r\n    if (this is Int) {\r\n        return this.toInt().toQuadWord()\r\n    }\r\n    if (this is Long) {\r\n        return this.toLong().toQuadWord()\r\n    }\r\n    if (this is Byte) {\r\n        return this.toByte().toQuadWord()\r\n    }\r\n    if (this is Short) {\r\n        return this.toShort().toQuadWord()\r\n    }\r\n    throw ClassCastException(\"Unknown number type!\")\r\n}\r\n\r\nfun Byte.toQuadWord(): QuadWord {\r\n    val num = this.toInt()\r\n    return if (num.sign == -1) {\r\n        QuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        QuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Short.toQuadWord(): QuadWord {\r\n    val num = this.toInt()\r\n    return if (num.sign == -1) {\r\n        QuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        QuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Int.toQuadWord(): QuadWord {\r\n    val num = this\r\n    return if (num.sign == -1) {\r\n        QuadWord(int0 = num, int1 = Int.MIN_VALUE, int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        QuadWord(int0 = num)\r\n    }\r\n}\r\n\r\nfun Long.toQuadWord(): QuadWord {\r\n    val num = this\r\n    return if (num.sign == -1) {\r\n        QuadWord(int0 = num.toInt(), int1 = (num shr 32).toInt(), int2 = Int.MIN_VALUE, int3 = Int.MIN_VALUE)\r\n    } else {\r\n        QuadWord(int0 = num.toInt(), int1 = (num shr 32).toInt())\r\n    }\r\n}\r\n\r\nfun Byte.toUQuadWord(): QuadWord {\r\n    return QuadWord(int0 = this.toInt())\r\n}\r\n\r\nfun Short.toUQuadWord(): QuadWord {\r\n    return QuadWord(int0 = this.toInt())\r\n}\r\n\r\nfun Int.toUQuadWord(): QuadWord {\r\n    return QuadWord(int0 = this)\r\n}\r\n\r\nfun Long.toUQuadWord(): QuadWord {\r\n    return QuadWord(int0 = this.toInt(), int1 = (this shr 32).toInt())\r\n}\r\n\r\noperator fun Int.minus(other: QuadWord): QuadWord {\r\n    return this.toQuadWord() - other\r\n}\r\n\r\n// import kotlin.random.Random\r\n//\r\n// class QuadWord private constructor(n: Int) {\r\n//    internal val array:IntArray\r\n//    init{\r\n//        array = IntArray(n shl 2)\r\n//    }\r\n//    fun size():Int {\r\n//        return size(this.array)\r\n//    }\r\n//    /**\r\n//     * Main utility class - points to an index in the array\r\n//     * @param idx\r\n//     * @return\r\n//     */\r\n//    fun newIdx(idx:Int): Idx {\r\n//        return Idx(array).set(idx)\r\n//    }\r\n//    class Idx internal constructor(array: IntArray) {\r\n//        //dont make the field finals\r\n//        internal var idx: Int = 0\r\n//        internal var array: IntArray = array//keep ref. here, reduce the indirection\r\n//\r\n//        fun set(idx:Int): Idx {\r\n//            if (size(array) <= idx || idx < 0)\r\n//                throw IndexOutOfBoundsException((idx).toString())\r\n//            this.idx = idx shl 2\r\n//            return this\r\n//        }\r\n//        fun index(): Int {\r\n//            return idx shr 2\r\n//        }\r\n//        fun shl32(): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = array[++idx]\r\n//            array[idx] = 0\r\n//            return this\r\n//        }\r\n//        fun shr32(): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx + 3\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = array[--idx]\r\n//            array[idx] = 0\r\n//            return this\r\n//        }\r\n//        fun or(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            var idx2 = src.idx\r\n//            val array2 = src.array\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            array[idx++] = array[idx++] or array2[idx2++]\r\n//            return this\r\n//        }\r\n//        fun xor(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx\r\n//            var idx2 = src.idx\r\n//            val array2 = src.array\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            array[idx++] = array[idx++] xor array2[idx2++]\r\n//            return this\r\n//        }\r\n//        fun add(src: Idx): Idx {\r\n//            val array = this.array\r\n//            var idx = this.idx + 3\r\n//            val array2 = src.array\r\n//            var idx2 = src.idx + 3\r\n//            var l: Long = 0\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong() and mask\r\n//            array[idx--] = (l and mask).toInt()\r\n//            l = l ushr 32\r\n//            l += array[idx].toLong() and mask\r\n//            l += array2[idx2--].toLong()\r\n//            array[idx] = (l and mask).toInt()\r\n//            // l>>>=32;\r\n//            return this\r\n//        }\r\n//        fun set(high:Long, low:Long): Idx {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            array[idx + 0] = ((high.ushr(32)) and mask).toInt()\r\n//            array[idx + 1] = ((high.ushr(0)) and mask).toInt()\r\n//            array[idx + 2] = ((low.ushr(32)) and mask).toInt()\r\n//            array[idx + 3] = ((low.ushr(0)) and mask).toInt()\r\n//            return this\r\n//        }\r\n//        fun high(): Long {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            val res = ((array[idx].toLong() and mask) shl 32) or (array[idx + 1].toLong() and mask)\r\n//            return res\r\n//        }\r\n//        fun low(): Long {\r\n//            val array = this.array\r\n//            val idx = this.idx\r\n//            val res = ((array[idx + 2].toLong() and mask) shl 32) or (array[idx + 3].toLong() and mask)\r\n//            return res\r\n//        }\r\n//        //ineffective but well\r\n//        public override fun toString():String {\r\n//            return String.format(\"0x%016x%016x\", high(), low())\r\n//        }\r\n//        companion object {\r\n//            private val mask = 0xFFFFFFFFL\r\n//        }\r\n//    }\r\n//    companion object {\r\n//        private fun size(array:IntArray):Int {\r\n//            return array.size shr 2\r\n//        }\r\n//        /**\r\n//         * allocates N 128bit elements. newIdx to create a pointer\r\n//         * @param n\r\n//         * @return\r\n//         */\r\n//        fun allocate(n:Int): QuadWord {\r\n//            return QuadWord(n)\r\n//        }\r\n//        @JvmStatic\r\n//        fun main(args:Array<String>) {\r\n//            val bitz = QuadWord.allocate(256)\r\n//            val idx = bitz.newIdx(0)\r\n//            val idx2 = bitz.newIdx(2)\r\n//            println(idx.set(0, 0xf))\r\n//            println(idx2.set(0, Long.MIN_VALUE).xor(idx))\r\n//            println(idx.set(0, Long.MAX_VALUE).add(idx2.set(0, 1)))\r\n//            println(\"==\")\r\n//            println(idx.add(idx))//can add itself\r\n//            println(idx.shl32())//left\r\n//            println(idx.shr32())//and right\r\n//            println(idx.shl32())//back left\r\n//            //w/ alloc\r\n//            println(idx.add(bitz.newIdx(4).set(0, Long.MAX_VALUE)))\r\n//            //self xor\r\n//            println(idx.xor(idx))\r\n//            //random xor\r\n//            println(\"===init random===\")\r\n//            val r = Random(1112)\r\n//            run({ var i = 0\r\n//                val s = bitz.size()\r\n//                while (i < s) {\r\n//                    idx.set(i).set(r.nextLong(), r.nextLong())\r\n//                    println(idx)\r\n//                    i++\r\n//                }})\r\n//            val theXor = bitz.newIdx(0)\r\n//            var i = 1\r\n//            val s = bitz.size()\r\n//            while (i < s)\r\n//            {\r\n//                theXor.xor(idx.set(i))\r\n//                i++\r\n//            }\r\n//            println(\"===XOR===\")\r\n//            println(theXor)\r\n//        }\r\n//    }\r\n// }","package venusbackend\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toQuadWord\r\n\r\noperator fun Number.plus(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).plus(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).plus(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).plus(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).plus(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).plus(other.toQuadWord()))\r\n    }\r\n}\r\n\r\noperator fun Number.minus(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).minus(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).minus(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).minus(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).minus(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).minus(other.toQuadWord()))\r\n    }\r\n}\r\n\r\noperator fun Number.times(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).times(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).times(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).times(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).times(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).times(other.toQuadWord()))\r\n    }\r\n}\r\n\r\noperator fun Number.div(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).div(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).div(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).div(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).div(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).div(other.toQuadWord()))\r\n    }\r\n}\r\n\r\noperator fun Number.inc(): Number {\r\n    return if ((this is QuadWord)) {\r\n        (this.toQuadWord()).inc()\r\n    } else if ((this is Long)) {\r\n        ((this.toLong()).inc())\r\n    } else if ((this is Int)) {\r\n        ((this.toInt()).inc())\r\n    } else if ((this is Short)) {\r\n        ((this.toShort()).inc()) as Number\r\n    } else {\r\n        ((this.toQuadWord()).inc())\r\n    }\r\n}\r\n\r\noperator fun Number.compareTo(other: Number): Int {\r\n    return if ((this is QuadWord)) {\r\n        ((this.toQuadWord()).compareTo(other.toQuadWord()))\r\n    } else if ((this is Long)) {\r\n        ((this.toLong()).compareTo(other.toLong()))\r\n    } else if ((this is Int)) {\r\n        ((this.toInt()).compareTo(other.toInt()))\r\n    } else if ((this is Short)) {\r\n        ((this.toShort()).compareTo(other.toShort()))\r\n    } else {\r\n        ((this.toQuadWord()).compareTo(other.toQuadWord()))\r\n    }\r\n}\r\n\r\ninfix fun Number.shr(other: Number): Number {\r\n    return if ((this is QuadWord)) {\r\n        (this.toQuadWord()).shr(other.toInt())\r\n    } else if ((this is Long)) {\r\n        ((this.toLong()).shr(other.toInt()))\r\n    } else if ((this is Int)) {\r\n        ((this.toInt()).shr(other.toInt()))\r\n    } else if ((this is Short)) {\r\n        ((this.toInt()).shr(other.toInt())).toShort() as Number\r\n    } else {\r\n        ((this.toQuadWord()).shr(other.toInt()))\r\n    }\r\n}\r\n\r\ninfix fun Number.ushr(other: Number): Number {\r\n    return if ((this is QuadWord)) {\r\n        (this.toQuadWord()).ushr(other.toInt())\r\n    } else if ((this is Long)) {\r\n        ((this.toLong()).ushr(other.toInt()))\r\n    } else if ((this is Int)) {\r\n        ((this.toInt()).ushr(other.toInt()))\r\n    } else if ((this is Short)) {\r\n        ((this.toInt()).ushr(other.toInt())).toShort() as Number\r\n    } else {\r\n        ((this.toQuadWord()).ushr(other.toInt()))\r\n    }\r\n}\r\n\r\ninfix fun Number.shl(other: Number): Number {\r\n    return if ((this is QuadWord)) {\r\n        (this.toQuadWord()).shl(other.toInt())\r\n    } else if ((this is Long)) {\r\n        ((this.toLong()).shl(other.toInt()))\r\n    } else if ((this is Int)) {\r\n        ((this.toInt()).shl(other.toInt()))\r\n    } else if ((this is Short)) {\r\n        ((this.toInt()).shl(other.toInt())).toShort() as Number\r\n    } else {\r\n        ((this.toQuadWord()).shl(other.toInt()))\r\n    }\r\n}\r\n\r\noperator fun Number.rem(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).rem(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).rem(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).rem(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).rem(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).rem(other.toQuadWord()))\r\n    }\r\n}\r\n\r\ninfix fun Number.and(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).and(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).and(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).and(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toShort()).and(other.toShort())) as Number\r\n    } else {\r\n        ((this.toQuadWord()).and(other.toQuadWord()))\r\n    }\r\n}\r\n\r\ninfix fun Number.or(other: Number): Number {\r\n    return if ((this is QuadWord) or (other is QuadWord)) {\r\n        ((this.toQuadWord()).or(other.toQuadWord()))\r\n    } else if ((this is Long) or (other is Long)) {\r\n        ((this.toLong()).or(other.toLong()))\r\n    } else if ((this is Int) or (other is Int)) {\r\n        ((this.toInt()).or(other.toInt()))\r\n    } else if ((this is Short) or (other is Short)) {\r\n        ((this.toInt()).or(other.toInt())).toShort() as Number\r\n    } else {\r\n        ((this.toQuadWord()).or(other.toQuadWord()))\r\n    }\r\n}","package venusbackend.riscv\r\n\r\nclass Address(a: Number, s: MemSize) {\r\n    val size = s\r\n    val address = a\r\n}","package venusbackend.riscv\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.riscv.insts.floating.double.i.fld\r\nimport venusbackend.riscv.insts.floating.double.r.*\r\nimport venusbackend.riscv.insts.floating.double.s.fsd\r\nimport venusbackend.riscv.insts.floating.fcvtds\r\nimport venusbackend.riscv.insts.floating.fcvtsd\r\nimport venusbackend.riscv.insts.floating.single.i.flw\r\nimport venusbackend.riscv.insts.floating.single.r.*\r\nimport venusbackend.riscv.insts.floating.single.s.fsw\r\nimport venusbackend.riscv.insts.integer.base.i.*\r\nimport venusbackend.riscv.insts.integer.base.i.ecall.ecall\r\nimport venusbackend.riscv.insts.integer.base.r.*\r\nimport venusbackend.riscv.insts.integer.base.sb.*\r\nimport venusbackend.riscv.insts.integer.base.s.*\r\nimport venusbackend.riscv.insts.integer.base.u.*\r\nimport venusbackend.riscv.insts.integer.base.uj.*\r\nimport venusbackend.riscv.insts.integer.extensions.atomic.r.*\r\nimport venusbackend.riscv.insts.integer.extensions.compressed.ca.*\r\nimport venusbackend.riscv.insts.integer.extensions.compressed.cr.*\r\nimport venusbackend.riscv.insts.integer.extensions.multiply.r.*\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\nclass InitInstructions {\r\n    companion object {\r\n        var inited = false\r\n    }\r\n    init {\r\n        if (!inited) {\r\n            addi\r\n            addiw\r\n            andi\r\n            csrrc\r\n            csrrci\r\n            csrrw\r\n            csrrwi\r\n            ebreak\r\n            ecall\r\n            fence\r\n            fencei\r\n            jalr\r\n            lb\r\n            lbu\r\n            ld\r\n            lh\r\n            lhu\r\n            lw\r\n//            lwu\r\n            ori\r\n            slli\r\n            slliw\r\n            slti\r\n            sltiu\r\n            srai\r\n            sraiw\r\n            srli\r\n            srliw\r\n            xori\r\n            add\r\n            addw\r\n            and\r\n            or\r\n            sll\r\n            sllw\r\n            slt\r\n            sltu\r\n            sra\r\n            sraw\r\n            srl\r\n            srlw\r\n            sub\r\n            subw\r\n            xor\r\n            sb\r\n            sd\r\n            sh\r\n            sw\r\n            beq\r\n            bge\r\n            bgeu\r\n            blt\r\n            bltu\r\n            bne\r\n            auipc\r\n            lui\r\n            jal\r\n            amoaddw\r\n            amoandw\r\n            amomaxw\r\n            amomaxuw\r\n            amominw\r\n            amominuw\r\n            amoorw\r\n            amoswapw\r\n            amoxorw\r\n            lrw\r\n            scw\r\n            div\r\n            divu\r\n//            divw\r\n            mul\r\n            mulh\r\n            mulhsu\r\n            mulhu\r\n//            mulw\r\n            rem\r\n            remu\r\n//            remuw\r\n//            remw\r\n            fld\r\n            faddd\r\n            fclassd\r\n            fcvtdw\r\n            fcvtdwu\r\n            fcvtwd\r\n            fcvtwud\r\n            feqd\r\n            fled\r\n            fltd\r\n            fmaddd\r\n            fmaxd\r\n            fmind\r\n            fmsubd\r\n            fmuld\r\n            fmvdx\r\n            fmvxd\r\n            fnmaddd\r\n            fnmsubd\r\n            fsgnjd\r\n            fsgnjnd\r\n            fsgnjxd\r\n            fsqrtd\r\n            fsubd\r\n            fsd\r\n            flw\r\n            fadds\r\n            fclasss\r\n            fcvtsw\r\n            fcvtswu\r\n            fcvtws\r\n            fcvtwus\r\n            fdivs\r\n            feqs\r\n            fles\r\n            flts\r\n            fmadds\r\n            fmaxs\r\n            fmins\r\n            fmsubs\r\n            fmuls\r\n            fmvsx\r\n            fmvxs\r\n            fnmadds\r\n            fnmsubs\r\n            fsgnjs\r\n            fsgnjns\r\n            fsgnjxs\r\n            fsqrts\r\n            fsubs\r\n            fsw\r\n            fcvtds\r\n            fcvtsd\r\n            caddw\r\n            cand\r\n            cor\r\n            csub\r\n            csubw\r\n            cxor\r\n            cadd\r\n            cebreak\r\n            cmv\r\n            inited = true\r\n        }\r\n    }\r\n}","package venusbackend.riscv\r\n\r\n/** Describes how to get fields from RV16/32/64 instruction formats */\r\nenum class InstructionField(val lo: Int, val hi: Int) {\r\n    ENTIRE(0, 32),\r\n    HALF(0, 16),\r\n    OPCODE(0, 7),\r\n    OP2(0, 2),\r\n    RD(7, 12),\r\n    RS2P(2, 5),\r\n    CRS2(2, 7),\r\n    FUNCT3(12, 15),\r\n    CFUNCT3(13, 16),\r\n    FUNCT2(25, 27),\r\n    CFUNCT2(5, 7),\r\n    FUNCT(5, 7),\r\n    FUNCT6(10, 16),\r\n    FUNCT4(12, 16),\r\n    WIDTH(12, 15),\r\n    RS1P(7, 10),\r\n    RDP(7, 10),\r\n    RS1(15, 20),\r\n    RS2(20, 25),\r\n    RS3(27, 32),\r\n    FUNCT7(25, 32),\r\n    FUNCT5(27, 32),\r\n    RL(25, 26),\r\n    AQ(26, 27),\r\n    IMM_b2_b6(2, 7),\r\n    IMM_b12(12, 13),\r\n    IMM_11_0(20, 32),\r\n    IMM_4_0(7, 12),\r\n    IMM_11_5(25, 32),\r\n    IMM_11_B(7, 8),\r\n    IMM_4_1(8, 12),\r\n    IMM_10_5(25, 31),\r\n    IMM_12(31, 32),\r\n    IMM_12_2(2, 13),\r\n    IMM_31_12(12, 32),\r\n    IMM_19_12(12, 20),\r\n    IMM_11_J(20, 21),\r\n    IMM_10_1(21, 31),\r\n    IMM_20(31, 32),\r\n    SHAMT(20, 25),\r\n}","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.constructBranchImmediate\r\n\r\nobject BTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        val imm = constructBranchImmediate(mcode)\r\n        return \"$name x$rs1 x$rs2 $imm\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\n\r\nobject ITypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        return \"$name x$rd x$rs1 $imm\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\n\r\nobject LoadDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rd = mcode[InstructionField.RD]\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        return \"$name x$rd $imm(x$rs1)\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject RTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        return \"$name x$rd x$rs1 x$rs2\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject ShiftImmediateDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val shamt = mcode[InstructionField.SHAMT]\r\n        return \"$name x$rd x$rs1 $shamt\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.constructStoreImmediate\r\n\r\nobject STypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        val imm = constructStoreImmediate(mcode)\r\n        return \"$name x$rs2 $imm(x$rs1)\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject UTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val imm = mcode[InstructionField.IMM_31_12]\r\n        return \"$name x$rd $imm\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.extensions.atomic\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject AMORTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        return \"$name x$rd x$rs2 (x$rs1)\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.extensions.compressed\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject CATypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RDP] + 8\r\n        val rs2 = mcode[InstructionField.RS2P] + 8\r\n        return \"$name x$rd x$rs2\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.extensions.compressed\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\nobject CRTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs2 = mcode[InstructionField.CRS2]\r\n        return \"$name x$rd x$rs2\"\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FFRRTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        return \"$name x$rd f$rs1 f$rs2\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FITypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        return \"$name f$rd $imm(x$rs1)\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FR4TypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        val rs3 = mcode[InstructionField.RS3]\r\n        return \"$name f$rd f$rs1 f$rs2 f$rs3\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FRRTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        return \"$name x$rd f$rs1\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FRTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        return \"$name f$rd f$rs1 f$rs2\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.constructStoreImmediate\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\n\r\nobject FSTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        val rs2 = mcode[InstructionField.RS2]\r\n        val imm = constructStoreImmediate(mcode)\r\n        return \"$name f$rs2 $imm(x$rs1)\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject RFRTypeDisassembler : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String {\r\n        val name = Instruction[mcode].name\r\n        val rd = mcode[InstructionField.RD]\r\n        val rs1 = mcode[InstructionField.RS1]\r\n        return \"$name f$rd x$rs1\"\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.disasms\r\n\r\nimport venusbackend.riscv.MachineCode\r\n\r\nclass RawDisassembler(private val disasm: (MachineCode) -> String) : InstructionDisassembler {\r\n    override fun invoke(mcode: MachineCode): String = disasm(mcode)\r\n}\r\n","package venusbackend.riscv.insts.dsl.formats.base\r\n\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeFunct3Format\r\n\r\nclass BTypeFormat(opcode: Int, funct3: Int) : OpcodeFunct3Format(opcode, funct3)\r\n","package venusbackend.riscv.insts.dsl.formats.base\r\n\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeFunct3Format\r\n\r\nclass ITypeFormat(opcode: Int, funct3: Int) : OpcodeFunct3Format(opcode, funct3)\r\n","package venusbackend.riscv.insts.dsl.formats.base\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\nclass RTypeFormat(opcode: Int, funct3: Int, funct7: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        FieldEqual(InstructionField.FUNCT3, funct3),\r\n        FieldEqual(InstructionField.FUNCT7, funct7)\r\n))\r\n","package venusbackend.riscv.insts.dsl.formats.base\r\n\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeFunct3Format\r\n\r\nclass STypeFormat(opcode: Int, funct3: Int) : OpcodeFunct3Format(opcode, funct3)\r\n","package venusbackend.riscv.insts.dsl.formats.base\r\n\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeFormat\r\n\r\nclass UTypeFormat(opcode: Int) : OpcodeFormat(opcode)\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.atomic\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\nclass AMORTypeFormat(opcode: Int, funct3: Int, funct5: Int, aq: Int, rl: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        FieldEqual(InstructionField.FUNCT3, funct3),\r\n        FieldEqual(InstructionField.FUNCT5, funct5),\r\n        FieldEqual(InstructionField.AQ, aq),\r\n        FieldEqual(InstructionField.RL, rl)\r\n))\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.compressed\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\nclass CATypeFormat(opcode2: Int, funct2: Int, funct6: Int) : InstructionFormat(2, listOf(\r\n                FieldEqual(InstructionField.OP2, opcode2),\r\n                FieldEqual(InstructionField.CFUNCT2, funct2),\r\n                FieldEqual(InstructionField.FUNCT6, funct6)\r\n        )\r\n)\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.compressed\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\nclass CRTypeFormat(opcode2: Int, funct4: Int, regComp: Array<FieldEqual>) : InstructionFormat(2, arrayOf(\r\n        arrayOf(\r\n            FieldEqual(InstructionField.OP2, opcode2),\r\n            FieldEqual(InstructionField.FUNCT4, funct4)\r\n        ),\r\n        regComp\r\n).flatten())\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FRTypeFormat(opcode: Int, funct7: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        FieldEqual(InstructionField.FUNCT7, funct7)\r\n))\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\nclass FSRS2TypeFormat(opcode: Int, funct7: Int, rs2: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        FieldEqual(InstructionField.RS2, rs2),\r\n        FieldEqual(InstructionField.FUNCT7, funct7)\r\n))\r\n","package venusbackend.riscv.insts.dsl.formats.extensions.floating\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass R4TypeFormat(opcode: Int, funct2: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        // FieldEqual(InstructionField.FUNCT3, funct3),\r\n        FieldEqual(InstructionField.FUNCT2, funct2)\r\n))","package venusbackend.riscv.insts.dsl.formats\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\ndata class FieldEqual(val ifield: InstructionField, val required: Int, val not: Boolean = false, val oifields: List<InstructionField> = listOf())\r\n\r\nopen class InstructionFormat(val length: Int, val ifields: List<FieldEqual>) {\r\n    fun matches(mcode: MachineCode): Boolean = ifields.all {\r\n        (ifield, required, bool, oifields) -> if (bool) {\r\n//            mcode[ifield].toInt() != required\r\n            var res = mcode[ifield].toInt() != required\r\n            for (ifild in oifields) {\r\n                res = res and (mcode[ifield].toInt() != required)\r\n            }\r\n            res\r\n        } else {\r\n//            mcode[ifield].toInt() == required\r\n            var res = mcode[ifield].toInt() == required\r\n            for (ifild in oifields) {\r\n                res = res and (mcode[ifield].toInt() == required)\r\n            }\r\n            res\r\n        }\r\n    }\r\n\r\n    fun fill(): MachineCode {\r\n        val mcode = MachineCode(0)\r\n        mcode.length = length\r\n        for ((ifield, required) in ifields) {\r\n            mcode[ifield] = required\r\n        }\r\n        return mcode\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.formats\r\n\r\nimport venusbackend.riscv.InstructionField\r\n\r\nopen class OpcodeCFunct3Format(opcode: Int, cfunct3: Int, regComp: Array<FieldEqual>) : InstructionFormat(2, arrayOf(\r\n        arrayOf(\r\n            FieldEqual(InstructionField.OPCODE, opcode),\r\n            FieldEqual(InstructionField.CFUNCT3, cfunct3)\r\n        ),\r\n        regComp\r\n    ).flatten()\r\n)\r\n","package venusbackend.riscv.insts.dsl.formats\r\n\r\nimport venusbackend.riscv.InstructionField\r\n\r\nopen class OpcodeFormat(opcode: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode)\r\n))\r\n","package venusbackend.riscv.insts.dsl.formats\r\n\r\nimport venusbackend.riscv.InstructionField\r\n\r\nopen class OpcodeFunct3Format(opcode: Int, funct3: Int) : InstructionFormat(4, listOf(\r\n        FieldEqual(InstructionField.OPCODE, opcode),\r\n        FieldEqual(InstructionField.FUNCT3, funct3)\r\n))\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass BTypeImplementation32(private val cond: (Int, Int) -> Boolean) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1: Int = mcode[InstructionField.RS1].toInt()\r\n        val rs2: Int = mcode[InstructionField.RS2].toInt()\r\n        val imm: Int = constructBranchImmediate(mcode)\r\n        val vrs1: Int = sim.getReg(rs1).toInt()\r\n        val vrs2: Int = sim.getReg(rs2).toInt()\r\n        if (cond(vrs1, vrs2)) {\r\n            sim.branched = true\r\n            sim.incrementPC(imm)\r\n        } else {\r\n            sim.incrementPC(mcode.length)\r\n        }\r\n    }\r\n}\r\n\r\nfun constructBranchImmediate(mcode: MachineCode): Int {\r\n    val imm_11 = mcode[InstructionField.IMM_11_B].toInt()\r\n    val imm_4_1 = mcode[InstructionField.IMM_4_1].toInt()\r\n    val imm_10_5 = mcode[InstructionField.IMM_10_5].toInt()\r\n    val imm_12 = mcode[InstructionField.IMM_12].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_11, 11, 12)\r\n    imm = setBitslice(imm, imm_4_1, 1, 5)\r\n    imm = setBitslice(imm, imm_10_5, 5, 11)\r\n    imm = setBitslice(imm, imm_12, 12, 13)\r\n    return signExtend(imm, 13)\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass ITypeImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1: Int = mcode[InstructionField.RS1].toInt()\r\n        val imm: Int = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        val rd: Int = mcode[InstructionField.RD].toInt()\r\n        val vrs1: Int = sim.getReg(rs1).toInt()\r\n        sim.setReg(rd, eval(vrs1, imm))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass LoadImplementation32(\r\n    private val load: (Simulator, Int) -> Int,\r\n    private val postLoad: (Int) -> Int\r\n) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        sim.setReg(rd, postLoad(load(sim, vrs1 + imm)))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass RTypeImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val vrs2 = sim.getReg(rs2).toInt()\r\n        sim.setReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass ShiftImmediateImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val shamt = mcode[InstructionField.SHAMT].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        sim.setReg(rd, eval(vrs1, shamt))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass STypeImplementation32(private val store: (Simulator, Int, Int) -> Unit) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val imm = constructStoreImmediate(mcode)\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val vrs2 = sim.getReg(rs2).toInt()\r\n        store(sim, vrs1 + imm, vrs2)\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n\r\nfun constructStoreImmediate(mcode: MachineCode): Int {\r\n    val imm_11_5 = mcode[InstructionField.IMM_11_5].toInt()\r\n    val imm_4_0 = mcode[InstructionField.IMM_4_0].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_11_5, 5, 12)\r\n    imm = setBitslice(imm, imm_4_0, 0, 5)\r\n    return signExtend(imm, 12)\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass BTypeImplementation64(private val cond: (Long, Long) -> Boolean) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1: Int = mcode[InstructionField.RS1].toInt()\r\n        val rs2: Int = mcode[InstructionField.RS2].toInt()\r\n        val imm: Long = constructBranchImmediate64(mcode)\r\n        val vrs1: Long = sim.getReg(rs1).toLong()\r\n        val vrs2: Long = sim.getReg(rs2).toLong()\r\n        if (cond(vrs1, vrs2)) {\r\n            sim.branched = true\r\n            sim.incrementPC(imm)\r\n        } else {\r\n            sim.incrementPC(mcode.length)\r\n        }\r\n    }\r\n}\r\n\r\nfun constructBranchImmediate64(mcode: MachineCode): Long {\r\n    val imm_11 = mcode[InstructionField.IMM_11_B].toInt()\r\n    val imm_4_1 = mcode[InstructionField.IMM_4_1].toInt()\r\n    val imm_10_5 = mcode[InstructionField.IMM_10_5].toInt()\r\n    val imm_12 = mcode[InstructionField.IMM_12].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_11, 11, 12)\r\n    imm = setBitslice(imm, imm_4_1, 1, 5)\r\n    imm = setBitslice(imm, imm_10_5, 5, 11)\r\n    imm = setBitslice(imm, imm_12, 12, 13)\r\n    return signExtend(imm, 13).toLong()\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass ITypeImplementation64(private val eval: (Long, Long) -> Long) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1: Int = mcode[InstructionField.RS1].toInt()\r\n        val imm: Long = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12).toLong()\r\n        val rd: Int = mcode[InstructionField.RD].toInt()\r\n        val vrs1: Long = sim.getReg(rs1).toLong()\r\n        sim.setReg(rd, eval(vrs1, imm))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass LoadImplementation64(\r\n    private val load: (Simulator, Long) -> Long,\r\n    private val postLoad: (Long) -> Long\r\n) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toLong()\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12).toLong()\r\n        sim.setReg(rd, postLoad(load(sim, vrs1 + imm)))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass RTypeImplementation64(private val eval: (Long, Long) -> Long) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toLong()\r\n        val vrs2 = sim.getReg(rs2).toLong()\r\n        sim.setReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass ShiftImmediateImplementation64(private val eval: (Long, Long) -> Long) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val shamt = mcode[InstructionField.SHAMT].toLong()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toLong()\r\n        sim.setReg(rd, eval(vrs1, shamt))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.base.b64\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass STypeImplementation64(private val store: (Simulator, Long, Long) -> Unit) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val imm = constructStoreImmediate64(mcode)\r\n        val vrs1 = sim.getReg(rs1).toLong()\r\n        val vrs2 = sim.getReg(rs2).toLong()\r\n        store(sim, vrs1 + imm, vrs2)\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n\r\nfun constructStoreImmediate64(mcode: MachineCode): Long {\r\n    val imm_11_5 = mcode[InstructionField.IMM_11_5].toInt()\r\n    val imm_4_0 = mcode[InstructionField.IMM_4_0].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_11_5, 5, 12)\r\n    imm = setBitslice(imm, imm_4_0, 0, 5)\r\n    return signExtend(imm, 12).toLong()\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.extensions.atomic.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass AMORTypeImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val vrs2 = sim.getReg(rs2).toInt()\r\n\r\n        val data = sim.loadWordwCache(vrs1)\r\n        sim.setReg(rd, data)\r\n        sim.storeWordwCache(vrs1, eval(data, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.compressed.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass CATypeImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs2 = mcode[InstructionField.RS2P].toInt() + 8 // We only use registers x8 to x15\r\n        val rd = mcode[InstructionField.RDP].toInt() + 8\r\n        val vrs1 = sim.getReg(rd).toInt()\r\n        val vrs2 = sim.getReg(rs2).toInt()\r\n\r\n        sim.setReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.compressed.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass CRTypeImplementation32(private val eval: (Int, Int) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs2 = mcode[InstructionField.CRS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rd).toInt()\r\n        val vrs2 = sim.getReg(rs2).toInt()\r\n\r\n        sim.setReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FFRRTypeImplementation32(private val eval: (Decimal, Decimal) -> Int) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getFReg(rs1)\r\n        val vrs2 = sim.getFReg(rs2)\r\n        sim.setReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FITypeImplementation32(private val eval: (Int, Simulator) -> Decimal) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n        sim.setFReg(rd, eval(vrs1 + imm, sim))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FR4TypeImplementation32(private val eval: (Decimal, Decimal, Decimal) -> Decimal) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rs3 = mcode[InstructionField.RS3].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getFReg(rs1)\r\n        val vrs2 = sim.getFReg(rs2)\r\n        val vrs3 = sim.getFReg(rs3)\r\n        sim.setFReg(rd, eval(vrs1, vrs2, vrs3))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FRTypeImplementation32(private val eval: (Decimal, Decimal) -> Decimal) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getFReg(rs1)\r\n        val vrs2 = sim.getFReg(rs2)\r\n        sim.setFReg(rd, eval(vrs1, vrs2))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FSTypeImplementation32(private val store: (Simulator, Int, Decimal) -> Unit) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rs2 = mcode[InstructionField.RS2].toInt()\r\n        val imm = constructStoreImmediate(mcode)\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        val vrs2 = sim.getFReg(rs2)\r\n        store(sim, vrs1 + imm, vrs2)\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}\r\n\r\nfun constructStoreImmediate(mcode: MachineCode): Int {\r\n    val imm_11_5 = mcode[InstructionField.IMM_11_5].toInt()\r\n    val imm_4_0 = mcode[InstructionField.IMM_4_0].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_11_5, 5, 12)\r\n    imm = setBitslice(imm, imm_4_0, 0, 5)\r\n    return signExtend(imm, 12)\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls.extensions.floating.b32\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass RtFTypeImplementation32(private val eval: (Int) -> Decimal) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) {\r\n        val rs1 = mcode[InstructionField.RS1].toInt()\r\n        val rd = mcode[InstructionField.RD].toInt()\r\n        val vrs1 = sim.getReg(rs1).toInt()\r\n        sim.setFReg(rd, eval(vrs1))\r\n        sim.incrementPC(mcode.length)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.impls\r\n\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.simulator.Simulator\r\n\r\nobject NoImplementation : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) =\r\n            throw NotImplementedError(\"no implementation available\")\r\n}\r\n","package venusbackend.riscv.insts.dsl.impls\r\n\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass RawImplementation(private val eval: (MachineCode, Simulator) -> Unit) : InstructionImplementation {\r\n    override operator fun invoke(mcode: MachineCode, sim: Simulator) = eval(mcode, sim)\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.dsl.getImmWarning\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\nobject BTypeParser : InstructionParser {\r\n    const val B_TYPE_MIN = -2048\r\n    const val B_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[1], dbg = dbg)\r\n\r\n        val label = args[2]\r\n        var imm: Int? = null\r\n        try {\r\n            imm = prog.getLabelOffset(label, prog.textSize, dbg)\r\n                    ?: throw AssemblerError(\"could not find label $label\", dbg)\r\n        } catch (e: AssemblerError) {\r\n            try {\r\n                imm = prog.getLabelOffset(venusInternalLabels + (userStringToInt(label) + prog.textSize), prog.textSize, dbg)\r\n                getImmWarning += \"Interpreting the label as an offset!; \"\r\n            } catch (e2: Throwable) {\r\n                throw e\r\n            }\r\n        }\r\n\r\n        if (imm !in B_TYPE_MIN..B_TYPE_MAX) {\r\n            getImmWarning = getImmWarning.replace(\"Interpreting the label as an offset!; \", \"\")\r\n            throw AssemblerError(\"branch to $label too far\", dbg)\r\n        }\r\n\r\n        mcode[InstructionField.IMM_11_B] = imm !! shr 11\r\n        mcode[InstructionField.IMM_4_1] = imm shr 1\r\n        mcode[InstructionField.IMM_12] = imm shr 12\r\n        mcode[InstructionField.IMM_10_5] = imm shr 5\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.toInt(), last.toInt() + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject CSRTypeParser : InstructionParser {\r\n    const val I_TYPE_MIN = -2048\r\n    const val I_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.IMM_11_0] = getImmediate(args[1], CSRTypeParser.I_TYPE_MIN, CSRTypeParser.I_TYPE_MAX, dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\nimport venusbackend.riscv.insts.dsl.relocators.ImmAbsRelocator\r\nimport venusbackend.riscv.isNumeral\r\n\r\nobject ITypeParser : InstructionParser {\r\n    const val I_TYPE_MIN = -2048\r\n    const val I_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        val real_line = dbg.line.split(Regex(\"#\")).firstOrNull()\r\n        // Do not need to check of other paren because the lexer will ensure no mismatch.\r\n        if (real_line != null && real_line.contains(Regex(\"[(]\"))) {\r\n            throw AssemblerError(\"I-Type Instructions should not be in Displaced Notation!\", dbg)\r\n        }\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], dbg = dbg)\r\n        if (isNumeral(args[2])) {\r\n            mcode[InstructionField.IMM_11_0] =\r\n                    prog.getImmediate(args[2], I_TYPE_MIN, I_TYPE_MAX, dbg)\r\n        } else {\r\n            prog.addRelocation(\r\n                    ImmAbsRelocator, prog.symbolPart(args[2], dbg),\r\n                    prog.labelOffsetPart(args[2], dbg), dbg = dbg)\r\n        }\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject LoadParser : InstructionParser {\r\n    const val I_TYPE_MIN = -2048\r\n    const val I_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n//        val real_line = dbg.line.split(Regex(\"#\")).firstOrNull()\r\n//        if (real_line == null) {\r\n//            AssemblerError(\"A dbg line was passed in but contained not code!\")\r\n//        }\r\n//        // Do not need to check of other paren because the lexer will ensure no mismatch.\r\n//        val numParen = real_line!!.count { c -> c == '(' }\r\n//        if (numParen != 1) {\r\n//            throw AssemblerError(\"Load takes only one set of parentheses around the last register!\")\r\n//        }\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.IMM_11_0] = prog.getImmediate(args[1], I_TYPE_MIN, I_TYPE_MAX, dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject RTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], dbg = dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[2], dbg = dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject ShiftImmediateParser : InstructionParser {\r\n    const val SHIFT_MIN = 0\r\n    const val SHIFT_MAX = 31\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], dbg = dbg)\r\n        mcode[InstructionField.SHAMT] = prog.getImmediate(args[2], SHIFT_MIN, SHIFT_MAX, dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject STypeParser : InstructionParser {\r\n    const val S_TYPE_MIN = -2048\r\n    const val S_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n//        val real_line = dbg.line.split(Regex(\"#\")).firstOrNull()\r\n//        // Do not need to check of other paren because the lexer will ensure no mismatch.\r\n//        if (real_line != null && real_line.count { c -> c == '(' } == 1) {\r\n//            throw AssemblerError(\"Store takes only one set of parentheses around the last register!\")\r\n//        }\r\n\r\n        val imm = prog.getImmediate(args[1], S_TYPE_MIN, S_TYPE_MAX, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.IMM_4_0] = imm\r\n        mcode[InstructionField.IMM_11_5] = imm shr 5\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.base\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject UTypeParser : InstructionParser {\r\n    const val U_TYPE_MIN = 0\r\n    const val U_TYPE_MAX = 1048575\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 2, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.IMM_31_12] = prog.getImmediate(args[1], U_TYPE_MIN, U_TYPE_MAX, dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\n\r\nobject DoNothingParser : InstructionParser {\r\n    const val B_TYPE_MIN = -2048\r\n    const val B_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 0, dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers.extensions.atomic\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\nobject AMORTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[1], dbg = dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.compressed\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject CATypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 2, dbg)\r\n\r\n        val rdp = regNameToNumber(args[0], dbg = dbg)\r\n        val rs2p = regNameToNumber(args[1], dbg = dbg)\r\n\r\n        if (rdp !in 8..15 || rs2p !in 8..15) {\r\n            throw AssemblerError(\"CA instructions only takes registers x8 to x15!\", dbg)\r\n        }\r\n\r\n        mcode[InstructionField.RDP] = rdp\r\n        mcode[InstructionField.RS2P] = rs2p\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.compressed\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject CRTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 2, dbg)\r\n\r\n        val crd = regNameToNumber(args[0], dbg = dbg)\r\n        val crs2 = regNameToNumber(args[1], dbg = dbg)\r\n\r\n        mcode[InstructionField.RD] = crd\r\n        mcode[InstructionField.CRS2] = crs2\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FFRRTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], false, dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[2], false, dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FITypeParser : InstructionParser {\r\n    const val I_TYPE_MIN = -2048\r\n    const val I_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], false, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.IMM_11_0] = getImmediate(args[1], I_TYPE_MIN, I_TYPE_MAX, dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FR4TypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 4, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], false, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], false, dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[2], false, dbg)\r\n        mcode[InstructionField.RS3] = regNameToNumber(args[3], false, dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FRRTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 2, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], false, dbg)\r\n        mcode[InstructionField.RS2] = 0\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FRTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], false, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], false, dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[2], false, dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject FSTypeParser : InstructionParser {\r\n    const val S_TYPE_MIN = -2048\r\n    const val S_TYPE_MAX = 2047\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 3, dbg)\r\n\r\n        val imm = getImmediate(args[1], S_TYPE_MIN, S_TYPE_MAX, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[2], dbg = dbg)\r\n        mcode[InstructionField.RS2] = regNameToNumber(args[0], false, dbg)\r\n        mcode[InstructionField.IMM_4_0] = imm\r\n        mcode[InstructionField.IMM_11_5] = imm shr 5\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers.extensions.floating\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nobject RFRTypeParser : InstructionParser {\r\n    override operator fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) {\r\n        checkArgsLength(args.size, 2, dbg)\r\n\r\n        mcode[InstructionField.RD] = regNameToNumber(args[0], false, dbg)\r\n        mcode[InstructionField.RS1] = regNameToNumber(args[1], dbg = dbg)\r\n    }\r\n}","package venusbackend.riscv.insts.dsl.parsers\r\n\r\nclass ParserError(message: String) : Exception(message)\r\n","package venusbackend.riscv.insts.dsl.parsers\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.Program\r\n\r\nclass RawParser(private val eval: (Program, MachineCode, List<String>, DebugInfo) -> Unit) : InstructionParser {\r\n    override fun invoke(prog: Program, mcode: MachineCode, args: List<String>, dbg: DebugInfo) = eval(prog, mcode, args, dbg)\r\n}\r\n","package venusbackend.riscv.insts.dsl.parsers\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\n\r\ninternal fun checkArgsLength(argsSize: Int, required: Int, dbg: DebugInfo) {\r\n    if (argsSize != required)\r\n        throw AssemblerError(\"got $argsSize arguments but expected $required\", dbg)\r\n}\r\n\r\n/**\r\n * Converts a register name to its ID.\r\n *\r\n * Accepts ABI names (e.g., ra, fp) and RISC-V names (e.g., x1, x8)\r\n *\r\n * @param reg the name of the register\r\n * @return the ID of the register\r\n *\r\n * @throws AssemblerError if given an invalid register\r\n */\r\ninternal fun regNameToNumber(reg: String, integer: Boolean = true, dbg: DebugInfo): Int {\r\n    if (reg.startsWith(\"x\")) {\r\n        val ret = reg.drop(1).toInt()\r\n        if (ret in 0..31) {\r\n            if (!integer) throw AssemblerError(\"Register $reg is not a floating point register\", dbg)\r\n            return ret\r\n        }\r\n        throw AssemblerError(\"register $reg not recognized\", dbg)\r\n    }\r\n    if (reg.matches(Regex(\"f\\\\d{1,2}\"))) {\r\n        val ret = reg.drop(1).toInt()\r\n        if (ret in 0..31) {\r\n            if (integer) throw AssemblerError(\"Register $reg is not an integer register\", dbg)\r\n            return ret\r\n        }\r\n        throw AssemblerError(\"register $reg not recognized\", dbg)\r\n    }\r\n    try {\r\n        if (integer) {\r\n            return checkInteger(reg, dbg)\r\n        } else {\r\n            return checkFloating(reg, dbg)\r\n        }\r\n    } catch (e: AssemblerError) {\r\n        if (integer) {\r\n            checkFloating(reg, dbg)\r\n            throw AssemblerError(\"Register $reg is not an integer register\", dbg)\r\n        } else {\r\n            checkInteger(reg, dbg)\r\n            throw AssemblerError(\"Register $reg is not a floating point register\", dbg)\r\n        }\r\n    }\r\n}\r\n\r\nfun checkInteger(reg: String, dbg: DebugInfo): Int {\r\n    return when (reg) {\r\n        \"zero\" -> 0\r\n        \"ra\" -> 1\r\n        \"sp\" -> 2\r\n        \"gp\" -> 3\r\n        \"tp\" -> 4\r\n        \"t0\" -> 5\r\n        \"t1\" -> 6\r\n        \"t2\" -> 7\r\n        \"s0\", \"fp\" -> 8\r\n        \"s1\" -> 9\r\n        \"a0\" -> 10\r\n        \"a1\" -> 11\r\n        \"a2\" -> 12\r\n        \"a3\" -> 13\r\n        \"a4\" -> 14\r\n        \"a5\" -> 15\r\n        \"a6\" -> 16\r\n        \"a7\" -> 17\r\n        \"s2\" -> 18\r\n        \"s3\" -> 19\r\n        \"s4\" -> 20\r\n        \"s5\" -> 21\r\n        \"s6\" -> 22\r\n        \"s7\" -> 23\r\n        \"s8\" -> 24\r\n        \"s9\" -> 25\r\n        \"s10\" -> 26\r\n        \"s11\" -> 27\r\n        \"t3\" -> 28\r\n        \"t4\" -> 29\r\n        \"t5\" -> 30\r\n        \"t6\" -> 31\r\n        else -> throw AssemblerError(\"register $reg not recognized\", dbg)\r\n    }\r\n}\r\n\r\nfun checkFloating(reg: String, dbg: DebugInfo): Int {\r\n    return when (reg) {\r\n        \"ft0\" -> 0\r\n        \"ft1\" -> 1\r\n        \"ft2\" -> 2\r\n        \"ft3\" -> 3\r\n        \"ft4\" -> 4\r\n        \"ft5\" -> 5\r\n        \"ft6\" -> 6\r\n        \"ft7\" -> 7\r\n        \"fs0\" -> 8\r\n        \"fs1\" -> 9\r\n        \"fa0\" -> 10\r\n        \"fa1\" -> 11\r\n        \"fa2\" -> 12\r\n        \"fa3\" -> 13\r\n        \"fa4\" -> 14\r\n        \"fa5\" -> 15\r\n        \"fa6\" -> 16\r\n        \"fa7\" -> 17\r\n        \"fs2\" -> 18\r\n        \"fs3\" -> 19\r\n        \"fs4\" -> 20\r\n        \"fs5\" -> 21\r\n        \"fs6\" -> 22\r\n        \"fs7\" -> 23\r\n        \"fs8\" -> 24\r\n        \"fs9\" -> 25\r\n        \"fs10\" -> 26\r\n        \"fs11\" -> 27\r\n        \"ft8\" -> 28\r\n        \"ft9\" -> 29\r\n        \"ft10\" -> 30\r\n        \"ft11\" -> 31\r\n        else -> throw AssemblerError(\"register $reg not recognized\", dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\n/** Set the immediate field of an I-type instruction MCODE to TARGET.\r\n *  The value of PC is unused. */\r\nprivate object ImmAbsRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        if (target in -2048..2047) {\r\n            mcode[InstructionField.IMM_11_0] = target\r\n        } else {\r\n            throw AssemblerError(\"immediate value out of range: $target\", dbg)\r\n        }\r\n    }\r\n}\r\n\r\nval ImmAbsRelocator = Relocator(ImmAbsRelocator32, NoRelocator64)","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\nprivate object ImmAbsStoreRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        if (target in -2048..2047) {\r\n            mcode[InstructionField.IMM_4_0] = target\r\n            mcode[InstructionField.IMM_11_5] = target shr 5\r\n        } else {\r\n            throw AssemblerError(\"immediate value out of range: $target\", dbg)\r\n        }\r\n    }\r\n}\r\n\r\nval ImmAbsStoreRelocator = Relocator(ImmAbsStoreRelocator32, NoRelocator64)","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\nprivate object JALRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        val imm = target - pc\r\n        mcode[InstructionField.IMM_20] = imm shr 20\r\n        mcode[InstructionField.IMM_10_1] = imm shr 1\r\n        mcode[InstructionField.IMM_19_12] = imm shr 12\r\n        mcode[InstructionField.IMM_11_J] = imm shr 11\r\n    }\r\n}\r\n\r\nval JALRelocator = Relocator(JALRelocator32, NoRelocator64)\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MachineCode\r\n\r\nobject NoRelocator64 : Relocator64 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Long, target: Long, dbg: DebugInfo) =\r\n            throw NotImplementedError(\"no relocator64 for $mcode\")\r\n}\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\nprivate object PCRelHiRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        mcode[InstructionField.IMM_31_12] = (target - pc + 0x800) shr 12\r\n    }\r\n}\r\n\r\nval PCRelHiRelocator = Relocator(PCRelHiRelocator32, NoRelocator64)\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\nprivate object PCRelLoRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        mcode[InstructionField.IMM_11_0] = target - (pc - 4)\r\n    }\r\n}\r\n\r\nval PCRelLoRelocator = Relocator(PCRelLoRelocator32, NoRelocator64)\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\n\r\nprivate object PCRelLoStoreRelocator32 : Relocator32 {\r\n    override operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo) {\r\n        val offset = target - (pc - 4)\r\n        mcode[InstructionField.IMM_4_0] = offset\r\n        mcode[InstructionField.IMM_11_5] = offset shr 5\r\n    }\r\n}\r\n\r\nval PCRelLoStoreRelocator = Relocator(PCRelLoStoreRelocator32, NoRelocator64)\r\n","package venusbackend.riscv.insts.dsl.relocators\r\n\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MachineCode\r\n\r\ninterface Relocator32 {\r\n    operator fun invoke(mcode: MachineCode, pc: Int, target: Int, dbg: DebugInfo)\r\n}\r\n\r\ninterface Relocator64 {\r\n    operator fun invoke(mcode: MachineCode, pc: Long, target: Long, dbg: DebugInfo)\r\n}\r\n\r\nclass Relocator(private val relocator32: Relocator32, private val relocator64: Relocator64) {\r\n    operator fun invoke(mcode: MachineCode, pc: Number, target: Number, is64: Boolean = false, dbg: DebugInfo) {\r\n        if (is64) relocator64(mcode, pc.toLong(), target.toLong(), dbg)\r\n        else relocator32(mcode, pc.toInt(), target.toInt(), dbg)\r\n    }\r\n}\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.BTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.BTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.BTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.BTypeImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.BTypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass BTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    cond16: (Short, Short) -> Boolean = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    cond32: (Int, Int) -> Boolean,\r\n    cond64: (Long, Long) -> Boolean = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    cond128: (QuadWord, QuadWord) -> Boolean = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = BTypeFormat(opcode, funct3),\r\n        parser = BTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = BTypeImplementation32(cond32),\r\n        impl64 = BTypeImplementation64(cond64),\r\n        impl128 = NoImplementation,\r\n        disasm = BTypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.ITypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.ITypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.ITypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.ITypeImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.ITypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass ITypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = ITypeFormat(opcode, funct3),\r\n        parser = ITypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = ITypeImplementation32(eval32),\r\n        impl64 = ITypeImplementation64(eval64),\r\n        impl128 = NoImplementation,\r\n        disasm = ITypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.LoadDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.ITypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.LoadImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.LoadImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.LoadParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass LoadTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    load16: (Simulator, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    postLoad16: (Short) -> Short = { it },\r\n    load32: (Simulator, Int) -> Int,\r\n    postLoad32: (Int) -> Int = { it },\r\n    load64: (Simulator, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    postLoad64: (Long) -> Long = { it },\r\n    load128: (Simulator, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") },\r\n    postLoad128: (QuadWord) -> QuadWord = { it }\r\n) : Instruction(\r\n        name = name,\r\n        format = ITypeFormat(opcode, funct3),\r\n        parser = LoadParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = LoadImplementation32(load32, postLoad32),\r\n        impl64 = LoadImplementation64(load64, postLoad64),\r\n        impl128 = NoImplementation,\r\n        disasm = LoadDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.RTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.RTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.RTypeImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.RTypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass RTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    funct7: Int = 0b0,\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(opcode, funct3, funct7),\r\n        parser = RTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RTypeImplementation32(eval32),\r\n        impl64 = RTypeImplementation64(eval64),\r\n        impl128 = NoImplementation,\r\n        disasm = RTypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.ShiftImmediateDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.ShiftImmediateImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.ShiftImmediateImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.ShiftImmediateParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass ShiftImmediateInstruction(\r\n    name: String,\r\n    funct3: Int,\r\n    funct7: Int,\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(\r\n                opcode = 0b0010011,\r\n                funct3 = funct3,\r\n                funct7 = funct7\r\n        ),\r\n        parser = ShiftImmediateParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = ShiftImmediateImplementation32(eval32),\r\n        impl64 = ShiftImmediateImplementation64(eval64),\r\n        impl128 = NoImplementation,\r\n        disasm = ShiftImmediateDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.ShiftImmediateDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.ShiftImmediateImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.ShiftImmediateImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.ShiftImmediateParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass ShiftWImmediateInstruction(\r\n    name: String,\r\n    funct3: Int,\r\n    funct7: Int,\r\n    opcode: Int,\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(\r\n                opcode = opcode,\r\n                funct3 = funct3,\r\n                funct7 = funct7\r\n        ),\r\n        parser = ShiftImmediateParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = ShiftImmediateImplementation32(eval32),\r\n        impl64 = ShiftImmediateImplementation64(eval64),\r\n        impl128 = NoImplementation,\r\n        disasm = ShiftImmediateDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.base.STypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.STypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.base.b32.STypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.base.b64.STypeImplementation64\r\nimport venusbackend.riscv.insts.dsl.parsers.base.STypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass STypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    store16: (Simulator, Short, Short) -> Unit = { _, _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    store32: (Simulator, Int, Int) -> Unit,\r\n    store64: (Simulator, Long, Long) -> Unit = { _, _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    store128: (Simulator, QuadWord, QuadWord) -> Unit = { _, _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = STypeFormat(opcode, funct3),\r\n        parser = STypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = STypeImplementation32(store32),\r\n        impl64 = STypeImplementation64(store64),\r\n        impl128 = NoImplementation,\r\n        disasm = STypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.base\r\n\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.disasms.base.UTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.UTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.UTypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass UTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    impl16: (MachineCode, Simulator) -> Unit = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    impl32: (MachineCode, Simulator) -> Unit,\r\n    impl64: (MachineCode, Simulator) -> Unit = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    impl128: (MachineCode, Simulator) -> Unit = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = UTypeFormat(opcode),\r\n        parser = UTypeParser,\r\n        impl16 = RawImplementation(impl16),\r\n        impl32 = RawImplementation(impl32),\r\n        impl64 = RawImplementation(impl64),\r\n        impl128 = RawImplementation(impl128),\r\n        disasm = UTypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.extensions.atomic\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.atomic.AMORTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.atomic.AMORTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.atomic.b32.AMORTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.atomic.AMORTypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass AMORTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    aq: Int,\r\n    rl: Int,\r\n    funct5: Int,\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = AMORTypeFormat(opcode, funct3, funct5, aq, rl),\r\n        parser = AMORTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = AMORTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = AMORTypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.extensions.compressed\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.compressed.CATypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.compressed.CATypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.compressed.b32.CATypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.compressed.CATypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass CATypeInstruction(\r\n    name: String,\r\n    opcode2: Int,\r\n    funct2: Int,\r\n    funct6: Int,\r\n    regComp: Array<FieldEqual> = arrayOf(),\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = CATypeFormat(opcode2, funct2, funct6),\r\n        parser = CATypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = CATypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = CATypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.extensions.compressed\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.compressed.CRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.compressed.CRTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.compressed.b32.CRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.compressed.CRTypeParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nclass CRTypeInstruction(\r\n    name: String,\r\n    opcode2: Int,\r\n    funct4: Int,\r\n    regComp: Array<FieldEqual> = arrayOf(),\r\n    eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int, Int) -> Int,\r\n    eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    eval128: (QuadWord, QuadWord) -> QuadWord = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = CRTypeFormat(opcode2, funct4, regComp),\r\n        parser = CRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = CRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = CRTypeDisassembler\r\n)\r\n","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass F3RTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct7: Int,\r\n    funct3: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Decimal // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(opcode, funct3, funct7),\r\n        parser = FRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FRRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FFRRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FRRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass FclassRTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    funct7: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Int // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(opcode, funct3, funct7),\r\n        parser = FRRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FFRRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FRRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FFRRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.RTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FFRRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FFRRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass FFRRTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    funct7: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Int // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = RTypeFormat(opcode, funct3, funct7),\r\n        parser = FFRRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FFRRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FFRRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FITypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.ITypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FITypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FITypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass FITypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    eval32: (Int, Simulator) -> Decimal\r\n) : Instruction(\r\n        name = name,\r\n        format = ITypeFormat(opcode, funct3),\r\n        parser = FITypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FITypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FITypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FR4TypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.floating.R4TypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FR4TypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FR4TypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass FR4TypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct2: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal, Decimal) -> Decimal // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = R4TypeFormat(opcode, funct2),\r\n        parser = FR4TypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FR4TypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FR4TypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FRRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.floating.FSRS2TypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FRRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass FRRTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct7: Int,\r\n    rs2: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Decimal // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = FSRS2TypeFormat(opcode, funct7, rs2),\r\n        parser = FRRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FRRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.floating.FRTypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\nclass FRTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct7: Int,\r\n        // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Decimal // ,\r\n        // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n        // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = FRTypeFormat(opcode, funct7),\r\n        parser = FRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FRTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FSTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.STypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FSTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FSTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Simulator\r\n\r\nclass FSTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    store32: (Simulator, Int, Decimal) -> Unit\r\n) : Instruction(\r\n        name = name,\r\n        format = STypeFormat(opcode, funct3),\r\n        parser = FSTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = FSTypeImplementation32(store32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = FSTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.FRRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.floating.FSRS2TypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.FFRRTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.FRRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass FtRTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    funct7: Int,\r\n    rs2: Int,\r\n    // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Decimal, Decimal) -> Int // ,\r\n    // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n    name = name,\r\n    format = FSRS2TypeFormat(opcode, funct7, rs2),\r\n    parser = FRRTypeParser,\r\n    impl16 = NoImplementation,\r\n    impl32 = FFRRTypeImplementation32(eval32),\r\n    impl64 = NoImplementation,\r\n    impl128 = NoImplementation,\r\n    disasm = FRRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types.extensions.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.extensions.floating.RFRTypeDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.extensions.floating.FSRS2TypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.extensions.floating.b32.RtFTypeImplementation32\r\nimport venusbackend.riscv.insts.dsl.parsers.extensions.floating.RFRTypeParser\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nclass RtFTypeInstruction(\r\n    name: String,\r\n    opcode: Int,\r\n    funct3: Int,\r\n    funct7: Int,\r\n    rs2: Int,\r\n    // eval16: (Short, Short) -> Short = { _, _ -> throw NotImplementedError(\"no rv16\") },\r\n    eval32: (Int) -> Decimal // ,\r\n    // eval64: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv64\") },\r\n    // eval128: (Long, Long) -> Long = { _, _ -> throw NotImplementedError(\"no rv128\") }\r\n) : Instruction(\r\n        name = name,\r\n        format = FSRS2TypeFormat(opcode, funct7, rs2),\r\n        parser = RFRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RtFTypeImplementation32(eval32),\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = RFRTypeDisassembler\r\n)","package venusbackend.riscv.insts.dsl.types\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.InstructionNotFoundError\r\nimport venusbackend.riscv.insts.dsl.disasms.InstructionDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.InstructionImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.InstructionParser\r\nimport venusbackend.simulator.SimulatorError\r\n\r\nopen class Instruction(\r\n    val name: String,\r\n    val format: InstructionFormat,\r\n    val parser: InstructionParser,\r\n    val impl16: InstructionImplementation,\r\n    val impl32: InstructionImplementation,\r\n    val impl64: InstructionImplementation,\r\n    val impl128: InstructionImplementation,\r\n    val disasm: InstructionDisassembler\r\n) {\r\n    companion object {\r\n        private val allInstructions = arrayListOf<Instruction>()\r\n\r\n        operator fun get(mcode: MachineCode): Instruction =\r\n                allInstructions.filter { it.format.length == mcode.length }\r\n                        .firstOrNull { it.format.matches(mcode) }\r\n                        ?: throw SimulatorError(\"instruction not found for 0x\" + mcode.toString(16), InstructionNotFoundError())\r\n\r\n        operator fun get(name: String, dbg: DebugInfo?) =\r\n                allInstructions.firstOrNull { it.name == name }\r\n                        ?: throw AssemblerError(\"instruction with name $name not found\", InstructionNotFoundError(), dbg)\r\n    }\r\n\r\n    init {\r\n        allInstructions.add(this)\r\n    }\r\n\r\n    override fun toString() = name\r\n}\r\n","package venusbackend.riscv.insts.floating\r\n\r\nimport kotlin.math.abs\r\n\r\nclass Decimal(f: Float = 0F, d: Double = 0.0, isF: Boolean = true) {\r\n    var float: Float = f\r\n    var double: Double = d\r\n    var isFloat: Boolean = isF\r\n    fun isDouble(): Boolean = !this.isFloat\r\n\r\n    fun set(float: Float) {\r\n        this.float = float\r\n        isFloat = true\r\n    }\r\n\r\n    fun set(double: Double) {\r\n        this.double = double\r\n        isFloat = false\r\n    }\r\n\r\n    fun get(): Number {\r\n        if (this.isFloat) {\r\n            return this.float\r\n        } else {\r\n            return this.double\r\n        }\r\n    }\r\n\r\n    fun getCurrentFloat(): Float {\r\n        if (this.isFloat) {\r\n            return this.float\r\n        } else {\r\n            var s = this.double.toRawBits().toString(16)\r\n            s += \"0\".repeat(16 - s.length)\r\n            return Float.fromBits(s.substring(8 until 16).toInt(16))\r\n        }\r\n    }\r\n\r\n    fun getCurrentDouble(): Double {\r\n        if (this.isFloat) {\r\n            var s = this.float.toRawBits().toString(16)\r\n            s += \"0\".repeat(8 - s.length)\r\n            s = \"0\".repeat(8) + s\r\n            return Double.fromBits(s.toLong(16))\r\n        } else {\r\n            return this.double\r\n        }\r\n    }\r\n\r\n    fun toHex(): String {\r\n        /*FIXME make it convert to hex correctly*/\r\n        var s: String\r\n        if (this.isFloat) {\r\n            var isNeg = false\r\n            val f = if (this.float < 0) {\r\n                isNeg = true\r\n                this.float * -1\r\n            } else {\r\n                this.float\r\n            }\r\n            val b = f.toRawBits()\r\n            s = b.toString(16)\r\n            s = s.removePrefix(\"-\")\r\n            s = \"0\".repeat(8 - s.length) + s\r\n            if (isNeg) {\r\n                val new: Char = when (s[0]) {\r\n                    '0' -> '8'\r\n                    '1' -> '9'\r\n                    '2' -> 'a'\r\n                    '3' -> 'b'\r\n                    '4' -> 'c'\r\n                    '5' -> 'd'\r\n                    '6' -> 'e'\r\n                    '7' -> 'f'\r\n                    else -> s[0]\r\n                }\r\n                s = new + s.removeRange(0..0)\r\n            }\r\n            s = \"0x\" + s\r\n        } else {\r\n            var isNeg = false\r\n            val d = if (this.double < 0) {\r\n                isNeg = true\r\n                this.double * -1\r\n            } else {\r\n                this.double\r\n            }\r\n            val b = d.toRawBits()\r\n            s = b.toString(16)\r\n            s = s.removePrefix(\"-\")\r\n            s = \"0\".repeat(16 - s.length) + s\r\n            if (isNeg) {\r\n                val new: Char = when (s[0]) {\r\n                    '0' -> '8'\r\n                    '1' -> '9'\r\n                    '2' -> 'a'\r\n                    '3' -> 'b'\r\n                    '4' -> 'c'\r\n                    '5' -> 'd'\r\n                    '6' -> 'e'\r\n                    '7' -> 'f'\r\n                    else -> s[0]\r\n                }\r\n                s = new + s.removeRange(0..0)\r\n            }\r\n            s = \"0x\" + s\r\n        }\r\n        return s\r\n    }\r\n\r\n    fun toDecimal(): String {\r\n        var s = \"\"\r\n        if (this.isFloat) {\r\n            if (this.float.toRawBits() == 0x80000000.toInt()) {\r\n                s = \"-\"\r\n            }\r\n            s += this.float.toString()\r\n        } else {\r\n            if (this.double.toRawBits().toString(16) == \"8000000000000000\") {\r\n                s = \"-\"\r\n            }\r\n            s += this.double.toString()\r\n        }\r\n        return s\r\n    }\r\n\r\n    fun toUnsigned(): String {\r\n        val s: String\r\n        if (this.isFloat) {\r\n            s = abs(this.float).toString()\r\n        } else {\r\n            s = abs(this.double).toString()\r\n        }\r\n        return s\r\n    }\r\n\r\n    fun toAscii(): String {\r\n        return this.toHex()\r\n    }\r\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()","package venusbackend.riscv.insts.floating.double.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FITypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fld = FITypeInstruction(\r\n        name = \"fld\",\r\n        opcode = 0b0000111,\r\n        funct3 = 0b011,\r\n        eval32 = { addr, sim ->\r\n            Decimal(d = Double.fromBits(sim.loadWordwCache(addr).toLong() or (sim.loadWordwCache(addr + 4).toLong() shl 32)), isF = false)\r\n        }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval faddd = FRTypeInstruction(\r\n        name = \"fadd.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0000001,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble() + b.getCurrentDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fcvtdw = RtFTypeInstruction(\r\n        name = \"fcvt.d.w\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1101001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a -> Decimal(d = a.toDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.abs\r\n\r\nval fcvtdwu = RtFTypeInstruction(\r\n        name = \"fcvt.d.wu\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1101001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00001,\r\n        eval32 = { a -> Decimal(d = abs(a).toDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\nimport kotlin.math.round\r\n\r\nval fcvtwd = FtRTypeInstruction(\r\n        name = \"fcvt.w.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1100001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> round(a.getCurrentDouble()).toInt() }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\nimport kotlin.math.abs\r\nimport kotlin.math.round\r\n\r\nval fcvtwud = FtRTypeInstruction(\r\n        name = \"fcvt.wu.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1100001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00001,\r\n        eval32 = { a, b -> abs(round(a.getCurrentDouble())).toInt() }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\nval feqd = FFRRTypeInstruction(\r\n        name = \"feq.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b010,\r\n        funct7 = 0b1010001,\r\n        eval32 = { a, b -> if (a.getCurrentDouble() == b.getCurrentDouble()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\nval fled = FFRRTypeInstruction(\r\n        name = \"fle.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b1010001,\r\n        eval32 = { a, b -> if (a.getCurrentDouble() <= b.getCurrentDouble()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\nval fltd = FFRRTypeInstruction(\r\n        name = \"flt.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b1010001,\r\n        eval32 = { a, b -> if (a.getCurrentDouble() < b.getCurrentDouble()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fmaddd = FR4TypeInstruction(\r\n        name = \"fmadd.d\",\r\n        opcode = 0b1000011,\r\n        funct2 = 0b01,\r\n        eval32 = { a, b, c -> Decimal(d = (a.getCurrentDouble() * b.getCurrentDouble()) + c.getCurrentDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fmaxd = F3RTypeInstruction(\r\n        name = \"fmax.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0010101,\r\n        eval32 = { a, b -> Decimal(d = maxOf(a.getCurrentDouble(), b.getCurrentDouble()), isF = false) }\r\n)","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fmind = F3RTypeInstruction(\r\n        name = \"fmin.d\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0010101,\r\n        eval32 = { a, b -> Decimal(d = minOf(a.getCurrentDouble(), b.getCurrentDouble()), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fmsubd = FR4TypeInstruction(\r\n        name = \"fmsub.d\",\r\n        opcode = 0b1000111,\r\n        funct2 = 0b01,\r\n        eval32 = { a, b, c -> Decimal(d = (a.getCurrentDouble() * b.getCurrentDouble()) - c.getCurrentDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fmuld = FRTypeInstruction(\r\n        name = \"fmul.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0001001,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble() * b.getCurrentDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\n\r\nval fmvdx = RtFTypeInstruction(\r\n        name = \"fmv.d.x\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1111001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a -> throw InstructionNotSupportedError(\"fmv.d.x is only for 64 bit systems!\") }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\n\r\nval fmvxd = FtRTypeInstruction(\r\n        name = \"fmv.x.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1110001,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> throw InstructionNotSupportedError(\"fmv.x.d is only for 64 bit systems!\") }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fnmaddd = FR4TypeInstruction(\r\n        name = \"fnmadd.d\",\r\n        opcode = 0b1001111,\r\n        funct2 = 0b01,\r\n        eval32 = { a, b, c -> Decimal(d = -((a.getCurrentDouble() * b.getCurrentDouble()) + c.getCurrentDouble()), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fnmsubd = FR4TypeInstruction(\r\n        name = \"fnmsub.d\",\r\n        opcode = 0b1001011,\r\n        funct2 = 0b01,\r\n        eval32 = { a, b, c -> Decimal(d = -((a.getCurrentDouble() * b.getCurrentDouble()) - c.getCurrentDouble()), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.withSign\r\n\r\nval fsgnjd = F3RTypeInstruction(\r\n        name = \"fsgnj.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010001,\r\n        funct3 = 0b000,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble().withSign(b.getCurrentDouble()), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sign\r\nimport kotlin.math.withSign\r\n\r\nval fsgnjnd = F3RTypeInstruction(\r\n        name = \"fsgnjn.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010001,\r\n        funct3 = 0b001,\r\n        /*TODO FIX THE BITS TO MAKE THE SIGN CORRECT*/\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble().withSign((b.getCurrentDouble().toRawBits() xor 0x800000000000000).sign), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sign\r\nimport kotlin.math.withSign\r\n\r\nval fsgnjxd = F3RTypeInstruction(\r\n        name = \"fsgnjx.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010001,\r\n        funct3 = 0b010,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble().withSign((a.getCurrentDouble().toRawBits() xor b.getCurrentDouble().toRawBits()).sign), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sqrt\r\n\r\nval fsqrtd = FRRTypeInstruction(\r\n        name = \"fsqrt.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0101101,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> Decimal(d = sqrt(a.getCurrentDouble()), isF = false) }\r\n)","package venusbackend.riscv.insts.floating.double.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fsubd = FRTypeInstruction(\r\n        name = \"fsub.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0000101,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentDouble() - b.getCurrentDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRRTypeInstruction\r\n\r\nval fcvtds = FRRTypeInstruction(\r\n        name = \"fcvt.d.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0100001,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> Decimal(d = a.getCurrentFloat().toDouble(), isF = false) }\r\n)","package venusbackend.riscv.insts.floating\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRRTypeInstruction\r\n\r\nval fcvtsd = FRRTypeInstruction(\r\n        name = \"fcvt.s.d\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0100000,\r\n        rs2 = 0b00001,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentDouble().toFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FITypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\n\r\nval flw = FITypeInstruction(\r\n        name = \"flw\",\r\n        opcode = 0b0000111,\r\n        funct3 = 0b010,\r\n        eval32 = { addr, sim ->\r\n            Decimal(f = Float.fromBits(sim.loadWordwCache(addr)))\r\n        }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fadds = FRTypeInstruction(\r\n        name = \"fadd.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0000000,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat() + b.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FclassRTypeInstruction\r\n\r\n/*Single-Precision*/\r\n/*TODO fix so this is better.*/\r\nval fclasss = FclassRTypeInstruction(\r\n        name = \"fclass.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b1110000,\r\n        eval32 = { a, b ->\r\n            var bits = 0b0\r\n            if (a.getCurrentFloat() == Float.NEGATIVE_INFINITY) bits = bits or 0b0000000001\r\n            if (a.getCurrentFloat() < 0 && a.getCurrentFloat() >= (-1.17549435e-38).toFloat()) bits = bits or 0b0000000010\r\n            if (a.getCurrentFloat() < 0 && a.getCurrentFloat() < (-1.17549435e-38).toFloat()) bits = bits or 0b0000000100\r\n            if (a.getCurrentFloat().toRawBits() == 0) bits = bits or 0b0000001000\r\n            if (a.getCurrentFloat().toRawBits() == 0x80000000.toInt()) bits = bits or 0b0000010000\r\n            if (a.getCurrentFloat() > 0 && a.getCurrentFloat() >= (1.17549435e-38).toFloat()) bits = bits or 0b0000100000\r\n            if (a.getCurrentFloat() > 0 && a.getCurrentFloat() < (1.17549435e-38).toFloat()) bits = bits or 0b0001000000\r\n            if (a.getCurrentFloat() == Float.POSITIVE_INFINITY) bits = bits or 0b0010000000\r\n            if (Float.NaN.equals(a.getCurrentFloat())) bits = bits or 0b0100000000\r\n            if (Float.NaN.equals(a.getCurrentFloat())) bits = bits or 0b1000000000\r\n            bits\r\n        }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fcvtsw = RtFTypeInstruction(\r\n    name = \"fcvt.s.w\",\r\n    opcode = 0b1010011,\r\n    funct7 = 0b1101000,\r\n    funct3 = 0b000,\r\n    rs2 = 0b00000,\r\n    eval32 = { a -> Decimal(f = a.toFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.abs\r\n\r\nval fcvtswu = RtFTypeInstruction(\r\n        name = \"fcvt.s.wu\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1101000,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00001,\r\n        eval32 = { a -> Decimal(f = abs(a).toFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\nimport kotlin.math.round\r\n\r\nval fcvtws = FtRTypeInstruction(\r\n        name = \"fcvt.w.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1100000,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> round(a.getCurrentFloat()).toInt() }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\nimport kotlin.math.abs\r\nimport kotlin.math.round\r\n\r\nval fcvtwus = FtRTypeInstruction(\r\n        name = \"fcvt.wu.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1100000,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00001,\r\n        eval32 = { a, b -> abs(round(a.getCurrentFloat())).toInt() }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fdivs = FRTypeInstruction(\r\n        name = \"fdiv.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0001100,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat() / b.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\n/*Single-Precision*/\r\nval feqs = FFRRTypeInstruction(\r\n        name = \"feq.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b010,\r\n        funct7 = 0b1010000,\r\n        eval32 = { a, b -> if (a.getCurrentFloat() == b.getCurrentFloat()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\n/*Single-Precision*/\r\nval fles = FFRRTypeInstruction(\r\n        name = \"fle.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b1010000,\r\n        eval32 = { a, b -> if (a.getCurrentFloat() <= b.getCurrentFloat()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FFRRTypeInstruction\r\n\r\n/*Single-Precision*/\r\nval flts = FFRRTypeInstruction(\r\n        name = \"flt.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b1010000,\r\n        eval32 = { a, b -> if (a.getCurrentFloat() < b.getCurrentFloat()) 1 else 0 }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fmadds = FR4TypeInstruction(\r\n        name = \"fmadd.s\",\r\n        opcode = 0b1000011,\r\n        funct2 = 0b00,\r\n        eval32 = { a, b, c -> Decimal(f = (a.getCurrentFloat() * b.getCurrentFloat()) + c.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fmaxs = F3RTypeInstruction(\r\n        name = \"fmax.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0010100,\r\n        eval32 = { a, b -> Decimal(f = maxOf(a.getCurrentFloat(), b.getCurrentFloat())) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fmins = F3RTypeInstruction(\r\n        name = \"fmin.s\",\r\n        opcode = 0b1010011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0010100,\r\n        eval32 = { a, b -> Decimal(f = minOf(a.getCurrentFloat(), b.getCurrentFloat())) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fmsubs = FR4TypeInstruction(\r\n        name = \"fmsub.s\",\r\n        opcode = 0b1000111,\r\n        funct2 = 0b00,\r\n        eval32 = { a, b, c -> Decimal(f = (a.getCurrentFloat() * b.getCurrentFloat()) - c.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fmuls = FRTypeInstruction(\r\n        name = \"fmul.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0001000,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat() * b.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.RtFTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\n\r\nval fmvsx = RtFTypeInstruction(\r\n        name = \"fmv.s.x\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1111000,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a -> Decimal(f = Float.fromBits(a)) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FtRTypeInstruction\r\n\r\n/*Single-Precision*/\r\nval fmvxs = FtRTypeInstruction(\r\n        name = \"fmv.x.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b1110000,\r\n        funct3 = 0b000,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> a.getCurrentFloat().toRawBits() }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fnmadds = FR4TypeInstruction(\r\n        name = \"fnmadd.s\",\r\n        opcode = 0b1001111,\r\n        funct2 = 0b00,\r\n        eval32 = { a, b, c -> Decimal(f = -((a.getCurrentFloat() * b.getCurrentFloat()) + c.getCurrentFloat())) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FR4TypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\nval fnmsubs = FR4TypeInstruction(\r\n        name = \"fnmsub.s\",\r\n        opcode = 0b1001011,\r\n        funct2 = 0b00,\r\n        eval32 = { a, b, c -> Decimal(f = -((a.getCurrentFloat() * b.getCurrentFloat()) - c.getCurrentFloat())) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.withSign\r\n\r\n/*Single-Precision*/\r\nval fsgnjs = F3RTypeInstruction(\r\n        name = \"fsgnj.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010000,\r\n        funct3 = 0b000,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat().withSign(b.getCurrentFloat())) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sign\r\nimport kotlin.math.withSign\r\n\r\n/*Single-Precision*/\r\nval fsgnjns = F3RTypeInstruction(\r\n        name = \"fsgnjn.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010000,\r\n        funct3 = 0b001,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat().withSign((b.getCurrentFloat().toRawBits() xor 0x80000000.toInt()).sign)) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.F3RTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sign\r\nimport kotlin.math.withSign\r\n\r\n/*Single-Precision*/\r\nval fsgnjxs = F3RTypeInstruction(\r\n        name = \"fsgnjx.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0010000,\r\n        funct3 = 0b010,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat().withSign((a.getCurrentFloat().toRawBits() xor b.getCurrentFloat().toRawBits()).sign)) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport kotlin.math.sqrt\r\n\r\n/*Single-Precision*/\r\nval fsqrts = FRRTypeInstruction(\r\n        name = \"fsqrt.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0101100,\r\n        rs2 = 0b00000,\r\n        eval32 = { a, b -> Decimal(f = sqrt((a.getCurrentFloat()).toDouble()).toFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FRTypeInstruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\n\r\n/*Single-Precision*/\r\nval fsubs = FRTypeInstruction(\r\n        name = \"fsub.s\",\r\n        opcode = 0b1010011,\r\n        funct7 = 0b0000100,\r\n        eval32 = { a, b -> Decimal(f = a.getCurrentFloat() - b.getCurrentFloat()) }\r\n)","package venusbackend.riscv.insts.floating.single.s\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.floating.FSTypeInstruction\r\n\r\n/*Single-Precision*/\r\n\r\nval fsw = FSTypeInstruction(\r\n        name = \"fsw\",\r\n        opcode = 0b0100111,\r\n        funct3 = 0b010,\r\n//        store16 = NoImplementation,\r\n        store32 = { sim, address, value ->\r\n            sim.storeWordwCache(address, value.getCurrentFloat().toRawBits())\r\n        }\r\n//        store64 = NoImplementation,\r\n//        store128 = NoImplementation\r\n)","package venusbackend.riscv.insts\r\n\r\nclass InstructionNotFoundError : Throwable {\r\n    constructor(msg: String? = null) : super(msg)\r\n}","package venusbackend.riscv.insts\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\n/**\r\n * Thrown when errors occur when an instruction is not supported by the instruction set.\r\n */\r\nopen class InstructionNotSupportedError : Throwable {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n}\r\n","package venusbackend.riscv.insts\r\n\r\n/**\r\n * Created by thaum on 8/6/2018.\r\n */\r\n/**\r\n * Thrown when errors occur when an instruction is not supported by the instruction set.\r\n */\r\nclass InstructionReservedError : InstructionNotSupportedError {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n}\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval addi = ITypeInstruction(\r\n        name = \"addi\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b000,\r\n        eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = { a, b -> a + b },\r\n        eval64 = { a, b -> a + b },\r\n        eval128 = { a, b -> a + b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval addiw = ITypeInstruction(\r\n        name = \"addiw\",\r\n        opcode = 0b0011011,\r\n        funct3 = 0b000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"addiw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"addiw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            (a.toInt() + b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            (a.toInt() + b.toInt()).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval andi = ITypeInstruction(\r\n        name = \"andi\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b111,\r\n        eval16 = { a, b -> (a.toInt() and b.toInt()).toShort() },\r\n        eval32 = { a, b -> a and b },\r\n        eval64 = { a, b -> a and b },\r\n        eval128 = { a, b -> a and b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrc = Instruction(\r\n        name = \"csrrc\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b011)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrc x$dest $csr x$source\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrci = Instruction(\r\n        name = \"csrrci\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b111)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm.inv() and vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrci x$dest $csr $source\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrs = Instruction(\r\n        name = \"csrrs\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b010)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1 or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1 or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1 or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrs x$dest $csr x$source\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrsi = Instruction(\r\n        name = \"csrrsi\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b110)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm or vcsr)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrsi x$dest $csr $source\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrw = Instruction(\r\n        name = \"csrrw\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b001)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val vrs1 = sim.getReg(mcode[InstructionField.RS1].toInt()).toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, vrs1)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrw x$dest $csr x$source\"\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.base.CSRTypeParser\r\n\r\nval csrrwi = Instruction(\r\n        name = \"csrrwi\",\r\n        format = InstructionFormat(4,\r\n                listOf(\r\n                        FieldEqual(InstructionField.OPCODE, 0b1110011),\r\n                        FieldEqual(InstructionField.FUNCT3, 0b101)\r\n                )\r\n        ),\r\n        parser = CSRTypeParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toInt()\r\n            val vcsr = sim.getReg(32).toInt()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toLong()\r\n            val vcsr = sim.getReg(32).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val imm = mcode[InstructionField.RS1].toQuadWord()\r\n            val vcsr = sim.getReg(32).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), vcsr)\r\n            sim.setReg(32, imm)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler {\r\n            val dest = it[InstructionField.RD]\r\n            val source = it[InstructionField.RS1]\r\n            val csr = it[InstructionField.IMM_11_0]\r\n            \"csrrwi x$dest $csr $source\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.DoNothingParser\r\n\r\nval ebreak = Instruction(\r\n        name = \"ebreak\",\r\n        format = InstructionFormat(4,\r\n                listOf(FieldEqual(InstructionField.ENTIRE, 0b000000000001_00000_000_00000_1110011))\r\n        ),\r\n        parser = DoNothingParser,\r\n        impl16 = RawImplementation { mcode, sim ->\r\n            sim.ebreak = true\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            sim.ebreak = true\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            sim.ebreak = true\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            sim.ebreak = true\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler { \"ebreak\" }\r\n)","package venusbackend.riscv.insts.integer.base.i.ecall\r\n\r\nimport venus.Renderer\r\nimport venusbackend.riscv.Registers\r\nimport venusbackend.simulator.Simulator\r\n\r\nfun clib(sim: Simulator) {\r\n    val whichCall = sim.getReg(Registers.a6)\r\n    when (whichCall) {\r\n        1 -> malloc(sim)\r\n        2 -> calloc(sim)\r\n        3 -> realloc(sim)\r\n        4 -> free(sim)\r\n        5 -> mallocActiveNumBlocks(sim)\r\n        else -> Renderer.printConsole(\"Invalid clib ecall $whichCall\")\r\n    }\r\n}\r\n\r\n/**\r\n * Takes in\r\n * a1 size to malloc.\r\n *\r\n * Returns to a0 a pointer to the new malloced data or NULL if the malloc has failed.\r\n */\r\nfun malloc(sim: Simulator) {\r\n    val size = sim.getReg(Registers.a1).toInt()\r\n    val dest = sim.alloc.malloc(size)\r\n    sim.setReg(Registers.a0, dest)\r\n}\r\n\r\n/**\r\n * Takes in:\r\n * a1 nitems\r\n * a2 size\r\n *\r\n * Returns to a0 a pointer to the new malloced data or NULL if the calloc has failed.\r\n */\r\nfun calloc(sim: Simulator) {\r\n    val nitems = sim.getReg(Registers.a1).toInt()\r\n    val size = sim.getReg(Registers.a2).toInt()\r\n    val dest = sim.alloc.calloc(nitems, size)\r\n    sim.setReg(Registers.a0, dest)\r\n}\r\n\r\n/**\r\n * Takes in:\r\n * a1 ptr\r\n * a2 size\r\n *\r\n * Returns to a0 a pointer to the new malloced data or NULL if the realloc has failed.\r\n */\r\nfun realloc(sim: Simulator) {\r\n    val ptr = sim.getReg(Registers.a1).toInt()\r\n    val size = sim.getReg(Registers.a2).toInt()\r\n    val dest = sim.alloc.realloc(ptr, size)\r\n    sim.setReg(Registers.a0, dest)\r\n}\r\n\r\n/**\r\n * Takes in:\r\n * a1 ptr\r\n *\r\n * Free does not return anything\r\n */\r\nfun free(sim: Simulator) {\r\n    val ptr = sim.getReg(Registers.a1).toInt()\r\n    sim.alloc.free(ptr)\r\n}\r\n\r\n/**\r\n * Takes in nothing\r\n *\r\n * Returns the number of blocks which are not free or -1 if there was an error\r\n * Errors are currently caused by the list to be incorrectly modified.\r\n */\r\nfun mallocActiveNumBlocks(sim: Simulator) {\r\n    val amt = sim.alloc.numActiveBlocks()\r\n    sim.setReg(Registers.a0, amt)\r\n}","package venusbackend.riscv.insts.integer.base.i.ecall\r\n\r\nimport venus.Renderer\r\nimport venusbackend.simulator.Simulator\r\nimport venusbackend.toHex\r\n\r\n/**\r\n * This is a wrapper file for all basic malloc operations.\r\nMalloc Node has the format:\r\n    char*[0] where this is of size size.\r\n    uppermagic\r\n    prevNode\r\n    nextNode\r\n    free\r\n    size\r\n    lowermagic\r\nnodeAddr^\r\n*/\r\n\r\ndata class MallocNode(\r\n    var size: Int,\r\n    var free: Int,\r\n    var nextNode: Int,\r\n    var prevNode: Int,\r\n    var nodeAddr: Int,\r\n    var aupperMagic: Int = upperMagic,\r\n    var alowerMagic: Int = lowerMagic\r\n) {\r\n    companion object {\r\n        val lowBuffer = 0\r\n        val highBuffer = 0\r\n        val sizeof = 4 * 6 + lowBuffer + highBuffer\r\n        val upperMagic: Int = 0x3CBCBCBC\r\n        val lowerMagic: Int = 0x3CDCDCDC\r\n        val minSize: Int = 1\r\n        val nodes: HashMap<Int, MallocNode> = HashMap()\r\n        fun loadBlock(sim: Simulator, nodeAddr: Int, ignore_magic: Boolean = false): MallocNode? {\r\n            if (nodeAddr == 0) {\r\n                return null\r\n            }\r\n            val lM = sim.loadWordwCache(nodeAddr + lowBuffer)\r\n            val size = sim.loadWordwCache(nodeAddr + lowBuffer + 4)\r\n            val free = sim.loadWordwCache(nodeAddr + lowBuffer + 8)\r\n            val nextNode = sim.loadWordwCache(nodeAddr + lowBuffer + 12)\r\n            val prevNode = sim.loadWordwCache(nodeAddr + lowBuffer + 16)\r\n            val uM = sim.loadWordwCache(nodeAddr + lowBuffer + 20)\r\n            val node = MallocNode(\r\n                    size = size,\r\n                    free = free,\r\n                    nextNode = nextNode,\r\n                    prevNode = prevNode,\r\n                    nodeAddr = nodeAddr,\r\n                    alowerMagic = lM,\r\n                    aupperMagic = uM\r\n            )\r\n\r\n            if (((uM != upperMagic) || (lM != lowerMagic)) && !ignore_magic) {\r\n                Renderer.stderr(\"The magic value for this malloc node is incorrect! This means you are overriding malloc metadata OR have specified the address of an incorrect malloc node!\\n\")\r\n                Renderer.stderr(node)\r\n                return null\r\n            }\r\n            return node\r\n        }\r\n    }\r\n\r\n    override fun toString(): String {\r\n        return \"Node Address: ${toHex(nodeAddr)}\\nsize: ${toHex(size)} B\\nfree: ${isFree()}\\nPrevious Node Address: ${toHex(prevNode)}\\nNext Node Address: ${toHex(nextNode)}\\nLower Magic Value: A: ${toHex(alowerMagic)} E: ${toHex(lowerMagic)}\\nUpper Magic Value: A: ${toHex(aupperMagic)} E: ${toHex(upperMagic)}\\nMetadata Size: ${toHex(sizeof)} B\\nMinimum Node Size (Bytes): ${toHex(minSize)} B\\nLower Buffer Size: ${toHex(lowBuffer)} B\\nUpper Buffer Size: ${toHex(highBuffer)} B\\nSentinel: ${isSentinel()}\\nNull (not in memory): ${isNull()}\"\r\n    }\r\n\r\n    fun storeMagic(sim: Simulator) {\r\n        nodes[this.nodeAddr] = this\r\n        sim.storeWordwCache(this.nodeAddr, lowerMagic)\r\n        sim.storeWordwCache(this.nodeAddr + lowBuffer + 20, upperMagic)\r\n    }\r\n\r\n    fun storeSize(sim: Simulator) {\r\n        nodes[this.nodeAddr] = this\r\n        sim.storeWordwCache(this.nodeAddr + lowBuffer + 4, this.size)\r\n    }\r\n\r\n    fun storeFree(sim: Simulator) {\r\n        nodes[this.nodeAddr] = this\r\n        sim.storeWordwCache(this.nodeAddr + lowBuffer + 8, this.free)\r\n    }\r\n\r\n    fun storeNextNode(sim: Simulator) {\r\n        nodes[this.nodeAddr] = this\r\n        sim.storeWordwCache(this.nodeAddr + lowBuffer + 12, this.nextNode)\r\n    }\r\n\r\n    fun storePrevNode(sim: Simulator) {\r\n        nodes[this.nodeAddr] = this\r\n        sim.storeWordwCache(this.nodeAddr + lowBuffer + 16, this.prevNode)\r\n    }\r\n\r\n    fun storeNode(sim: Simulator) {\r\n        if (this.nodeAddr == 0) {\r\n            Renderer.stderr(\"Prevented a store of a null malloc node!\\n\")\r\n            return\r\n        }\r\n        this.storeMagic(sim)\r\n        this.storeSize(sim)\r\n        this.storeFree(sim)\r\n        this.storeNextNode(sim)\r\n        this.storePrevNode(sim)\r\n    }\r\n\r\n    fun isNextNull(): Boolean {\r\n        return this.nextNode == 0\r\n    }\r\n\r\n    fun isPrevNull(): Boolean {\r\n        return this.prevNode == 0\r\n    }\r\n\r\n    fun isFree(): Boolean {\r\n        return this.free != 0\r\n    }\r\n\r\n    fun isNull(): Boolean {\r\n        return this.nodeAddr == 0\r\n    }\r\n\r\n    fun isSentinel(): Boolean {\r\n        return this.size == 0 && !this.isFree() && this.isPrevNull()\r\n    }\r\n\r\n    fun canFit(size: Int): Boolean {\r\n        return this.isFree() && (this.size >= size)\r\n    }\r\n\r\n    fun dataAddr(): Int {\r\n        return this.nodeAddr + sizeof\r\n    }\r\n\r\n    fun getNextNode(sim: Simulator): MallocNode? {\r\n        return if (this.nextNode == 0) {\r\n            MallocNode(0, 1, 0, 0, 0)\r\n        } else {\r\n            loadBlock(sim, this.nextNode)\r\n        }\r\n    }\r\n\r\n    fun getPrevNode(sim: Simulator): MallocNode? {\r\n        return loadBlock(sim, this.prevNode)\r\n    }\r\n\r\n    fun allocateNode(sim: Simulator, wantedSize: Int, calloc: Boolean = false): Boolean? {\r\n        if (this.size < wantedSize) {\r\n            return false\r\n        }\r\n        this.free = 0\r\n        if (calloc) {\r\n            if (sim.memset(this.dataAddr(), 0, wantedSize) == 0) {\r\n                this.storeNode(sim)\r\n                return false\r\n            }\r\n        }\r\n        if (this.size > wantedSize + MallocNode.sizeof + MallocNode.minSize) {\r\n            val newNodeAddr = this.dataAddr() + wantedSize\r\n            val newNodeSize = this.size - (wantedSize + MallocNode.sizeof)\r\n            val newNode = MallocNode(newNodeSize, 1, this.nextNode, this.nodeAddr, newNodeAddr)\r\n            if (this.nextNode != 0) {\r\n                val nextNodeMetadata = getNextNode(sim) ?: return null\r\n                nextNodeMetadata.prevNode = newNodeAddr\r\n                nextNodeMetadata.storeNode(sim)\r\n            }\r\n            this.nextNode = newNodeAddr\r\n            this.size = wantedSize\r\n            newNode.storeNode(sim)\r\n        }\r\n        this.storeNode(sim)\r\n        return true\r\n    }\r\n\r\n    fun freeNode(sim: Simulator) {\r\n        if (this.isFree()) {\r\n            Renderer.stderr(\"Double free!\\n\")\r\n            Renderer.stderr(this)\r\n            return\r\n        }\r\n        if (this.isSentinel()) {\r\n            Renderer.stderr(\"You cannot free the sentinel node!\\n\")\r\n            Renderer.stderr(this)\r\n            return\r\n        }\r\n        this.free = 1\r\n        this.storeFree(sim)\r\n        var next: MallocNode = this\r\n        var prev: MallocNode = this\r\n        var s = 0\r\n\r\n        while (next.getNextNode(sim)?.isFree() ?: return) {\r\n            next = next.getNextNode(sim) ?: return\r\n            if (next.isNull()) {\r\n                break\r\n            }\r\n            s += MallocNode.sizeof + next.size\r\n        }\r\n\r\n        while (!prev.isSentinel() && prev.getPrevNode(sim)?.isFree() ?: return) {\r\n            prev = prev.getPrevNode(sim) ?: return\r\n            s += MallocNode.sizeof + next.size\r\n        }\r\n\r\n        if (this != next || this != prev) {\r\n            if (this != prev) {\r\n                s += MallocNode.sizeof + next.size\r\n            }\r\n            prev.size += s\r\n\r\n            prev.nextNode = next.nodeAddr\r\n            next.prevNode = prev.nodeAddr\r\n            if (!next.isNull()) {\r\n                next.storeNode(sim)\r\n            }\r\n            prev.storeNode(sim)\r\n        }\r\n\r\n//        while (!next.isNull()) {\r\n//            next = next.getNextNode(sim)!!\r\n//            if (!next.isFree()) {\r\n//                break\r\n//            }\r\n//            s += MallocNode.sizeof + next.size\r\n//        }\r\n//        var prev = this\r\n//        while (!prev.isPrevNull() && prev.getPrevNode(sim)?.isFree() == true && prev.getPrevNode(sim)?.isPrevNull() != true) {\r\n//            if (!prev.isFree()) {\r\n//                break\r\n//            }\r\n//            prev = prev.getPrevNode(sim)!!\r\n//            s += MallocNode.sizeof + prev.size\r\n//        }\r\n//        if (this != next || this != prev) {\r\n//            if (this != prev) {\r\n//                s += MallocNode.sizeof + this.size\r\n//            }\r\n//            prev.size += s\r\n//\r\n//            prev.nextNode = next.nodeAddr\r\n//            next.prevNode = prev.nodeAddr\r\n//            next.storeNode(sim)\r\n//            prev.storeNode(sim)\r\n//        }\r\n    }\r\n}\r\n\r\nclass Alloc(val sim: Simulator) {\r\n    var initialized = false\r\n    var sentinelMetadata: Int = 0\r\n\r\n    fun initialize() {\r\n        sentinelMetadata = sim.getHeapEnd().toInt()\r\n        val sentinel = MallocNode(0, 0, 0, 0, sentinelMetadata)\r\n        sim.addHeapSpace(MallocNode.sizeof + sentinel.size)\r\n        sentinel.storeNode(sim)\r\n        initialized = true\r\n    }\r\n\r\n    companion object {\r\n        fun getMetadata(ptr: Int): Int {\r\n            val loc = ptr - MallocNode.sizeof\r\n            return if (loc < 0) {\r\n                0\r\n            } else {\r\n                loc\r\n            }\r\n        }\r\n    }\r\n    var alwaysCalloc = false\r\n\r\n    fun malloc(size: Int, calloc: Boolean = alwaysCalloc): Int {\r\n        if (!initialized) {\r\n            initialize()\r\n        }\r\n        if (size <= 0) {\r\n            return 0\r\n        }\r\n        var m = MallocNode.loadBlock(sim, sentinelMetadata) ?: run {\r\n            Renderer.stderr(\"Failed to get the sentinel metadata block!\\n\")\r\n            Renderer.stderr(MallocNode.loadBlock(sim, sentinelMetadata, true) ?: \"null\")\r\n            return 0\r\n        }\r\n\r\n        while (!m.isNextNull()) {\r\n            m = m.getNextNode(sim) ?: run {\r\n                return 0\r\n            }\r\n            if (m.canFit(size)) {\r\n                if (m.allocateNode(sim, size, calloc) ?: return 0) {\r\n                    return m.dataAddr()\r\n                }\r\n            }\r\n        }\r\n        val sizeToAdd = size + MallocNode.sizeof\r\n        // TODO DO rlim check Currently there is a janky check\r\n        if (sim.willHeapOverrideStack(sizeToAdd)) {\r\n            return 0\r\n        }\r\n\r\n        val newMallocNode = MallocNode(size, 0, 0, m.nodeAddr, sim.getHeapEnd().toInt())\r\n        sim.addHeapSpace(sizeToAdd)\r\n        m.nextNode = newMallocNode.nodeAddr\r\n        m.storeNextNode(sim)\r\n        newMallocNode.storeNode(sim)\r\n        return newMallocNode.dataAddr()\r\n    }\r\n\r\n    fun calloc(nitems: Int, size: Int): Int {\r\n        return this.malloc(nitems * size, calloc = true)\r\n    }\r\n\r\n    fun realloc(ptr: Int, size: Int): Int {\r\n        if (size == 0) {\r\n            return if (ptr == 0) {\r\n                0\r\n            } else {\r\n                this.free(ptr)\r\n                0\r\n            }\r\n        }\r\n        val tm: MallocNode? = MallocNode.loadBlock(sim, getMetadata(ptr))\r\n        if ((ptr == 0) || (tm == null)) {\r\n            return this.malloc(size)\r\n        }\r\n        var m: MallocNode = tm\r\n        val newBlock: Int = malloc(size)\r\n        if (newBlock == 0) {\r\n            return 0\r\n        }\r\n        sim.memcpy(newBlock, m.dataAddr(), size)\r\n        m.freeNode(sim)\r\n        return newBlock\r\n    }\r\n\r\n    fun free(ptr: Int) {\r\n        if (ptr != 0) {\r\n            MallocNode.loadBlock(sim, getMetadata(ptr))?.freeNode(sim)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Counts the number of blocks which are not free.\r\n     * Returns -1 if an error has occurred (aka a corrupted list)\r\n     */\r\n    fun numActiveBlocks(): Int {\r\n        if (!initialized) {\r\n            return 0\r\n        }\r\n        var counter = 0\r\n        var m = MallocNode.loadBlock(sim, sentinelMetadata) ?: run {\r\n            Renderer.stderr(\"Failed to get the sentinel metadata block!\\n\")\r\n            Renderer.stderr(MallocNode.loadBlock(sim, sentinelMetadata, true) ?: \"null\")\r\n            return -1\r\n        }\r\n        if (m.isNextNull()) {\r\n            // We do not want to count the sentinel block!\r\n            return counter\r\n        }\r\n        m = m.getNextNode(sim) ?: return -1\r\n        while (!m.isNextNull()) {\r\n            if (!m.isFree()) {\r\n                if (m.size > 0) { // We want to ignore the sentinel node.\r\n                    counter++\r\n                }\r\n            }\r\n            // If we fail to get the next node when it should exist, we must return -1 to indicate an error.\r\n            m = m.getNextNode(this.sim) ?: return -1\r\n        }\r\n        return counter\r\n    }\r\n}","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.DoNothingParser\r\n\r\nval fencei = Instruction(\r\n        name = \"fence.i\",\r\n        format = InstructionFormat(4,\r\n                listOf(FieldEqual(InstructionField.ENTIRE, 0b000000000000_00000_001_00000_0001111))\r\n        ),\r\n        parser = DoNothingParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = NoImplementation,\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = RawDisassembler { \"fence.i\" }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.DoNothingParser\r\n\r\nval fence = Instruction(\r\n        name = \"fence\",\r\n        format = InstructionFormat(4,\r\n                listOf(FieldEqual(InstructionField.ENTIRE, 0b000000000000_00000_000_00000_0001111))\r\n        ),\r\n        parser = DoNothingParser,\r\n        impl16 = NoImplementation,\r\n        impl32 = NoImplementation,\r\n        impl64 = NoImplementation,\r\n        impl128 = NoImplementation,\r\n        disasm = RawDisassembler { \"fence\" }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\n// import venusbackend.assembler.AssemblerError\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.base.ITypeFormat\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.riscv.insts.dsl.parsers.base.ITypeParser\r\n// import venusbackend.riscv.insts.dsl.parsers.base.LoadParser\r\nimport venusbackend.riscv.insts.dsl.parsers.RawParser\r\n\r\nval jalr = Instruction(\r\n        name = \"jalr\",\r\n        format = ITypeFormat(\r\n                opcode = 0b1100111,\r\n                funct3 = 0b000\r\n        ),\r\n        parser = RawParser { prog, mcode, args, dbg ->\r\n//            try {\r\n                ITypeParser(prog, mcode, args, dbg)\r\n//            } catch (e: AssemblerError) {\r\n//                /* Try base displacement notation */\r\n//                try {\r\n//                    LoadParser(prog, mcode, args, dbg)\r\n//                } catch (e_two: AssemblerError) {\r\n//                    throw e\r\n//                }\r\n//            }\r\n        },\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rs1 = mcode[InstructionField.RS1].toInt()\r\n            val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n            val vrs1 = sim.getReg(rs1).toInt()\r\n            sim.setReg(rd, sim.getPC().toInt() + mcode.length)\r\n            sim.setPC(((vrs1 + imm) shr 1) shl 1)\r\n            sim.jumped = true\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rs1 = mcode[InstructionField.RS1].toInt()\r\n            val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12).toLong()\r\n            val vrs1 = sim.getReg(rs1).toLong()\r\n            sim.setReg(rd, sim.getPC().toLong() + mcode.length)\r\n            sim.setPC(((vrs1 + imm) shr 1) shl 1)\r\n            sim.jumped = true\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rs1 = mcode[InstructionField.RS1].toInt()\r\n            val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12).toQuadWord()\r\n            val vrs1 = sim.getReg(rs1).toQuadWord()\r\n            sim.setReg(rd, sim.getPC().toQuadWord() + mcode.length)\r\n            sim.setPC(((vrs1 + imm) shr 1) shl 1)\r\n            sim.jumped = true\r\n        },\r\n        disasm = RawDisassembler { mcode ->\r\n            val rd = mcode[InstructionField.RD]\r\n            val rs1 = mcode[InstructionField.RS1]\r\n            val imm = signExtend(mcode[InstructionField.IMM_11_0].toInt(), 12)\r\n            \"jalr x$rd x$rs1 $imm\"\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\n\r\nval lb = LoadTypeInstruction(\r\n        name = \"lb\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b000,\r\n//        load16 = NoImplementation,\r\n//        postLoad16 = NoImplementation,\r\n        load32 = { sim, address -> sim.loadBytewCache(address).toInt() },\r\n        postLoad32 = { v -> signExtend(v, 8) },\r\n        load64 = { sim, address -> sim.loadBytewCache(address).toLong() },\r\n        postLoad64 = { v -> signExtend(v.toInt(), 8).toLong() },\r\n        load128 = { sim, address -> sim.loadBytewCache(address).toQuadWord() },\r\n        postLoad128 = { v -> signExtend(v.toInt(), 8).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\n\r\nval lbu = LoadTypeInstruction(\r\n        name = \"lbu\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b100,\r\n//        load16 = NoImplementation,\r\n        load32 = { sim, addr -> sim.loadBytewCache(addr).toInt() },\r\n        load64 = { sim, addr -> sim.loadBytewCache(addr).toLong() },\r\n        load128 = { sim, addr -> sim.loadBytewCache(addr).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nval ld = LoadTypeInstruction(\r\n        name = \"ld\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b011,\r\n        load16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"LD is not supported by 16 bit systems!\")\r\n        },\r\n        load32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"LD is not supported by 32 bit systems!\")\r\n        },\r\n        load64 = Simulator::loadLongwCache,\r\n        load128 = { sim, addr ->\r\n            sim.loadLongwCache(addr).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\n\r\nval lh = LoadTypeInstruction(\r\n        name = \"lh\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b001,\r\n        load16 = { sim, address -> sim.loadHalfWordwCache(address).toShort() },\r\n        postLoad16 = { v -> v },\r\n        load32 = { sim, address -> sim.loadHalfWordwCache(address) },\r\n        postLoad32 = { v -> signExtend(v, 16) },\r\n        load64 = { sim, address -> sim.loadHalfWordwCache(address).toLong() },\r\n        postLoad64 = { v -> signExtend(v.toInt(), 16).toLong() },\r\n        load128 = { sim, address -> sim.loadHalfWordwCache(address).toQuadWord() },\r\n        postLoad128 = { v -> signExtend(v.toInt(), 16).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\n\r\nval lhu = LoadTypeInstruction(\r\n        name = \"lhu\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b101,\r\n        load16 = { sim, address -> sim.loadHalfWordwCache(address).toShort() },\r\n        load32 = { sim, address -> sim.loadHalfWordwCache(address) },\r\n        load64 = { sim, address -> sim.loadHalfWordwCache(address).toLong() },\r\n        load128 = { sim, address -> sim.loadHalfWordwCache(address).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nval lw = LoadTypeInstruction(\r\n        name = \"lw\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b010,\r\n        load16 = { sim, addr ->\r\n            throw InstructionNotSupportedError(\"LW is not supported by 16 bit systems!\")\r\n        },\r\n        load32 = Simulator::loadWordwCache,\r\n        load64 = { sim, addr -> sim.loadWordwCache(addr).toLong() },\r\n        load128 = { sim, addr -> sim.loadWordwCache(addr).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toUQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.LoadTypeInstruction\r\nimport venusbackend.simulator.Simulator\r\n\r\nval lwu = LoadTypeInstruction(\r\n        name = \"lwu\",\r\n        opcode = 0b0000011,\r\n        funct3 = 0b010,\r\n        load16 = { sim, address ->\r\n            throw InstructionNotSupportedError(\"lwu is not supported by 16 bit systems!\")\r\n        },\r\n        load32 = Simulator::loadWordwCache,\r\n        load64 = { sim, address ->\r\n            sim.loadWordwCache(address).toULong().toLong()\r\n        },\r\n        load128 = { sim, address ->\r\n            sim.loadWordwCache(address).toUQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval ori = ITypeInstruction(\r\n        name = \"ori\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b110,\r\n        eval16 = { a, b -> (a.toInt() or b.toInt()).toShort() },\r\n        eval32 = { a, b -> a or b },\r\n        eval64 = { a, b -> a or b },\r\n        eval128 = { a, b -> a or b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftImmediateInstruction\r\n\r\nval slli = ShiftImmediateInstruction(\r\n        name = \"slli\",\r\n        funct3 = 0b001,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> if (b == 0.toShort()) a else ((a.toInt() shl b.toInt()).toShort()) },\r\n        eval32 = { a, b -> if (b == 0) a else (a shl b) },\r\n        eval64 = { a, b -> if (b == 0.toLong()) a else (a shl b.toInt()) },\r\n        eval128 = { a, b -> if (b == 0.toQuadWord()) a else (a shl b.toInt()) }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftWImmediateInstruction\r\n\r\nval slliw = ShiftWImmediateInstruction(\r\n        name = \"slliw\",\r\n        opcode = 0b0011011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"slliw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"slliw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b == 0L) a.toInt().toLong() else (a.toInt() shl b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b == 0.toQuadWord()) a.toInt().toQuadWord() else (a.toInt() shl b.toInt()).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval slti = ITypeInstruction(\r\n        name = \"slti\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b010,\r\n        eval16 = { a, b -> if (a < b) 1 else 0 },\r\n        eval32 = { a, b -> if (a < b) 1 else 0 },\r\n        eval64 = { a, b -> if (a < b) 1 else 0 },\r\n        eval128 = { a, b -> if (a < b) 1.toQuadWord() else 0.toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\nimport venusbackend.riscv.insts.dsl.compareUnsigned\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedLong\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedQuadWord\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedShort\r\n\r\nval sltiu = ITypeInstruction(\r\n        name = \"sltiu\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b011,\r\n        eval16 = { a, b -> if (compareUnsignedShort(a, b) < 0) 1 else 0 },\r\n        eval32 = { a, b -> if (compareUnsigned(a, b) < 0) 1 else 0 },\r\n        eval64 = { a, b -> if (compareUnsignedLong(a, b) < 0) 1 else 0 },\r\n        eval128 = { a, b -> if (compareUnsignedQuadWord(a, b) < 0) 1.toQuadWord() else 0.toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftImmediateInstruction\r\n\r\nval srai = ShiftImmediateInstruction(\r\n        name = \"srai\",\r\n        funct3 = 0b101,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b -> if (b == 0.toShort()) a else ((a.toInt() shr b.toInt()).toShort()) },\r\n        eval32 = { a, b -> if (b == 0) a else (a shr b) },\r\n        eval64 = { a, b -> if (b == 0.toLong()) a else (a shr b.toInt()) },\r\n        eval128 = { a, b -> if (b == 0.toQuadWord()) a else (a shr b.toInt()) }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftWImmediateInstruction\r\n\r\nval sraiw = ShiftWImmediateInstruction(\r\n        name = \"sraiw\",\r\n        opcode = 0b0011011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sraiw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sraiw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b == 0L) a.toInt().toLong() else (a.toInt() shr b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b == 0.toQuadWord()) a.toInt().toQuadWord() else (a.toInt() shr b.toInt()).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftImmediateInstruction\r\n\r\nval srli = ShiftImmediateInstruction(\r\n        name = \"srli\",\r\n        funct3 = 0b101,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> if (b == 0.toShort()) a else ((a.toInt() ushr b.toInt()).toShort()) },\r\n        eval32 = { a, b -> if (b == 0) a else (a ushr b) },\r\n        eval64 = { a, b -> if (b == 0.toLong()) a else (a ushr b.toInt()) },\r\n        eval128 = { a, b -> if (b == 0.toQuadWord()) a else (a ushr b.toInt()) }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.ShiftWImmediateInstruction\r\n\r\nval srliw = ShiftWImmediateInstruction(\r\n        name = \"srliw\",\r\n        opcode = 0b0011011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"srliw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"srliw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b == 0L) a.toInt().toLong() else (a.toInt() ushr b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b == 0.toQuadWord()) a.toInt().toQuadWord() else (a.toInt() ushr b.toInt()).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.i\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.ITypeInstruction\r\n\r\nval xori = ITypeInstruction(\r\n        name = \"xori\",\r\n        opcode = 0b0010011,\r\n        funct3 = 0b100,\r\n        eval16 = { a, b -> (a.toInt() xor b.toInt()).toShort() },\r\n        eval32 = { a, b -> a xor b },\r\n        eval64 = { a, b -> a xor b },\r\n        eval128 = { a, b -> a xor b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval add = RTypeInstruction(\r\n        name = \"add\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = { a, b -> a + b },\r\n        eval64 = { a, b -> a + b },\r\n        eval128 = { a, b -> a + b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval addw = RTypeInstruction(\r\n        name = \"addw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"addw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"addw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b -> (a.toInt() + b.toInt()).toLong() },\r\n        eval128 = { a, b -> (a.toInt() + b.toInt()).toQuadWord() }\r\n)","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval and = RTypeInstruction(\r\n        name = \"and\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b111,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> (a.toInt() and b.toInt()).toShort() },\r\n        eval32 = { a, b -> a and b },\r\n        eval64 = { a, b -> a and b },\r\n        eval128 = { a, b -> a and b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval or = RTypeInstruction(\r\n        name = \"or\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b110,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> (a.toInt() or b.toInt()).toShort() },\r\n        eval32 = { a, b -> a or b },\r\n        eval64 = { a, b -> a or b },\r\n        eval128 = { a, b -> a or b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\nimport venusbackend.shl\r\nimport kotlin.experimental.and\r\n\r\nval sll = RTypeInstruction(\r\n        name = \"sll\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            val shift = b and 0b11111\r\n            if (shift == 0.toShort()) a else (a shl shift).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val shift = b and 0b11111\r\n            if (shift == 0) a else a shl shift\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b111111\r\n            if (shift == 0) a else a shl shift\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b1111111\r\n            if (shift == 0) a else a shl shift\r\n        }\r\n)\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval sllw = RTypeInstruction(\r\n        name = \"sllw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sllw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sllw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toLong() else (a.toInt() shl shift).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toQuadWord() else (a.toInt() shl shift).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval slt = RTypeInstruction(\r\n        name = \"slt\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b010,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> if (a < b) 1 else 0 },\r\n        eval32 = { a, b -> if (a < b) 1 else 0 },\r\n        eval64 = { a, b -> if (a < b) 1 else 0 },\r\n        eval128 = { a, b -> if (a < b) 1.toQuadWord() else 0.toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\nimport venusbackend.riscv.insts.dsl.compareUnsigned\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedLong\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedQuadWord\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedShort\r\n\r\nval sltu = RTypeInstruction(\r\n        name = \"sltu\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b011,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> if (compareUnsignedShort(a, b) < 0) 1 else 0 },\r\n        eval32 = { a, b -> if (compareUnsigned(a, b) < 0) 1 else 0 },\r\n        eval64 = { a, b -> if (compareUnsignedLong(a, b) < 0) 1 else 0 },\r\n        eval128 = { a, b -> if (compareUnsignedQuadWord(a, b) < 0) 1.toQuadWord() else 0.toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\nimport venusbackend.shr\r\nimport kotlin.experimental.and\r\n\r\nval sra = RTypeInstruction(\r\n        name = \"sra\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b ->\r\n            val shift = b and 0b1111\r\n            if (shift == 0.toShort()) a else (a shr shift).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val shift = b and 0b11111\r\n            if (shift == 0) a else a shr shift\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b111111\r\n            if (shift == 0) a else a shr shift\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b1111111\r\n            if (shift == 0) a else a shr shift\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval sraw = RTypeInstruction(\r\n        name = \"sraw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sraw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"sraw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toLong() else (a.toInt() shr shift).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toQuadWord() else (a.toInt() shr shift).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\nimport venusbackend.ushr\r\nimport kotlin.experimental.and\r\n\r\nval srl = RTypeInstruction(\r\n        name = \"srl\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            val shift = b and 0b1111\r\n            if (shift == 0.toShort()) a else (a ushr shift).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val shift = b and 0b11111\r\n            if (shift == 0) a else a ushr shift\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b111111\r\n            if (shift == 0) a else a ushr shift\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b1111111\r\n            if (shift == 0) a else a ushr shift\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval srlw = RTypeInstruction(\r\n        name = \"srlw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"srlw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"srlw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toLong() else (a.toInt() ushr shift).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val shift = b.toInt() and 0b11111\r\n            if (shift == 0) a.toInt().toQuadWord() else (a.toInt() ushr shift).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval sub = RTypeInstruction(\r\n        name = \"sub\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b -> (a - b).toShort() },\r\n        eval32 = { a, b -> a - b },\r\n        eval64 = { a, b -> a - b },\r\n        eval128 = { a, b -> a - b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval subw = RTypeInstruction(\r\n        name = \"subw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0100000,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"subw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"subw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            (a.toInt() - b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            (a.toInt() - b.toInt()).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval xor = RTypeInstruction(\r\n        name = \"xor\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b100,\r\n        funct7 = 0b0000000,\r\n        eval16 = { a, b -> (a.toInt() xor b.toInt()).toShort() },\r\n        eval32 = { a, b -> a xor b },\r\n        eval64 = { a, b -> a xor b },\r\n        eval128 = { a, b -> a xor b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.s\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.STypeInstruction\r\n\r\nval sb = STypeInstruction(\r\n        name = \"sb\",\r\n        opcode = 0b0100011,\r\n        funct3 = 0b000,\r\n        store16 = { sim, address, value ->\r\n            sim.storeBytewCache(address, value)\r\n        },\r\n        store32 = { sim, address, value ->\r\n            sim.storeBytewCache(address, value)\r\n        },\r\n        store64 = { sim, address, value ->\r\n            sim.storeBytewCache(address, value)\r\n        },\r\n        store128 = { sim, address, value ->\r\n            sim.storeBytewCache(address, value)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.s\r\n\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.STypeInstruction\r\n\r\nval sd = STypeInstruction(\r\n        name = \"sd\",\r\n        opcode = 0b0100011,\r\n        funct3 = 0b011,\r\n        store16 = { sim, address, value ->\r\n            throw InstructionNotSupportedError(\"sd is not supported on 32 bit systems!\")\r\n        },\r\n        store32 = { sim, address, value ->\r\n            throw InstructionNotSupportedError(\"sd is not supported on 64 bit systems!\")\r\n        },\r\n        store64 = { sim, address, value ->\r\n            sim.storeLongwCache(address, value)\r\n        },\r\n        store128 = { sim, address, value ->\r\n            sim.storeLongwCache(address, value)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.s\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.STypeInstruction\r\n\r\nval sh = STypeInstruction(\r\n        name = \"sh\",\r\n        opcode = 0b0100011,\r\n        funct3 = 0b001,\r\n        store16 = { sim, address, value ->\r\n            sim.storeHalfWordwCache(address, value)\r\n        },\r\n        store32 = { sim, address, value ->\r\n            sim.storeHalfWordwCache(address, value)\r\n        },\r\n        store64 = { sim, address, value ->\r\n            sim.storeHalfWordwCache(address, value)\r\n        },\r\n        store128 = { sim, address, value ->\r\n            sim.storeHalfWordwCache(address, value)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.s\r\n\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.STypeInstruction\r\n\r\nval sw = STypeInstruction(\r\n        name = \"sw\",\r\n        opcode = 0b0100011,\r\n        funct3 = 0b010,\r\n        store16 = { sim, address, value ->\r\n            throw InstructionNotSupportedError(\"sw is not supported on 16 bit systems!\")\r\n        },\r\n        store32 = { sim, address, value ->\r\n            sim.storeWordwCache(address, value)\r\n        },\r\n        store64 = { sim, address, value ->\r\n            sim.storeWordwCache(address, value)\r\n        },\r\n        store128 = { sim, address, value ->\r\n            sim.storeWordwCache(address, value)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\n\r\nval beq = BTypeInstruction(\r\n        name = \"beq\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b000,\r\n        cond16 = { a, b -> a == b },\r\n        cond32 = { a, b -> a == b },\r\n        cond64 = { a, b -> a == b },\r\n        cond128 = { a, b -> a == b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\n\r\nval bge = BTypeInstruction(\r\n        name = \"bge\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b101,\r\n        cond16 = { a, b -> a >= b },\r\n        cond32 = { a, b -> a >= b },\r\n        cond64 = { a, b -> a >= b },\r\n        cond128 = { a, b -> a >= b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\nimport venusbackend.riscv.insts.dsl.compareUnsigned\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedLong\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedQuadWord\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedShort\r\n\r\nval bgeu = BTypeInstruction(\r\n        name = \"bgeu\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b111,\r\n        cond16 = { a, b -> compareUnsignedShort(a, b) >= 0 },\r\n        cond32 = { a, b -> compareUnsigned(a, b) >= 0 },\r\n        cond64 = { a, b -> compareUnsignedLong(a, b) >= 0 },\r\n        cond128 = { a, b -> compareUnsignedQuadWord(a, b) >= 0 }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\n\r\nval blt = BTypeInstruction(\r\n        name = \"blt\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b100,\r\n        cond16 = { a, b -> a < b },\r\n        cond32 = { a, b -> a < b },\r\n        cond64 = { a, b -> a < b },\r\n        cond128 = { a, b -> a < b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\nimport venusbackend.riscv.insts.dsl.compareUnsigned\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedLong\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedQuadWord\r\nimport venusbackend.riscv.insts.dsl.compareUnsignedShort\r\n\r\nval bltu = BTypeInstruction(\r\n        name = \"bltu\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b110,\r\n        cond16 = { a, b -> compareUnsignedShort(a, b) < 0 },\r\n        cond32 = { a, b -> compareUnsigned(a, b) < 0 },\r\n        cond64 = { a, b -> compareUnsignedLong(a, b) < 0 },\r\n        cond128 = { a, b -> compareUnsignedQuadWord(a, b) < 0 }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.sb\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.BTypeInstruction\r\n\r\nval bne = BTypeInstruction(\r\n        name = \"bne\",\r\n        opcode = 0b1100011,\r\n        funct3 = 0b001,\r\n        cond16 = { a, b -> a != b },\r\n        cond32 = { a, b -> a != b },\r\n        cond64 = { a, b -> a != b },\r\n        cond128 = { a, b -> a != b }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.u\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.UTypeInstruction\r\n\r\nval auipc = UTypeInstruction(\r\n        name = \"auipc\",\r\n        opcode = 0b0010111,\r\n        impl16 = { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"auipc is not supported on 16 bit systems!\")\r\n        },\r\n        impl32 = { mcode, sim ->\r\n            val offset = mcode[InstructionField.IMM_31_12].toInt() shl 12\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), sim.getPC().toInt() + offset)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = { mcode, sim ->\r\n            val offset = (mcode[InstructionField.IMM_31_12].toInt() shl 12).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), sim.getPC().toLong() + offset)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = { mcode, sim ->\r\n            val offset = (mcode[InstructionField.IMM_31_12].toInt() shl 12).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), sim.getPC().toQuadWord() + offset)\r\n            sim.incrementPC(mcode.length)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.u\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.UTypeInstruction\r\n\r\nval lui = UTypeInstruction(\r\n        name = \"lui\",\r\n        opcode = 0b0110111,\r\n        impl16 = { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"lui is not supported on 16 bit systems!\")\r\n        },\r\n        impl32 = { mcode, sim ->\r\n            val imm = mcode[InstructionField.IMM_31_12].toInt() shl 12\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), imm)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = { mcode, sim ->\r\n            val imm = (mcode[InstructionField.IMM_31_12].toInt() shl 12).toLong()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), imm)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = { mcode, sim ->\r\n            val imm = (mcode[InstructionField.IMM_31_12].toInt() shl 12).toQuadWord()\r\n            sim.setReg(mcode[InstructionField.RD].toInt(), imm)\r\n            sim.incrementPC(mcode.length)\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.base.uj\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeFormat\r\nimport venusbackend.riscv.insts.dsl.getImmWarning\r\nimport venusbackend.riscv.insts.dsl.impls.NoImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.impls.setBitslice\r\nimport venusbackend.riscv.insts.dsl.impls.signExtend\r\nimport venusbackend.riscv.insts.dsl.parsers.RawParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\nimport venusbackend.riscv.insts.dsl.relocators.JALRelocator\r\nimport venusbackend.riscv.userStringToInt\r\nimport venusbackend.riscv.venusInternalLabels\r\n\r\nval jal = Instruction(\r\n        name = \"jal\",\r\n        format = OpcodeFormat(0b1101111),\r\n        parser = RawParser { prog, mcode, args, dbg ->\r\n            checkArgsLength(args.size, 2, dbg)\r\n\r\n            mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n            val label = if (prog.labels.containsKey(args[1]) || args[1].matches(Regex(\"\\\\d+[fb]\"))) {\r\n                args[1]\r\n            } else {\r\n                try {\r\n                    getImmWarning += \"Interpreting label as offset!; \"\r\n                    venusInternalLabels + (prog.textSize + userStringToInt(args[1]))\r\n                } catch (e: Throwable) {\r\n                    getImmWarning = getImmWarning.replace(\"Interpreting label as offset!; \", \"\")\r\n                    args[1]\r\n                }\r\n            }\r\n            if (label.matches(Regex(\"\\\\d+[fb]\"))) {\r\n                val location: Int = prog.getLabelOffset(label, prog.textSize, dbg)!! + prog.textSize // I have to add the textsize since I remove it in the get label offset!\r\n                JALRelocator.invoke(mcode, prog.textSize, location, dbg = dbg)\r\n            } else {\r\n                prog.addRelocation(JALRelocator, label, 0, dbg = dbg)\r\n            }\r\n        },\r\n        impl16 = NoImplementation,\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val imm = constructJALImmediate(mcode)\r\n            sim.setReg(rd, sim.getPC().toInt() + mcode.length)\r\n            sim.incrementPC(imm)\r\n            sim.jumped = true\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val imm = constructJALImmediate(mcode).toLong()\r\n            sim.setReg(rd, sim.getPC().toLong() + mcode.length)\r\n            sim.incrementPC(imm)\r\n            sim.jumped = true\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val imm = constructJALImmediate(mcode).toQuadWord()\r\n            sim.setReg(rd, sim.getPC().toQuadWord() + mcode.length)\r\n            sim.incrementPC(imm)\r\n            sim.jumped = true\r\n        },\r\n        disasm = RawDisassembler { mcode ->\r\n            val rd = mcode[InstructionField.RD]\r\n            val imm = constructJALImmediate(mcode)\r\n            \"jal x$rd $imm\"\r\n        }\r\n)\r\n\r\nprivate fun constructJALImmediate(mcode: MachineCode): Int {\r\n    val imm_20 = mcode[InstructionField.IMM_20].toInt()\r\n    val imm_10_1 = mcode[InstructionField.IMM_10_1].toInt()\r\n    val imm_11 = mcode[InstructionField.IMM_11_J].toInt()\r\n    val imm_19_12 = mcode[InstructionField.IMM_19_12].toInt()\r\n    var imm = 0\r\n    imm = setBitslice(imm, imm_20, 20, 21)\r\n    imm = setBitslice(imm, imm_10_1, 1, 11)\r\n    imm = setBitslice(imm, imm_11, 11, 12)\r\n    imm = setBitslice(imm, imm_19_12, 12, 20)\r\n    return signExtend(imm, 21)\r\n}\r\n","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amoaddweval32 = { data: Int, vrs2: Int -> data + vrs2 }\r\n\r\nval amoaddw = AMORTypeInstruction(\r\n        name = \"amoadd.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00000,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoaddweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoaddwaq = AMORTypeInstruction(\r\n        name = \"amoadd.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00000,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoaddweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoaddwrl = AMORTypeInstruction(\r\n        name = \"amoadd.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00000,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoaddweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoaddwaqrl = AMORTypeInstruction(\r\n        name = \"amoadd.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoaddweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoaddwrlaq = AMORTypeInstruction(\r\n        name = \"amoadd.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoaddweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amoandweval32 = { data: Int, vrs2: Int -> data and vrs2 }\r\n\r\nval amoandw = AMORTypeInstruction(\r\n        name = \"amoand.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01100,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoandweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoandwaq = AMORTypeInstruction(\r\n        name = \"amoand.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01100,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoandweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoandwrl = AMORTypeInstruction(\r\n        name = \"amoand.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01100,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoandweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoandwaqrl = AMORTypeInstruction(\r\n        name = \"amoand.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoandweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoandwrlaq = AMORTypeInstruction(\r\n        name = \"amoand.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoandweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amomaxweval32 = { data: Int, vrs2: Int -> maxOf(data, vrs2) }\r\n\r\nval amomaxw = AMORTypeInstruction(\r\n        name = \"amomax.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10100,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxwaq = AMORTypeInstruction(\r\n        name = \"amomax.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10100,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxwrl = AMORTypeInstruction(\r\n        name = \"amomax.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10100,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxwaqrl = AMORTypeInstruction(\r\n        name = \"amomax.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxwrlaq = AMORTypeInstruction(\r\n        name = \"amomax.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\n/*todo test if this 'unsigned' conversion works*/\r\nval amomaxuweval32 = { data: Int, vrs2: Int -> maxOf(data xor Int.MIN_VALUE, vrs2 xor Int.MIN_VALUE) }\r\n\r\nval amomaxuw = AMORTypeInstruction(\r\n        name = \"amomaxu.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11100,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxuwaq = AMORTypeInstruction(\r\n        name = \"amomaxu.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11100,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxuwrl = AMORTypeInstruction(\r\n        name = \"amomaxu.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11100,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxuwaqrl = AMORTypeInstruction(\r\n        name = \"amomaxu.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amomaxuwrlaq = AMORTypeInstruction(\r\n        name = \"amomaxu.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amomaxuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amominweval32 = { data: Int, vrs2: Int -> minOf(data, vrs2) }\r\n\r\nval amominw = AMORTypeInstruction(\r\n        name = \"amomin.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10000,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominwaq = AMORTypeInstruction(\r\n        name = \"amomin.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominwrl = AMORTypeInstruction(\r\n        name = \"amomin.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = { data, vrs2 -> minOf(data, vrs2) }\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominwaqrl = AMORTypeInstruction(\r\n        name = \"amomin.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominwrlaq = AMORTypeInstruction(\r\n        name = \"amomin.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b10000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amominuweval32 = { data: Int, vrs2: Int -> minOf(data xor Int.MIN_VALUE, vrs2 xor Int.MIN_VALUE) }\r\n\r\nval amominuw = AMORTypeInstruction(\r\n        name = \"amominu.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11000,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominuwaq = AMORTypeInstruction(\r\n        name = \"amominu.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11000,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominuwrl = AMORTypeInstruction(\r\n        name = \"amominu.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11000,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominuwaqrl = AMORTypeInstruction(\r\n        name = \"amominu.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amominuwrlaq = AMORTypeInstruction(\r\n        name = \"amominu.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b11000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amominuweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amoorweval32 = { data: Int, vrs2: Int -> data or vrs2 }\r\n\r\nval amoorw = AMORTypeInstruction(\r\n        name = \"amoor.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01000,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoorwaq = AMORTypeInstruction(\r\n        name = \"amoor.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01000,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoorwrl = AMORTypeInstruction(\r\n        name = \"amoor.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01000,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoorwaqrl = AMORTypeInstruction(\r\n        name = \"amoor.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoorwrlaq = AMORTypeInstruction(\r\n        name = \"amoor.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b01000,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amoswapweval32 = { data: Int, vrs2: Int -> vrs2 }\r\n\r\nval amoswapw = AMORTypeInstruction(\r\n        name = \"amoswap.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00001,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoswapweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoswapwaq = AMORTypeInstruction(\r\n        name = \"amoswap.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00001,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoswapweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoswapwrl = AMORTypeInstruction(\r\n        name = \"amoswap.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00001,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoswapweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoswapwaqrl = AMORTypeInstruction(\r\n        name = \"amoswap.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00001,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoswapweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoswapwrlaq = AMORTypeInstruction(\r\n        name = \"amoswap.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00001,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoswapweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n\r\nval amoxorweval32 = { data: Int, vrs2: Int -> data xor vrs2 }\r\n\r\nval amoxorw = AMORTypeInstruction(\r\n        name = \"amoxor.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00100,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoxorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoxorwaq = AMORTypeInstruction(\r\n        name = \"amoxor.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00100,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoxorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoxorwrl = AMORTypeInstruction(\r\n        name = \"amoxor.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00100,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoxorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoxorwaqrl = AMORTypeInstruction(\r\n        name = \"amoxor.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoxorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval amoxorwrlaq = AMORTypeInstruction(\r\n        name = \"amoxor.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00100,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = amoxorweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\nval lrweval32 = { data: Int, vrs2: Int -> data }\r\n/*@FIXME*/\r\nval lrw = AMORTypeInstruction(\r\n        name = \"lr.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00010,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = lrweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval lrwaq = AMORTypeInstruction(\r\n        name = \"lr.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00010,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = lrweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval lrwrl = AMORTypeInstruction(\r\n        name = \"lr.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00010,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = lrweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval lrwaqrl = AMORTypeInstruction(\r\n        name = \"lr.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00010,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = lrweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval lrwrlaq = AMORTypeInstruction(\r\n        name = \"lr.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00010,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = lrweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.atomic.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.atomic.AMORTypeInstruction\r\n/*@FIXME*/\r\nval scweval32 = { data: Int, vrs2: Int -> data xor vrs2 }\r\n\r\nval scw = AMORTypeInstruction(\r\n        name = \"sc.w\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00011,\r\n        rl = 0b0,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = scweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval scwaq = AMORTypeInstruction(\r\n        name = \"sc.w.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00011,\r\n        rl = 0b0,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = scweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval scwrl = AMORTypeInstruction(\r\n        name = \"sc.w.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00011,\r\n        rl = 0b1,\r\n        aq = 0b0,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = scweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval scwaqrl = AMORTypeInstruction(\r\n        name = \"sc.w.aq.rl\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00011,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = scweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)\r\n\r\nval scwrlaq = AMORTypeInstruction(\r\n        name = \"sc.w.rl.aq\",\r\n        opcode = 0b0101111,\r\n        funct3 = 0b010,\r\n        funct5 = 0b00011,\r\n        rl = 0b1,\r\n        aq = 0b1,\r\n        // eval16 = { a, b -> (a + b).toShort() },\r\n        eval32 = scweval32\r\n        // eval64 = { a, b -> a + b },\r\n        // eval128 = { a, b -> a + b }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.InstructionReservedError\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval caddw = CATypeInstruction(\r\n        name = \"c.addw\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b01,\r\n        funct6 = 0b100111,\r\n        eval32 = { _, _ ->\r\n            throw InstructionReservedError(\"This instruction is reserved in RV32\")\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval cand = CATypeInstruction(\r\n        name = \"c.and\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b11,\r\n        funct6 = 0b100011,\r\n        eval32 = { a, b ->\r\n            a and b\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval cor = CATypeInstruction(\r\n        name = \"c.or\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b10,\r\n        funct6 = 0b100011,\r\n        eval32 = { a, b ->\r\n            a xor b\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval csub = CATypeInstruction(\r\n        name = \"c.sub\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b00,\r\n        funct6 = 0b100011,\r\n        eval32 = { a, b ->\r\n            a - b\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.InstructionReservedError\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval csubw = CATypeInstruction(\r\n        name = \"c.subw\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b00,\r\n        funct6 = 0b100111,\r\n        eval32 = { _, _ ->\r\n            throw InstructionReservedError(\"This instruction is reserved in RV32\")\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ca\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CATypeInstruction\r\n\r\nval cxor = CATypeInstruction(\r\n        name = \"c.xor\",\r\n        opcode2 = 0b01,\r\n        funct2 = 0b01,\r\n        funct6 = 0b100011,\r\n        eval32 = { a, b ->\r\n            a xor b\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ci\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeCFunct3Format\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.RawParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport kotlin.math.pow\r\n\r\nval caddi = Instruction(\r\n        name = \"c.addi\",\r\n        format = OpcodeCFunct3Format(0b01, 0b000, arrayOf(\r\n                FieldEqual(InstructionField.RD, 0, true),\r\n                FieldEqual(InstructionField.IMM_b2_b6, 0, true, listOf(InstructionField.IMM_b12))\r\n        )),\r\n        parser = RawParser { prog, mcode, args, dbg ->\r\n            checkArgsLength(args.size, 2, dbg)\r\n\r\n            mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n            val imm = getImmediate(args[1], (-(2.0).pow(6 - 1)).toInt(), (2.0).pow(6 - 1).toInt() - 1, dbg)\r\n            val fimm = imm and 0b11111\r\n            mcode[InstructionField.IMM_b2_b6] = fimm\r\n            val simm = (imm and 0b100000) shr 5\r\n            mcode[InstructionField.IMM_b12] = simm\r\n        },\r\n        impl16 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.ADDI is not supported by 16 bit systems!\")\r\n        },\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm = ((rawimm_12) shl 5) or rawimm6_2\r\n            val rs1v = sim.getReg(rd).toInt()\r\n            sim.setReg(rd, imm + rs1v)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.ADDI is not supported by 64 bit systems!\")\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.ADDI is not supported by 128 bit systems!\")\r\n        },\r\n        disasm = RawDisassembler { mcode ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm = ((rawimm_12) shl 5) or rawimm6_2\r\n            \"c.addi x$rd $imm\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ci\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.Registers\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeCFunct3Format\r\nimport venusbackend.riscv.insts.dsl.getImmediate\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.RawParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.parsers.regNameToNumber\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport kotlin.math.pow\r\n\r\nval clwsp = Instruction(\r\n        name = \"c.lwsp\",\r\n        format = OpcodeCFunct3Format(0b10, 0b010, arrayOf(\r\n                FieldEqual(InstructionField.RD, 0, true)\r\n        )),\r\n        parser = RawParser { prog, mcode, args, dbg ->\r\n            checkArgsLength(args.size, 2, dbg)\r\n\r\n            mcode[InstructionField.RD] = regNameToNumber(args[0], dbg = dbg)\r\n            val imm = getImmediate(args[1], (-(2.0).pow(8 - 1)).toInt(), (2.0).pow(8 - 1).toInt() - 1, dbg)\r\n            throw NotImplementedError(\"Still working on correct imm for C.LWSP\")\r\n//            mcode[InstructionField.IMM_b2_b6] = (imm and 0b1111100) shr 2\r\n//            mcode[InstructionField.IMM_b12] = (imm shr 7) and 0b1\r\n        },\r\n        impl16 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.LWSP is not supported by 16 bit systems!\")\r\n        },\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm4_2 = rawimm6_2 and 0b11100\r\n            val imm7_6 = rawimm6_2 and 0b00011\r\n            val imm = ((imm4_2 or (rawimm_12 shl 3) or (imm7_6 shl 4)) shl 2)\r\n            val sp = sim.getReg(Registers.sp).toInt()\r\n            val data = sim.loadWordwCache(sp + imm)\r\n            sim.setReg(rd, data)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm4_2 = rawimm6_2 and 0b11100\r\n            val imm7_6 = rawimm6_2 and 0b00011\r\n            val imm = ((imm4_2 or (rawimm_12 shl 3) or (imm7_6 shl 4)) shl 2)\r\n            val sp = sim.getReg(Registers.sp).toLong()\r\n            val data = sim.loadWordwCache(sp + imm).toLong()\r\n            sim.setReg(rd, data)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm4_2 = rawimm6_2 and 0b11100\r\n            val imm7_6 = rawimm6_2 and 0b00011\r\n            val imm = ((imm4_2 or (rawimm_12 shl 3) or (imm7_6 shl 4)) shl 2)\r\n            val sp = sim.getReg(Registers.sp).toLong()\r\n            val data = sim.loadWordwCache(sp + imm).toLong()\r\n            sim.setReg(rd, data)\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        disasm = RawDisassembler { mcode ->\r\n            val rd = mcode[InstructionField.RD].toInt()\r\n            val rawimm6_2 = mcode[InstructionField.IMM_b2_b6].toInt()\r\n            val rawimm_12 = mcode[InstructionField.IMM_b12].toInt()\r\n            val imm4_2 = rawimm6_2 and 0b11100\r\n            val imm7_6 = rawimm6_2 and 0b00011\r\n            val imm = ((imm4_2 or (rawimm_12 shl 3) or (imm7_6 shl 4)) shl 2)\r\n            \"c.lwsp x$rd $imm\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.ci\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.OpcodeCFunct3Format\r\nimport venusbackend.riscv.insts.dsl.impls.RawImplementation\r\nimport venusbackend.riscv.insts.dsl.parsers.RawParser\r\nimport venusbackend.riscv.insts.dsl.parsers.checkArgsLength\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\n\r\nval cnop = Instruction(\r\n        name = \"c.nop\",\r\n        format = OpcodeCFunct3Format(0b01, 0b000, arrayOf(\r\n                FieldEqual(InstructionField.RD, 0, false),\r\n                FieldEqual(InstructionField.IMM_b2_b6, 0, false, listOf(InstructionField.IMM_b12))\r\n        )),\r\n        parser = RawParser { prog, mcode, args, dbg ->\r\n            checkArgsLength(args.size, 0, dbg)\r\n        },\r\n        impl16 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.NOP is not supported by 16 bit systems!\")\r\n        },\r\n        impl32 = RawImplementation { mcode, sim ->\r\n            sim.incrementPC(mcode.length)\r\n        },\r\n        impl64 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.NOP is not supported by 64 bit systems!\")\r\n        },\r\n        impl128 = RawImplementation { mcode, sim ->\r\n            throw InstructionNotSupportedError(\"C.NOP is not supported by 128 bit systems!\")\r\n        },\r\n        disasm = RawDisassembler { mcode ->\r\n            \"c.nop\"\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.cr\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CRTypeInstruction\r\n\r\nval cadd = CRTypeInstruction(\r\n        name = \"c.add\",\r\n        opcode2 = 0b10,\r\n        funct4 = 0b1001,\r\n        regComp = arrayOf(\r\n                FieldEqual(InstructionField.RD, 0, true),\r\n                FieldEqual(InstructionField.CRS2, 0, true)\r\n        ),\r\n        eval32 = { a, b ->\r\n            a + b\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.cr\r\n\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.insts.dsl.disasms.RawDisassembler\r\nimport venusbackend.riscv.insts.dsl.formats.FieldEqual\r\nimport venusbackend.riscv.insts.dsl.formats.InstructionFormat\r\nimport venusbackend.riscv.insts.dsl.parsers.DoNothingParser\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.integer.base.i.ebreak\r\n\r\nval cebreak = Instruction(\r\n        name = \"ebreak\",\r\n        format = InstructionFormat(2,\r\n                listOf(FieldEqual(InstructionField.HALF, 0b100_1_00000_00000_10))\r\n        ),\r\n        parser = DoNothingParser,\r\n        impl16 = ebreak.impl16,\r\n        impl32 = ebreak.impl32,\r\n        impl64 = ebreak.impl64,\r\n        impl128 = ebreak.impl128,\r\n        disasm = RawDisassembler { \"c.ebreak\" }\r\n)","package venusbackend.riscv.insts.integer.extensions.compressed.cr\r\n\r\nimport venusbackend.riscv.insts.dsl.types.extensions.compressed.CRTypeInstruction\r\n\r\nval cmv = CRTypeInstruction(\r\n        name = \"c.mv\",\r\n        opcode2 = 0b10,\r\n        funct4 = 0b1000,\r\n        eval32 = { _, b ->\r\n            b\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toDoubleQuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval divu = RTypeInstruction(\r\n        name = \"divu\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b101,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            val x = a.toInt() shl 16 ushr 16\r\n            val y = b.toInt() shl 16 ushr 16\r\n            if (y == (0L).toInt()) (-1).toShort()\r\n            else (x / y).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val x = a.toLong() shl 32 ushr 32\r\n            val y = b.toLong() shl 32 ushr 32\r\n            if (y == 0L) (-1).toInt()\r\n            else (x / y).toInt()\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = a.toQuadWord() shl 64 ushr 64\r\n            val y = b.toQuadWord() shl 64 ushr 64\r\n            if (y == QuadWord()) (-1).toLong()\r\n            else (x / y).toLong()\r\n        },\r\n        /*FIXME 128 need to be able to convert to larger things that LONG*/\r\n        eval128 = { a, b ->\r\n            val x = a.toDoubleQuadWord() shl 128 ushr 128\r\n            val y = b.toDoubleQuadWord() shl 128 ushr 128\r\n            if (y == 0.toDoubleQuadWord()) (-1).toQuadWord()\r\n            else (x / y).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval divw = RTypeInstruction(\r\n        name = \"divw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b100,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"divw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"divw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b.toInt() == 0) -1\r\n            else if (a.toInt() == Int.MIN_VALUE && b.toInt() == -1) a.toInt().toLong()\r\n            else (a.toInt() / b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b.toInt() == 0) (-1).toQuadWord()\r\n            else if (a.toInt() == Int.MIN_VALUE && b.toInt() == -1) a.toInt().toQuadWord()\r\n            else (a.toInt() / b.toInt()).toQuadWord()\r\n        }\r\n)","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval mul = RTypeInstruction(\r\n        name = \"mul\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b -> (a * b).toShort() },\r\n        eval32 = { a, b -> a * b },\r\n        eval64 = { a, b -> a * b },\r\n        eval128 = { a, b -> a * b }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toDoubleQuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval mulh = RTypeInstruction(\r\n        name = \"mulh\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b001,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            val x = a.toInt()\r\n            val y = b.toInt()\r\n            ((x * y) ushr 16).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val x = a.toLong()\r\n            val y = b.toLong()\r\n            ((x * y) ushr 32).toInt()\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = a.toQuadWord()\r\n            val y = b.toQuadWord()\r\n            ((x * y) ushr 64).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val x = a.toDoubleQuadWord()\r\n            val y = b.toDoubleQuadWord()\r\n            ((x * y) ushr 128).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toDoubleQuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval mulhsu = RTypeInstruction(\r\n        name = \"mulhsu\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b010,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            val x = a.toInt()\r\n            val y = (b.toInt() shl 16) ushr 16\r\n            ((x * y) ushr 16).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val x = a.toLong()\r\n            val y = (b.toLong() shl 32) ushr 32\r\n            ((x * y) ushr 32).toInt()\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = a.toQuadWord()\r\n            val y = (b.toQuadWord() shl 32) ushr 32\r\n            ((x * y) ushr 32).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val x = a.toDoubleQuadWord()\r\n            val y = (b.toDoubleQuadWord() shl 32) ushr 32\r\n            ((x * y) ushr 32).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toDoubleQuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval mulhu = RTypeInstruction(\r\n        name = \"mulhu\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b011,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            val x = (a.toInt() shl 16) ushr 16\r\n            val y = (b.toInt() shl 16) ushr 16\r\n            ((x * y) ushr 16).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val x = (a.toLong() shl 32) ushr 32\r\n            val y = (b.toLong() shl 32) ushr 32\r\n            ((x * y) ushr 32).toInt()\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = (a.toQuadWord() shl 32) ushr 32\r\n            val y = (b.toQuadWord() shl 32) ushr 32\r\n            ((x * y) ushr 32).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val x = (a.toDoubleQuadWord() shl 32) ushr 32\r\n            val y = (b.toDoubleQuadWord() shl 32) ushr 32\r\n            ((x * y) ushr 32).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval mulw = RTypeInstruction(\r\n        name = \"mulw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b000,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"mulw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"mulw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b -> (a.toInt() * b.toInt()).toLong() },\r\n        eval128 = { a, b -> (a.toInt() * b.toInt()).toQuadWord() }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval rem = RTypeInstruction(\r\n        name = \"rem\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b110,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            if (b == 0.toShort()) a\r\n            else if (a == Short.MIN_VALUE && b == (-1).toShort()) 0\r\n            else (a % b).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            if (b == 0) a\r\n            else if (a == Int.MIN_VALUE && b == -1) 0\r\n            else a % b\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b == 0.toLong()) a\r\n            else if (a == Long.MIN_VALUE && b == (-1).toLong()) 0\r\n            else a % b\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b == 0.toQuadWord()) a\r\n            else if (a == QuadWord.MIN_VALUE && b == (-1).toQuadWord()) 0.toQuadWord()\r\n            else a % b\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toDoubleQuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval remu = RTypeInstruction(\r\n        name = \"remu\",\r\n        opcode = 0b0110011,\r\n        funct3 = 0b111,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            val x = a.toInt() shl 16 ushr 16\r\n            val y = b.toInt() shl 16 ushr 16\r\n            if (b == 0.toShort()) a\r\n            else (x % y).toShort()\r\n        },\r\n        eval32 = { a, b ->\r\n            val x = a.toLong() shl 32 ushr 32\r\n            val y = b.toLong() shl 32 ushr 32\r\n            if (b == 0) a\r\n            else (x % y).toInt()\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = a.toQuadWord() shl 32 ushr 32\r\n            val y = b.toQuadWord() shl 32 ushr 32\r\n            if (b == 0L) a\r\n            else (x % y).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val x = a.toDoubleQuadWord() shl 32 ushr 32\r\n            val y = b.toDoubleQuadWord() shl 32 ushr 32\r\n            if (b == QuadWord()) a\r\n            else (x % y).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval remuw = RTypeInstruction(\r\n        name = \"remuw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b111,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"remuw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"remuw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            val x = a.toLong() shl 32 ushr 32\r\n            val y = b.toLong() shl 32 ushr 32\r\n            if (b.toInt() == 0) a.toInt().toLong()\r\n            else (x % y).toInt().toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            val x = a.toLong() shl 32 ushr 32\r\n            val y = b.toLong() shl 32 ushr 32\r\n            if (b.toInt() == 0) a.toInt().toQuadWord()\r\n            else (x % y).toInt().toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv.insts.integer.extensions.multiply.r\r\n\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.insts.InstructionNotSupportedError\r\nimport venusbackend.riscv.insts.dsl.types.base.RTypeInstruction\r\n\r\nval remw = RTypeInstruction(\r\n        name = \"remw\",\r\n        opcode = 0b0111011,\r\n        funct3 = 0b110,\r\n        funct7 = 0b0000001,\r\n        eval16 = { a, b ->\r\n            throw InstructionNotSupportedError(\"remw is not supported on 16 bit systems!\")\r\n        },\r\n        eval32 = { a, b ->\r\n            throw InstructionNotSupportedError(\"remw is not supported on 32 bit systems!\")\r\n        },\r\n        eval64 = { a, b ->\r\n            if (b.toInt() == 0) a\r\n            else if (a.toInt() == Int.MIN_VALUE && b.toInt() == -1) 0.toLong()\r\n            else (a.toInt() % b.toInt()).toLong()\r\n        },\r\n        eval128 = { a, b ->\r\n            if (b.toInt() == 0) a.toInt().toQuadWord()\r\n            else if (a.toInt() == Int.MIN_VALUE && b.toInt() == -1) 0.toQuadWord()\r\n            else (a.toInt() % b.toInt()).toQuadWord()\r\n        }\r\n)\r\n","package venusbackend.riscv\r\n\r\n/**\r\n * Represents the machine code of an instruction.\r\n *\r\n * For now this only supports 32bit and smaller instructions. Eventually it will be more general.\r\n *\r\n * @param encoding the underlying machine code of the instruction\r\n */\r\nclass MachineCode(private var encoding: Int) {\r\n    var length = 4\r\n\r\n    /**\r\n     * Returns the value of the given instruction field for this instruction.\r\n     *\r\n     * @param ifield the instruction field to get\r\n     * @return the value of the given instruction field\r\n     */\r\n    operator fun get(ifield: InstructionField): Int {\r\n        val mask = ((1L shl ifield.hi) - (1L shl ifield.lo)).toInt()\r\n        return (encoding and mask) ushr ifield.lo\r\n    }\r\n\r\n    /**\r\n     * Sets an instruction field to the given value.\r\n     *\r\n     * @param ifield the instruction field to set\r\n     * @param value the value to set the field to\r\n     */\r\n    operator fun set(ifield: InstructionField, value: Int) {\r\n        val mask = ((1L shl ifield.hi) - (1L shl ifield.lo)).toInt()\r\n        encoding = encoding and mask.inv()\r\n        encoding = encoding or ((value shl ifield.lo) and mask)\r\n    }\r\n\r\n    override fun toString() = encoding.toLong().toString()\r\n    fun toString(radix: Int) = encoding.toLong().toString(radix)\r\n}","package venusbackend.riscv\r\n\r\nimport venusbackend.simulator.SimulatorError\r\n\r\n/** A singleton containing constants which say where various segments start */\r\nobject MemorySegments {\r\n    /** Memory address where the stack segment starts (growing downwards) */\r\n    const val STACK_BEGIN = 0x7fff_fff0\r\n    /** Memory address where the heap segment starts */\r\n    const val HEAP_BEGIN = 0x1000_8000\r\n    /** Memory address where the data segment starts */\r\n    var STATIC_BEGIN = 0x1000_0000\r\n    /**\r\n     * Memory address where the text segment starts\r\n     */\r\n    public var TEXT_BEGIN = 0x0000_0000\r\n\r\n    fun setTextBegin(i: Int) {\r\n        if (i < 0) {\r\n            throw SimulatorError(\"The text location must be a positive number!\")\r\n        } else if (i >= MemorySegments.STATIC_BEGIN) {\r\n            /*\r\n            * @todo add check to see if text plus program is above stack. Should error as well.\r\n            */\r\n            throw SimulatorError(\"The text location in memory cannot be larger than the static!\")\r\n        }\r\n        MemorySegments.TEXT_BEGIN = i\r\n    }\r\n}\r\n","package venusbackend.riscv\r\n\r\npublic enum class MemSize(val size: Int) {\r\n    QUAD(16),\r\n    LONG(8),\r\n    WORD(4),\r\n    HALF(2),\r\n    BYTE(1)\r\n}","package venusbackend.riscv\r\n\r\nimport venusbackend.assembler.AssemblerError\r\nimport venusbackend.assembler.DebugInfo\r\nimport venusbackend.linker.DataRelocationInfo\r\nimport venusbackend.linker.RelocationInfo\r\nimport venusbackend.riscv.insts.dsl.relocators.Relocator\r\n\r\ndata class Import(val path: String, val relative: Boolean)\r\n\r\n/**\r\n * An (unlinked) program.\r\n *\r\n * @param name the name of the program, used for debug info\r\n * @see venus.assembler.Assembler\r\n * @see venus.linker.Linker\r\n */\r\npublic val venusInternalLabels: String = \"Venus_Internal_Label-\"\r\nclass Program(var name: String = \"anonymous\", val absPath: String) {\r\n    /* TODO: abstract away these variables */\r\n    val insts = ArrayList<MachineCode>()\r\n    val debugInfo = ArrayList<DebugInfo>()\r\n    val labels = HashMap<String, Int>()\r\n    val equivs = HashMap<String, String>()\r\n    val relocationTable = ArrayList<RelocationInfo>()\r\n    val dataRelocationTable = ArrayList<DataRelocationInfo>()\r\n    val dataSegment = ArrayList<Byte>()\r\n    val localReferences = HashMap<Int, MutableSet<Int>>() // <Numeric Label, Addresses of that label>\r\n    var textSize = 0\r\n    var dataSize = 0\r\n    private val globalLabels = HashSet<String>()\r\n    val imports = ArrayList<Import>()\r\n\r\n    /**\r\n     * Adds an instruction to the program, and increments the text size.\r\n     *\r\n     * @param mcode the instruction to add\r\n     */\r\n    fun add(mcode: MachineCode) {\r\n        insts.add(mcode)\r\n        textSize += mcode.length\r\n    }\r\n\r\n    /**\r\n     * Adds a byte of data to the program, and increments the data size.\r\n     *\r\n     * @param byte the byte to add\r\n     */\r\n    fun addToData(byte: Byte) {\r\n        dataSegment.add(byte)\r\n        dataSize++\r\n    }\r\n\r\n    /**\r\n     * Overwrites a byte of data in the program's data segment\r\n     *\r\n     * @param offset the offset at which to overwrite\r\n     * @param byte the value to overwrite with\r\n     */\r\n    fun overwriteData(offset: Int, byte: Byte) {\r\n        dataSegment[offset] = byte\r\n    }\r\n\r\n    fun addImport(filepath: String, relative: Boolean) {\r\n        this.imports.add(Import(filepath, relative))\r\n    }\r\n\r\n    /**\r\n     * Adds debug info to the instruction currently being assembled.\r\n     *\r\n     * In the case of pseudo-instructions, the original instruction will be added multiple times.\r\n     * @todo Find a better way to deal with pseudoinstructions\r\n     *\r\n     * @param dbg the debug info to add\r\n     */\r\n    fun addDebugInfo(dbg: DebugInfo) {\r\n        while (debugInfo.size < insts.size) {\r\n            debugInfo.add(dbg)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a label with a given offset to the program.\r\n     *\r\n     * @param label the label to add\r\n     * @param offset the byte offset to add it at (from the start of the program)\r\n     */\r\n    fun addLabel(label: String, offset: Int): Int? {\r\n        if (label.matches(Regex(\"\\\\d+\"))) {\r\n            val intlabel = label.toInt()\r\n            if (localReferences.containsKey(intlabel)) {\r\n                val set = localReferences[intlabel]!!\r\n                set.add(offset)\r\n            } else {\r\n                val new_set = HashSet<Int>()\r\n                new_set.add(offset)\r\n                localReferences[intlabel] = new_set\r\n            }\r\n            return null\r\n        } else {\r\n            return labels.put(label, offset)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a symbol defined by .equiv, .equ, or .set.\r\n     */\r\n    fun addEqu(label: String, defn: String) = equivs.put(label, defn)\r\n    private val SYM_PATN = Regex(\"\"\"(.*?)(?:([-+])(?:(\\d+)|(.*)))?$\"\"\")\r\n    /** Return the symbolic part of LABELARG, where LABELARG may be either\r\n     *  <symbol>, <symbol>+<decimal numeral>, or <symbol>-<decimal numeral>.\r\n     */\r\n    fun symbolPart(labelArg: String, dbg: DebugInfo): String {\r\n        val match = SYM_PATN.find(labelArg) ?: throw AssemblerError(\"bad symbol reference: $labelArg\", dbg)\r\n        return match.groupValues[1]\r\n    }\r\n    /** Return the numeric offset part of LABELARG, where LABELARG may be either\r\n     *  <symbol> (result 0), <symbol>+<decimal numeral> (result\r\n     *  <decimal numeral> as an Int), <symbol>-<decimal numeral>,\r\n     *   <symbol>+<absolute symbol>, or <symbol>-<abssolute symbol>.  Here,\r\n     *   <absolute symbol> refers to a .equiv'ed symbol that resolves to\r\n     *   an immediate constant (as in .equiv value, 13).\r\n     */\r\n    fun labelOffsetPart(labelArg: String, dbg: DebugInfo): Int {\r\n        val match = SYM_PATN.find(labelArg) ?: throw AssemblerError(\"ill-formed symbol reference: $labelArg\", dbg)\r\n        val (_, sign, num, offsetSym) = match.destructured\r\n        if (sign == \"\") {\r\n            return 0\r\n        }\r\n        if (num != \"\") {\r\n            return (sign + num).toInt()\r\n        }\r\n        if (offsetSym !in labels) {\r\n            throw AssemblerError(\"undefined symbol: $offsetSym\", dbg)\r\n        }\r\n        return if (sign == \"-\") -labels[offsetSym]!! else labels[offsetSym]!!\r\n    }\r\n\r\n    /**\r\n     * Gets the _relative_ label offset, or null if it does not exist.\r\n     *\r\n     * The _relative_ offset is relative to the instruction currently being assembled.\r\n     *\r\n     * @param label the label to find\r\n     * @returns the relative offset, or null if it does not exist.\r\n     */\r\n    fun getLabelOffset(label: String, address: Int, dbg: DebugInfo): Int? {\r\n        // TODO FIX ME TO WORK WITH FORWARD AND BACKWARD LOCAL REFERENCE\r\n        val loc = if (label.matches(Regex(\"\\\\d+[fb]\"))) {\r\n            val intlabel = label.substring(0, label.length - 1).toInt()\r\n            val number_set = localReferences[intlabel] ?: throw AssemblerError(\"The number label '$intlabel' has not been defined!\", dbg)\r\n            if (label.matches(Regex(\"\\\\d+f\"))) {\r\n                number_set.filter { it >= address }.min()\r\n            } else {\r\n                number_set.filter { it <= address }.max()\r\n            }\r\n        } else {\r\n            labels.get(label)\r\n        }\r\n        return loc?.minus(textSize)\r\n    }\r\n\r\n    /**\r\n     * Gets the immediate from a string, checking if it is in range.\r\n     *\r\n     * @param str the immediate as a string\r\n     * @param min the minimum allowable value of the immediate\r\n     * @param max the maximum allowable value of the immediate\r\n     * @return the immediate, as an integer\r\n     *\r\n     * @throws IllegalArgumentException if the wrong number of arguments is given\r\n     */\r\n    internal fun getImmediate(str: String, min: Int, max: Int, dbg: DebugInfo): Int {\r\n        val imm = try {\r\n            userStringToInt(str)\r\n        } catch (e: NumberFormatException) {\r\n            val sym = symbolPart(str, dbg)\r\n            val offsetVal = labelOffsetPart(str, dbg)\r\n            if (sym != \"\" && sym !in labels) {\r\n                throw AssemblerError(\"undefined symbol: $sym\", dbg)\r\n            }\r\n            val symVal = if (sym == \"\") 0 else labels[sym]!!\r\n            symVal + offsetVal\r\n        }\r\n        if (imm !in min..max)\r\n            throw AssemblerError(\"immediate $str (= $imm) out of range (should be between $min and $max)\", dbg)\r\n        return imm\r\n    }\r\n\r\n    /**\r\n     * Adds a line to the relocation table.\r\n     *\r\n     * @param label the label to relocate\r\n     * @param labelOffset amount to add to the label value before applying\r\n     *                    relocation\r\n     * @param offset the byte offset at which to apply the relocation\r\n     *               (from the start of the program)\r\n     */\r\n    fun addRelocation(\r\n        relocator: Relocator,\r\n        label: String,\r\n        labelOffset: Int,\r\n        offset: Int = textSize,\r\n        dbg: DebugInfo\r\n    ) = relocationTable.add(RelocationInfo(relocator, offset, label, labelOffset, dbg))\r\n\r\n    /**\r\n     * Adds a line to the data relocation table.\r\n     *\r\n     * @param label the label to relocate\r\n     * @param labelOffset amount to add to the label value before applying\r\n     *                    relocation\r\n     * @param offset the byte offset at which to apply the relocation\r\n     *               (from the start of the program)\r\n     */\r\n    fun addDataRelocation(\r\n        label: String,\r\n        labelOffset: Int,\r\n        offset: Int = textSize,\r\n        dbg: DebugInfo\r\n    ) = dataRelocationTable.add(DataRelocationInfo(offset, label, labelOffset, dbg))\r\n\r\n    /**\r\n     * Makes a label global.\r\n     *\r\n     * @param label the label to make global\r\n     */\r\n    fun makeLabelGlobal(label: String) {\r\n        globalLabels.add(label)\r\n    }\r\n\r\n    /**\r\n     * Checks if a label is global.\r\n     *\r\n     * @param label the label to check\r\n     * @return true if the label is global\r\n     */\r\n    fun isGlobalLabel(label: String) = globalLabels.contains(label)\r\n\r\n    /* TODO: add dump formats */\r\n    /**\r\n     * Dumps the instructions.\r\n     *\r\n     * @return a list of instructions in this program\r\n     */\r\n    fun dump(): List<MachineCode> = insts\r\n\r\n    fun assembleDependencies(): ArrayList<Program> {\r\n        return ArrayList()\r\n    }\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2 \u2014 of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2] \u2014 of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","package venusbackend.riscv\r\n\r\nobject Registers {\r\n    val zero = 0\r\n    val ra = 1\r\n    val sp = 2\r\n    val gp = 3\r\n    val tp = 4\r\n    val t0 = 5\r\n    val t1 = 6\r\n    val t2 = 7\r\n    val s0 = 8\r\n    val fp = 8\r\n    val s1 = 9\r\n    val a0 = 10\r\n    val a1 = 11\r\n    val a2 = 12\r\n    val a3 = 13\r\n    val a4 = 14\r\n    val a5 = 15\r\n    val a6 = 16\r\n    val a7 = 17\r\n    val s2 = 18\r\n    val s3 = 19\r\n    val s4 = 20\r\n    val s5 = 21\r\n    val s6 = 22\r\n    val s7 = 23\r\n    val s8 = 24\r\n    val s9 = 25\r\n    val s10 = 26\r\n    val s11 = 27\r\n    val t3 = 28\r\n    val t4 = 29\r\n    val t5 = 30\r\n    val t6 = 31\r\n\r\n    val ft0 = 0\r\n    val ft1 = 1\r\n    val ft2 = 2\r\n    val ft3 = 3\r\n    val ft4 = 4\r\n    val ft5 = 5\r\n    val ft6 = 6\r\n    val ft7 = 7\r\n    val fs0 = 8\r\n    val fs1 = 9\r\n    val fa0 = 10\r\n    val fa1 = 11\r\n    val fa2 = 12\r\n    val fa3 = 13\r\n    val fa4 = 14\r\n    val fa5 = 15\r\n    val fa6 = 16\r\n    val fa7 = 17\r\n    val fs2 = 18\r\n    val fs3 = 19\r\n    val fs4 = 20\r\n    val fs5 = 21\r\n    val fs6 = 22\r\n    val fs7 = 23\r\n    val fs8 = 24\r\n    val fs9 = 25\r\n    val fs10 = 26\r\n    val fs11 = 27\r\n    val ft8 = 28\r\n    val ft9 = 29\r\n    val ft10 = 30\r\n    val ft11 = 31\r\n}","package venusbackend.riscv\r\n\r\nobject Settings {\r\n    var strict = false\r\n}\r\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the contents of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\npublic actual fun String.toBoolean(): Boolean = toLowerCase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.toLowerCase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    else -> -1\n}.let { if (it >= radix) -1 else it }\n","package venusbackend.simulator\r\n\r\n/**\r\n * Thrown when errors occur when memory is not aligned.\r\n */\r\nclass AlignmentError : SimulatorError {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n}\r\n","package venusbackend.simulator.cache\r\n\r\nimport venus.Renderer\r\n\r\n/**\r\n * Created by thaum on 7/29/2018.\r\n */\r\n/**\r\n * A collection of adjacent word entries within the cHandler. The number of entries\r\n * is determined by blocksize.\r\n *\r\n * @author Deborah Hawkins\r\n * @author Rishi Dewan\r\n */\r\nclass Block\r\n/**\r\n * Class constructor specifing size of block to create in bytes. All blocks\r\n * are created with this constructor and then modified.\r\n */\r\n(private val blocksize: Int) {\r\n\r\n    public var blockState = BlockState.EMPTY\r\n    /**\r\n     * Returns the tag field of the address. The containing set uses this to\r\n     * find an exact address.\r\n     */\r\n    var tag: Int = 0\r\n        private set\r\n    /**\r\n     * Returns true if the data contained in this block is valid or false if it\r\n     * has not been set yet.\r\n     */\r\n    var isValid: Boolean = false\r\n        private set\r\n    /**\r\n     * Returns true if the data contained in this block has been updated or\r\n     * false if it is still consistent with data in main memory.\r\n     */\r\n    var isDirty: Boolean = false\r\n        private set\r\n    /**\r\n     * Returns an int which indicates when the block was last used. Higher\r\n     * numbers indicate more recent use.\r\n     */\r\n    var recentUse: Int = 0\r\n        private set // higher values are more recently used\r\n    // private var words: IntArray? = null\r\n\r\n    init {\r\n        isValid = false // doesn't contain valid data yet\r\n        isDirty = false // doesn't need to be written back\r\n        recentUse = 0 // indicates not used yet\r\n    }\r\n\r\n    /**\r\n     * Returns the word (32 bytes) of data associated with a particular word\r\n     * address. Both data and address are expressed as (base 10) ints at this\r\n     * level.\r\n     *\r\n     * @param address the 32-bit address (as an int) at which to enter the data\r\n     * @param recentUse an update to the recentUse field\r\n     * @pre Check that this block is valid and that the address exists\r\n     * in this block before calling this function.\r\n     */\r\n    fun read(address: Int, useCounter: Int) {\r\n        recentUse = useCounter\r\n        // return words!![address % blocksize]\r\n    }\r\n\r\n    /**\r\n     * Replaces a word of data within the block for the byte address\r\n     * specified.\r\n     *\r\n     * @param address the 32-bit address (as an int) at which to enter the data\r\n     * @param data a 32-bit datum expressed as an int\r\n     * @param recentUse an update to the recentUse field\r\n     * @throws NotInCacheException If the address specified does not exist\r\n     * within this block or if the block is invalid.\r\n     */\r\n    fun write(offset: Int, /*data: Int,*/ useCounter: Int) {\r\n        recentUse = useCounter\r\n        // words!![offset] = data\r\n        isValid = true\r\n        isDirty = true\r\n    }\r\n\r\n    /**\r\n     * Fills the block with new data. Should only be used when the block is not\r\n     * dirty and is about to be used for a read or write.\r\n     *\r\n     * @param defines the block uniquely within this set (the first part of the address)\r\n     * @param words an array of data which represent the words in this block\r\n     */\r\n    fun writeBlock(tag: Int/*, words: IntArray*/) {\r\n        this.tag = tag\r\n        // this.words = words\r\n        isValid = true\r\n        isDirty = false\r\n    }\r\n\r\n    /**\r\n     * Returns the array of all words in the block. Used when the block is dirty\r\n     * and in the least recently used block, so the data can be written back to\r\n     * memory. This allocates new space for other data.\r\n     */\r\n    /*fun readAllData(): IntArray? {\r\n        return words\r\n    }*/\r\n\r\n    fun copy(): Block {\r\n        val b = Block(blocksize)\r\n        b.tag = this.tag\r\n        b.isValid = this.isValid\r\n        b.isDirty = this.isDirty\r\n        b.recentUse = this.recentUse\r\n        b.blockState = this.blockState\r\n        // b.words = this.words?.copyOf()\r\n        return b\r\n    }\r\n\r\n    /**\r\n     * Prints the block values to standard out.\r\n     */\r\n    override fun toString(): String {\r\n        var result = ((if (isValid) 1 else 0).toString() + \"        \" + Renderer.toHex(tag) + \"   \" +\r\n                (if (isDirty) 1 else 0) + \"        \")\r\n//        for (word in words!!)\r\n//            result += Renderer.toHex(word) + \"     \"\r\n        return result\r\n    }\r\n}","package venusbackend.simulator.cache\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\nimport venusbackend.*\r\nimport venusbackend.riscv.Address\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\nclass Cache\r\n/* ktlint-disable no-multi-spaces */\r\n/**\r\n *\r\n * @param capacity      the size in words of the cHandler\r\n * @param associativity the number of blocks in each set\r\n * @param blocksize     the size in bytes of each block\r\n * @param memory        a reference to main memory\r\n */\r\n/* ktlint-enable no-multi-spaces */\r\n(c: CacheHandler) {\r\n    internal var numWrites: Int = 0\r\n    internal var numReads: Int = 0\r\n    internal var numWriteMisses: Int = 0\r\n    internal var numReadMisses: Int = 0\r\n    private var numEvictions: Int = 0\r\n    private val c = c\r\n    internal var sets: Array<Set>\r\n\r\n    init {\r\n\r\n        // initialize counters\r\n        numWrites = 0\r\n        numReads = 0\r\n        numWriteMisses = 0\r\n        numReadMisses = 0\r\n        numEvictions = 0\r\n\r\n        // initialize values of the cHandler\r\n        // val s = arrayOfNulls<Set>(capacity / (associativity * blocksize))\r\n        val s = arrayOfNulls<Set>(c.cacheSize() / (c.associativity() * c.cacheBlockSize()))\r\n        // sets = new Set[ this.capacity / (this.associativity * this.blocksize) ];\r\n\r\n        // create the sets that make up this cHandler\r\n        for (i in s.indices)\r\n            // s[i] = Set(this.associativity, this.blocksize)\r\n            s[i] = Set(c.associativity(), c.cacheBlockSize(), c)\r\n        sets = s.filterNotNull().toTypedArray()\r\n    }\r\n\r\n    fun read(address: Address): Boolean {\r\n\r\n        // if the block isn't found in the cHandler, put it there\r\n        var h = true\r\n        var bs = BlockState.HIT\r\n        if (!isInMemory(address)) {\r\n            c.nextLevelCacheHandler?.read(address)\r\n            allocate(address.address)\r\n            numReadMisses++\r\n            h = false\r\n            bs = BlockState.MISS\r\n        }\r\n\r\n        // calculate what set the block is in and ask it for the data\r\n        val set = sets[(address.address / this.c.cacheBlockSize() % sets.size).toInt()]\r\n        val blockoffset = (address.address % this.c.cacheBlockSize()).toInt()\r\n        numReads++\r\n        set.read(getTag(address.address).toInt(), blockoffset, bs)\r\n        return h\r\n    }\r\n\r\n    fun write(address: Address/*, data: Int*/): Boolean {\r\n\r\n        // if the block isn't found in the cHandler, put it there\r\n        var h = true\r\n        var bs = BlockState.HIT\r\n        if (!isInMemory(address)) {\r\n            c.nextLevelCacheHandler?.write(address)\r\n            allocate(address.address)\r\n            numWriteMisses++\r\n            h = false\r\n            bs = BlockState.MISS\r\n        }\r\n\r\n        // calculate what set the block is in and ask it for the data\r\n        val index = (address.address / this.c.cacheBlockSize() % sets.size).toInt()\r\n        val blockoffset = (address.address % this.c.cacheBlockSize()).toInt()\r\n        val set = sets[index]\r\n        numWrites++\r\n        set.write(getTag(address.address).toInt(), blockoffset/*, data*/, bs)\r\n        return h\r\n    }\r\n\r\n    private fun isInMemory(address: Address): Boolean {\r\n        val index = address.address / this.c.cacheBlockSize() % sets.size\r\n        return sets[index.toInt()].findBlock(getTag(address.address).toInt()) != null\r\n    }\r\n\r\n    private fun getTag(address: Number): Number {\r\n        // System.out.println((int) ( (double)address / ((double)sets.length * (double)blocksize)));\r\n        return address / (sets.size * this.c.cacheBlockSize())\r\n    }\r\n\r\n    // should only be called if we already know the address is not in cache\r\n    private fun allocate(address: Number) {\r\n\r\n        // val index = address / blocksize % sets.size\r\n        val index = (address / c.cacheBlockSize() % sets.size).toInt()\r\n        val set = sets[index.toInt()]\r\n        var evictee: Block\r\n        if (c.blockRepPolicy().equals(BlockReplacementPolicy.RANDOM)) {\r\n            evictee = set.getRandom()\r\n        } else {\r\n            evictee = set.getLRU()\r\n        }\r\n\r\n        // If the least recently used block is dirty, write it back to\r\n        // main memory.\r\n        if (evictee.isDirty) {\r\n            numEvictions++\r\n            // val evicteeAddress = (evictee.getTag() * sets.size + index) * blocksize\r\n            val evicteeAddress = (evictee.tag * sets.size + index) * c.cacheBlockSize()\r\n        }\r\n\r\n        // Then write the block with the data we need\r\n        // val SAddress = address / blocksize * blocksize\r\n        val SAddress = (address / c.cacheBlockSize()) * c.cacheBlockSize()\r\n        evictee.writeBlock(getTag(address).toInt())\r\n    }\r\n\r\n    fun copy(): Cache {\r\n        val cc = Cache(this.c)\r\n        cc.numEvictions = this.numEvictions\r\n        cc.numReadMisses = this.numReadMisses\r\n        cc.numReads = this.numReads\r\n        cc.numWriteMisses = this.numWrites\r\n        cc.numWrites = this.numWrites\r\n        for (s in this.sets.indices) {\r\n            cc.sets[s] = this.sets[s].copy()\r\n        }\r\n        return cc\r\n    }\r\n\r\n    fun blockStates(): ArrayList<String> {\r\n        val bss = ArrayList<String>()\r\n        for (s in sets) {\r\n            s.blockStates(bss)\r\n        }\r\n        return bss\r\n    }\r\n}","package venusbackend.simulator.cache\r\n\r\nimport venusbackend.simulator.SimulatorError\r\n\r\n/**\r\n * Thrown when errors occur during cHandler op.\r\n */\r\nclass CacheError : SimulatorError {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n}\r\n","package venusbackend.simulator.cache\r\n\r\nimport venusbackend.riscv.Address\r\nimport venusbackend.riscv.MemSize\r\nimport kotlin.math.floor\r\nimport kotlin.math.log2\r\nimport kotlin.random.Random\r\n\r\nclass CacheHandler(var cacheLevel: Int) {\r\n    var seed: String = Random.nextLong().toString()\r\n    var seededRandom = Random(seed.hashCode())\r\n    private var numberOfBlocks: Int = 1\r\n    /*This is in bytes*/\r\n    private var cacheBlockSize: Int = 4\r\n    private var placementPol: PlacementPolicy = PlacementPolicy.DIRECT_MAPPING\r\n    private var BlockRepPolicy: BlockReplacementPolicy = BlockReplacementPolicy.LRU\r\n    /*This is the set size of blocks*/\r\n    private var associativity: Int = 1\r\n\r\n    private var cacheList = ArrayList<CacheState>()\r\n    private var addresses = ArrayList<Address>()\r\n    private var RorW = ArrayList<RW>()\r\n\r\n    var nextLevelCacheHandler: CacheHandler? = null\r\n    var attached = false\r\n        private set\r\n\r\n    init {\r\n        this.reset()\r\n    }\r\n\r\n    fun read(a: Address) {\r\n        addresses.add(a)\r\n        RorW.add(RW.READ)\r\n        if (attached) {\r\n            val c = CacheState(a, this, RW.READ)\r\n            cacheList.add(c)\r\n        } else {\r\n            nextLevelCacheHandler?.read(a)\r\n        }\r\n    }\r\n\r\n    fun write(a: Address) {\r\n        addresses.add(a)\r\n        RorW.add(RW.WRITE)\r\n        if (attached) {\r\n            val c = CacheState(a, this, RW.WRITE)\r\n            cacheList.add(c)\r\n        } else {\r\n            nextLevelCacheHandler?.write(a)\r\n        }\r\n    }\r\n\r\n    fun undoAccess(addr: Address) {\r\n        if (this.memoryAccessCount() > 0) {\r\n            this.addresses.removeAt(this.addresses.lastIndex)\r\n            this.RorW.removeAt(this.RorW.lastIndex)\r\n            if (this.attached) {\r\n                this.cacheList.removeAt(this.cacheList.lastIndex)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun setCurrentSeed(v: String) {\r\n        this.seed = v\r\n        this.seededRandom = Random(this.seed.hashCode())\r\n        this.update()\r\n    }\r\n\r\n    fun update() {\r\n        val adrs = this.addresses\r\n        val row = this.RorW\r\n        this.reset()\r\n        for (i in adrs.indices) {\r\n            if (row[i] == RW.READ) {\r\n                this.read(adrs[i])\r\n            } else {\r\n                this.write(adrs[i])\r\n            }\r\n        }\r\n    }\r\n\r\n    fun attach(attach: Boolean) {\r\n        this.attached = attach\r\n        if (attach) {\r\n            this.update()\r\n        } else {\r\n            this.reset(false)\r\n            nextLevelCacheHandler?.addresses = this.addresses\r\n            nextLevelCacheHandler?.RorW = this.RorW\r\n            nextLevelCacheHandler?.update()\r\n        }\r\n    }\r\n\r\n    fun reset(full: Boolean = true) {\r\n        try {\r\n            this.seededRandom = Random(this.seed.hashCode())\r\n        } catch (e: Throwable) {}\r\n        cacheList = ArrayList()\r\n        cacheList.add(CacheState(Address(0, MemSize.WORD), this, RW.READ, true))\r\n        if (full) {\r\n            addresses = ArrayList()\r\n            RorW = ArrayList()\r\n        }\r\n        nextLevelCacheHandler?.reset()\r\n    }\r\n\r\n    fun getBlocksState(): ArrayList<String> {\r\n        return this.currentState().getBlocksState()\r\n    }\r\n\r\n    fun getHitCount(): Int {\r\n        return this.currentState().getHitCount()\r\n    }\r\n\r\n    fun getMissCount(): Int {\r\n        return this.currentState().getMissCount()\r\n    }\r\n\r\n    fun getHitRate(): Double {\r\n        return this.currentState().getHitRate()\r\n    }\r\n\r\n    fun getMissRate(): Double {\r\n        return this.currentState().getMissRate()\r\n    }\r\n\r\n    fun wasHit(): Boolean {\r\n        return this.currentState().wasHit()\r\n    }\r\n\r\n    fun memoryAccessCount(): Int {\r\n        return this.addresses.size\r\n    }\r\n\r\n    fun currentState(): CacheState {\r\n        val clsize = this.cacheList.lastIndex\r\n        if (clsize < 0) {\r\n            return this.cacheList[0]\r\n        } else {\r\n            return this.cacheList[clsize]\r\n        }\r\n    }\r\n\r\n    /*This is in bytes*/\r\n    fun cacheSize(): Int {\r\n        return this.numberOfBlocks * this.cacheBlockSize\r\n    }\r\n\r\n    fun setNumberOfBlocks(i: Int) {\r\n        val d = log2(i.toDouble())\r\n        if (!isInt(d)) {\r\n            throw CacheError(\"Number of Blocks must be a power of 2!\")\r\n        }\r\n        this.numberOfBlocks = i\r\n        if (this.placementPol == PlacementPolicy.FULLY_ASSOCIATIVE) {\r\n            this.setAssociativity(i, true)\r\n        } else if (this.placementPol == PlacementPolicy.NWAY_SET_ASSOCIATIVE) {\r\n            if (i < this.associativity()) {\r\n                this.setAssociativity(i)\r\n            }\r\n        }\r\n        this.update()\r\n    }\r\n\r\n    fun numberOfBlocks(): Int {\r\n        return this.numberOfBlocks\r\n    }\r\n\r\n    fun setCacheBlockSize(i: Int) {\r\n        val d = log2(i.toDouble())\r\n        if (!isInt(d)) {\r\n            throw CacheError(\"CacheHandler Block Size must be a power of 2!\")\r\n        }\r\n        this.cacheBlockSize = i\r\n        this.update()\r\n    }\r\n\r\n    fun cacheBlockSize(): Int {\r\n        return this.cacheBlockSize\r\n    }\r\n\r\n    fun setPlacementPol(p: PlacementPolicy) {\r\n        this.placementPol = p\r\n        if (p.equals(PlacementPolicy.DIRECT_MAPPING)) {\r\n            this.associativity = 1\r\n        }\r\n        if (p.equals(PlacementPolicy.FULLY_ASSOCIATIVE)) {\r\n            this.associativity = this.numberOfBlocks\r\n        }\r\n        this.update()\r\n    }\r\n\r\n    fun placementPol(): PlacementPolicy {\r\n        return this.placementPol\r\n    }\r\n\r\n    fun setBlockRepPolicy(brp: BlockReplacementPolicy) {\r\n        this.BlockRepPolicy = brp\r\n        this.update()\r\n    }\r\n\r\n    fun blockRepPolicy(): BlockReplacementPolicy {\r\n        return this.BlockRepPolicy\r\n    }\r\n\r\n    fun canSetAssociativity(): Boolean {\r\n        return this.placementPol == PlacementPolicy.NWAY_SET_ASSOCIATIVE\r\n    }\r\n\r\n    fun setAssociativity(i: Int, override: Boolean = false) {\r\n        if ((this.placementPol == PlacementPolicy.NWAY_SET_ASSOCIATIVE || override)) {\r\n            if (i !in 1..this.numberOfBlocks) {\r\n                return\r\n                // throw CacheError(\"Associativity must be greater than or equal to 1 but not greater than the number of blocks!\")\r\n            }\r\n            val d = log2(i.toDouble())\r\n            if (!isInt(d)) {\r\n                throw CacheError(\"Associativity must be a positive nonzero power of 2!\")\r\n            }\r\n            this.associativity = i\r\n            this.update()\r\n        }\r\n    }\r\n\r\n    fun associativity(): Int {\r\n        return this.associativity\r\n    }\r\n\r\n    internal fun isInt(d: Double): Boolean {\r\n        return !d.isNaN() && !d.isInfinite() && d == floor(d)\r\n    }\r\n}\r\n\r\nenum class PlacementPolicy {\r\n    DIRECT_MAPPING,\r\n    FULLY_ASSOCIATIVE,\r\n    NWAY_SET_ASSOCIATIVE;\r\n\r\n    fun toMyString(): String {\r\n        if (this.equals(PlacementPolicy.FULLY_ASSOCIATIVE)) {\r\n            return \"Fully Associative\"\r\n        }\r\n        if (this.equals(PlacementPolicy.NWAY_SET_ASSOCIATIVE)) {\r\n            return \"N-Way Set Associative\"\r\n        }\r\n        return \"Direct Mapped\"\r\n    }\r\n}\r\nenum class BlockReplacementPolicy {\r\n    LRU,\r\n    RANDOM;\r\n\r\n    fun toMyString(): String {\r\n        if (this.equals(BlockReplacementPolicy.LRU)) {\r\n            return \"LRU\"\r\n        }\r\n        return \"Random\"\r\n    }\r\n}\r\n\r\nenum class BlockState {\r\n    HIT,\r\n    MISS,\r\n    EMPTY\r\n}","package venusbackend.simulator.cache\r\n\r\nimport venusbackend.riscv.Address\r\n\r\n/**\r\n * This is a class representing the state of a cacheHandler.\r\n *\r\n * If default is true, then the address is ignored since it will be the centinel node.\r\n */\r\nclass CacheState(address: Address, cacheHandler: CacheHandler, rw: RW, default: Boolean = false) {\r\n    private var prevCacheState: CacheState\r\n    private var currentInternalCache: InternalCache\r\n    private val cache = cacheHandler\r\n    private var wasHit = false\r\n\r\n    private var hitcount = 0\r\n\r\n    var latestChange: ChangedBlockState\r\n\r\n    init {\r\n        if (default) {\r\n            prevCacheState = this\r\n            /*Since this is the first block, we must set it up properly*/\r\n            currentInternalCache = InternalCache(cacheHandler)\r\n            currentInternalCache.setup()\r\n            this.latestChange = ChangedBlockState(-1, BlockState.EMPTY, true)\r\n        } else {\r\n            /*Since this is not the default state, we can use the data made in the previous cacheHandler to set up this cacheHandler.*/\r\n            prevCacheState = cacheHandler.currentState()\r\n            this.hitcount = this.prevCacheState.getHitCount()\r\n            currentInternalCache = prevCacheState.currentInternalCache.copy()\r\n            if (rw.equals(RW.READ)) {\r\n                this.wasHit = this.currentInternalCache.read(address)\r\n            } else {\r\n                this.wasHit = this.currentInternalCache.write(address)\r\n            }\r\n            hitcount += if (this.wasHit) 1 else 0\r\n            val b = this.getInternalChangedBlockState()\r\n            if (b.noChange) {\r\n                this.latestChange = prevCacheState.latestChange\r\n            } else {\r\n                this.latestChange = b\r\n            }\r\n        }\r\n    }\r\n\r\n    fun getHitCount(): Int {\r\n        return this.hitcount\r\n    }\r\n\r\n    fun getMissCount(): Int {\r\n        return this.cache.memoryAccessCount() - this.hitcount\r\n    }\r\n\r\n    fun getHitRate(): Double {\r\n        return this.getHitCount().toDouble() / this.cache.memoryAccessCount().toDouble()\r\n    }\r\n\r\n    fun getMissRate(): Double {\r\n        return this.getMissCount().toDouble() / this.cache.memoryAccessCount().toDouble()\r\n    }\r\n\r\n    fun wasHit(): Boolean {\r\n        return this.wasHit\r\n    }\r\n\r\n    fun getBlocksState(): ArrayList<String> {\r\n        return currentInternalCache.getBlocksState()\r\n    }\r\n\r\n    var prevBlockStates = ArrayList<String>()\r\n    private fun getInternalChangedBlockState(): ChangedBlockState {\r\n        val prevStates = prevCacheState.getBlocksState()\r\n        val currentStates = currentInternalCache.getBlocksState()\r\n        for (index in currentStates.indices) {\r\n            if (currentStates[index] != prevStates[index]) {\r\n                return ChangedBlockState(index, BlockState.valueOf(currentStates[index]))\r\n            }\r\n        }\r\n        return ChangedBlockState(-1, BlockState.EMPTY, true)\r\n    }\r\n\r\n    fun getChangedBlockState(): ChangedBlockState {\r\n        val prevStates = prevCacheState.getBlocksState()\r\n        val currentStates = currentInternalCache.getBlocksState()\r\n        for (index in currentStates.indices) {\r\n            if (currentStates[index] != prevStates[index]) {\r\n                return ChangedBlockState(index, BlockState.valueOf(currentStates[index]))\r\n            }\r\n        }\r\n        return this.latestChange\r\n    }\r\n\r\n    fun getPrevChangedBlock(): Int {\r\n        return this.prevCacheState.getChangedBlockState().block\r\n    }\r\n}\r\n\r\nenum class RW {\r\n    READ,\r\n    WRITE\r\n}\r\n\r\nclass ChangedBlockState(val block: Int, val state: BlockState, val noChange: Boolean = false)\r\n\r\nprivate class InternalCache(cacheHandler: CacheHandler) {\r\n    val cHandler = cacheHandler\r\n//    var indexSize = 0\r\n//    var offsetSize = 0\r\n//    var tagSize = 0\r\n    lateinit var cache: Cache\r\n\r\n    fun setup() {\r\n        /*@todo sets up this (for the default state)*/\r\n//        indexSize = Math.log2(cHandler.cacheSize().toDouble() / (cHandler.cacheBlockSize().toDouble() * cHandler.associativity())).toInt()\r\n//        offsetSize = Math.log2(this.cHandler.cacheBlockSize()).toInt()\r\n//        tagSize = 32 - indexSize - offsetSize\r\n        this.cache = Cache(cHandler)\r\n    }\r\n\r\n    fun read(address: Address): Boolean {\r\n        /*@todo will update the current state and return if it was successful*/\r\n        return cache.read(address)\r\n    }\r\n\r\n    fun write(address: Address): Boolean {\r\n        /*@todo will update the current state and return if it was successful*/\r\n        return cache.write(address)\r\n    }\r\n\r\n    fun getBlocksState(): ArrayList<String> {\r\n        return cache.blockStates()\r\n    }\r\n\r\n    fun copy(): InternalCache {\r\n        val inCache = InternalCache(this.cHandler)\r\n        inCache.cache = this.cache.copy()\r\n//        inCache.indexSize = this.indexSize\r\n//        inCache.tagSize = this.tagSize\r\n//        inCache.offsetSize = this.offsetSize\r\n        /*@todo will copy the elements in here so that we can keep each state.*/\r\n        return inCache\r\n    }\r\n}","package venusbackend.simulator.cache\r\n\r\nimport kotlin.math.floor\r\n\r\n/**\r\n * Created by thaum on 7/29/2018.\r\n */\r\nclass Set(internal var associativity: Int, internal var blocksize: Int, val cacheHandler: CacheHandler) {\r\n    internal var useCounter: Int = 0\r\n    internal var blocks: Array<Block>\r\n\r\n    init {\r\n        useCounter = 0\r\n        val bs = arrayOfNulls<Block>(associativity)\r\n        for (i in bs.indices) {\r\n            bs[i] = Block(blocksize)\r\n        }\r\n        /*This is a crapy workaround to the no null type issue.*/\r\n        blocks = bs.filterNotNull().toTypedArray()\r\n    }\r\n\r\n    fun copy(): Set {\r\n        var s = Set(associativity, blocksize, cacheHandler)\r\n        s.useCounter = this.useCounter\r\n        for (i in blocks.indices) {\r\n            s.blocks[i] = this.blocks[i].copy()\r\n        }\r\n        return s\r\n    }\r\n\r\n    // returns the relevant block, or null if not found\r\n    fun read(tag: Int, offset: Int, bs: BlockState) {\r\n        val theBlock = findBlock(tag)\r\n        theBlock?.blockState = bs\r\n        theBlock?.read(offset, ++useCounter)\r\n    }\r\n\r\n    fun write(tag: Int, offset: Int, /*data: Int, */bs: BlockState) {\r\n        val theBlock = findBlock(tag)\r\n        if (theBlock != null) {\r\n            theBlock.write(offset, /*data,*/ ++useCounter)\r\n            theBlock.blockState = bs\r\n        } else {\r\n            // this shouldn't happen ...\r\n            // throw CacheError(\"Could not find block with tag '\" + tag.toString() + \"'! This error should not have occurred since it should have been handled earlier in the code.\")\r\n        }\r\n    }\r\n\r\n    fun getLRU(): Block {\r\n        var lru = blocks[0]\r\n        var least = blocks[0].recentUse\r\n        var temp: Int\r\n        for (i in 1 until associativity) {\r\n            temp = blocks[i].recentUse\r\n            if (temp < least) {\r\n                lru = blocks[i]\r\n                least = temp\r\n            }\r\n        }\r\n        return lru\r\n    }\r\n\r\n    fun getRandom(): Block {\r\n        val index = getRandomInt(0, associativity - 1)\r\n        return blocks[index]\r\n    }\r\n\r\n    fun getRandomInt(min: Int, vmax: Int): Int {\r\n        val max = vmax + 1\r\n        return minOf(floor(cacheHandler.seededRandom.nextDouble() * (max - min)).toInt() + min, vmax)\r\n    }\r\n\r\n    // returns the Block if found, null otherwise\r\n    fun findBlock(tag: Int): Block? {\r\n        val result: Block? = null\r\n        for (i in blocks.indices) {\r\n            if (blocks[i].tag == tag && blocks[i].isValid)\r\n                return blocks[i]\r\n        }\r\n        return result\r\n    }\r\n\r\n    fun blockStates(a: ArrayList<String>) {\r\n        for (b in blocks) {\r\n            a.add(b.blockState.toString())\r\n        }\r\n    }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.riscv.Address\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass CacheDiff(val addr: Address) : Diff {\r\n    override operator fun invoke(state: SimulatorState) {\r\n        state.cache.undoAccess(addr)\r\n    }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass FRegisterDiff(val id: Int, val v: Decimal) : Diff {\r\n    override operator fun invoke(state: SimulatorState) = state.setFReg(id, v)\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass HeapSpaceDiff(val heapEnd: Number) : Diff {\r\n    override operator fun invoke(state: SimulatorState) { state.setHeapEnd(heapEnd) }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venus.Renderer\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass InstructionDiff(val idx: Int, val mc: Int, val orig: String) : Diff {\r\n    override operator fun invoke(state: SimulatorState) {\r\n        try {\r\n            Renderer.updateProgramListing(idx, mc, orig)\r\n        } catch (e: Throwable) {}\r\n    }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass MemoryDiff(val addr: Number, val value: Number) : Diff {\r\n    override operator fun invoke(state: SimulatorState) {\r\n        state.mem.storeWord(addr, value)\r\n    }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass PCDiff(val pc: Number) : Diff {\r\n    override operator fun invoke(state: SimulatorState) { state.setPC(pc) }\r\n}","package venusbackend.simulator.diffs\r\n\r\nimport venusbackend.simulator.Diff\r\nimport venusbackend.simulator.SimulatorState\r\n\r\nclass RegisterDiff(val id: Int, val v: Number) : Diff {\r\n    override operator fun invoke(state: SimulatorState) = state.setReg(id, v)\r\n}","package venusbackend.simulator\r\n\r\nimport venusbackend.riscv.insts.InstructionNotFoundError\r\n\r\n/**\r\n * Thrown when errors occur during simulation.\r\n */\r\nclass ExceededAllowedCyclesError : SimulatorError {\r\n    override var infe: InstructionNotFoundError? = null\r\n    override var handled: Boolean? = null\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null, infe: InstructionNotFoundError? = null, handled: Boolean? = null) : super(msg) {\r\n        this.infe = infe\r\n        this.handled = handled\r\n    }\r\n}\r\n","package venusbackend.simulator\r\n\r\nimport venus.vfs.VFSFile\r\n\r\nclass FileDescriptor(var vfsFile: VFSFile, var fileMetaData: FileMetaData) {\r\n    var feof = false\r\n    var ferror = false\r\n    val dataStream: StringBuilder = StringBuilder(vfsFile.readText())\r\n\r\n    fun read(size: Int): String? {\r\n        val amtToRead = minOf(size, dataStream.length - fileMetaData.readOffset)\r\n        if (amtToRead == 0 || !fileMetaData.readable) {\r\n            return null\r\n        }\r\n        val oldoffset = fileMetaData.readOffset\r\n        fileMetaData.readOffset += amtToRead\r\n        return dataStream.subSequence(oldoffset, fileMetaData.readOffset).toString()\r\n    }\r\n\r\n    fun write(value: String): Int? {\r\n        if (!fileMetaData.writeable) {\r\n            return null\r\n        }\r\n        dataStream.append(value)\r\n        return value.length\r\n    }\r\n\r\n    fun flush(): Int {\r\n        if (fileMetaData.writeable) {\r\n            vfsFile.setText(this.dataStream.toString())\r\n        }\r\n        return 0\r\n    }\r\n\r\n    fun isEOF(): Int {\r\n        return if (feof) {\r\n            1\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n\r\n    fun getError(): Int {\r\n        return if (ferror) {\r\n            1\r\n        } else {\r\n            0\r\n        }\r\n    }\r\n}\r\n\r\nclass FileMetaData(\r\n    var readOffset: Int = 0,\r\n    var readable: Boolean = false,\r\n    var writeable: Boolean = false\r\n)","package venusbackend.simulator\r\n\r\nimport venus.vfs.VFSFile\r\nimport venus.vfs.VFSType\r\n// Fixme make the fileshandler handle numbers and not Ints!\r\nclass FilesHandler(sim: Simulator) {\r\n    companion object {\r\n        var EOF = -1\r\n    }\r\n    val files = HashMap<Int, FileDescriptor>()\r\n    var fdCounter = 3\r\n\r\n    fun openFile(sim: Simulator, filename: String, permissions: Int): Int {\r\n        // open file in VFS here\r\n        val o = sim.VFS.getObjectFromPath(filename)\r\n        /*\r\n        0 = r (only can read)\r\n        1 = w (resets file contents and is only writable)\r\n        2 = a (does not reset file contents but is only writeable)\r\n        3 = r+ (RW)\r\n        4 = w+ (RW reset file contents)\r\n        5 = a+ (RW)\r\n        */\r\n        var resetText = false\r\n        val rw = when (permissions) {\r\n            0 -> {\r\n                if (o == null) {\r\n                    return EOF\r\n                }\r\n                FileMetaData(0, true, false)\r\n            }\r\n            1 -> {\r\n                resetText = true\r\n                FileMetaData(0, false, true)\r\n            }\r\n            2 -> {\r\n                FileMetaData(0, false, true)\r\n            }\r\n            3 -> {\r\n                if (o == null) {\r\n                    return EOF\r\n                }\r\n                FileMetaData(0, true, true)\r\n            }\r\n            4 -> {\r\n                resetText = true\r\n                FileMetaData(0, true, true)\r\n            }\r\n            5 -> {\r\n                FileMetaData(0, true, true)\r\n            }\r\n            else -> {\r\n                return EOF\r\n            }\r\n        }\r\n        val f = if (o == null) {\r\n            sim.VFS.makeFileInDir(filename) ?: return EOF\r\n        } else {\r\n            if (o.type == VFSType.File) {\r\n                o as VFSFile\r\n            } else {\r\n                return EOF\r\n            }\r\n        }\r\n        if (resetText) {\r\n            f.setText(\"\")\r\n        }\r\n        val fd = FileDescriptor(f, rw)\r\n        files[fdCounter] = fd\r\n        return fdCounter++\r\n    }\r\n\r\n    fun getFileDescriptor(fdID: Int): FileDescriptor? {\r\n        if (files.containsKey(fdID)) {\r\n            return files[fdID]\r\n        }\r\n        return null\r\n    }\r\n\r\n    fun closeFileDescriptor(fdID: Int): Int {\r\n        val fd = files.remove(fdID)\r\n        return fd?.flush() ?: EOF\r\n    }\r\n\r\n    fun flushFileDescriptor(fdID: Int): Int {\r\n        val fd = getFileDescriptor(fdID)\r\n        return fd?.flush() ?: EOF\r\n    }\r\n\r\n    fun readFileDescriptor(fdID: Int, size: Int): String? {\r\n        if (size < 0) {\r\n            return null\r\n        }\r\n        val fd = getFileDescriptor(fdID)\r\n        return fd?.read(size)\r\n    }\r\n\r\n    fun writeFileDescriptor(fdID: Int, value: String): Int {\r\n        val fd = getFileDescriptor(fdID)\r\n        return fd?.write(value) ?: EOF\r\n    }\r\n\r\n    fun getFileDescriptorEOF(fdID: Int): Int {\r\n        val fd = getFileDescriptor(fdID)\r\n        return fd?.isEOF() ?: EOF\r\n    }\r\n\r\n    fun getFileDescriptorError(fdID: Int): Int {\r\n        val fd = getFileDescriptor(fdID)\r\n        return fd?.getError() ?: EOF\r\n    }\r\n}","package venusbackend.simulator\r\n\r\n/* TODO: add a way to have a limit (maybe a deque?) */\r\nclass History {\r\n    private val diffs = ArrayList<List<Diff>>()\r\n\r\n    fun add(pre: List<Diff>) = diffs.add(pre.toList())\r\n    fun pop() = diffs.removeAt(diffs.size - 1)\r\n    fun isEmpty() = diffs.isEmpty()\r\n}","package venusbackend.simulator\r\n\r\nimport venusbackend.plus\r\nimport venusbackend.shr\r\n\r\n/**\r\n * A class representing a computer's memory.\r\n */\r\nclass Memory {\r\n    /**\r\n     * A hashmap which maps addresses to the value stored at that place in memory.\r\n     *\r\n     * Unlike MARS, I've made the design decision to use a hashmap. This allows for us to write anywhere in memory\r\n     * without being concerned with writing out of bounds (4 MB). The downside is that this has a higher overhead.\r\n     *\r\n     * @todo Transition to a `HashMap<Int, Int>`, which will have a smaller overhead (although more code complexity)\r\n     */\r\n    // TODO Change this from long :(\r\n    private val memory = HashMap<Long, Byte>()\r\n\r\n    fun removeByte(addr: Number) {\r\n        memory.remove(addr)\r\n    }\r\n\r\n    /**\r\n     * Loads an unsigned byte from memory\r\n     *\r\n     * @param addr the address to load from\r\n     * @return the byte at that location, or 0 if that location has not been written to\r\n     */\r\n//    fun loadByte(addr: Number): Int = memory[addr]?.toInt()?.and(0xff) ?: 0\r\n    fun loadByte(addr: Number): Int {\r\n        val v = memory[addr.toLong()]\r\n        return v?.toInt()?.and(0xff) ?: 0\r\n    }\r\n\r\n    /**\r\n     * Loads an unsigned halfword from memory\r\n     *\r\n     * @param addr the address to load from\r\n     * @return the halfword at that location, or 0 if that location has not been written to\r\n     */\r\n//    fun loadHalfWord(addr: Number): Int = (loadByte(addr + 1) shl 8) or loadByte(addr)\r\n    fun loadHalfWord(addr: Number): Int {\r\n        val lsb = loadByte(addr)\r\n        val msbb = loadByte(addr + 1)\r\n        val msb = (msbb shl 8)\r\n        return msb or lsb\r\n    }\r\n\r\n    /**\r\n     * Loads a word from memory\r\n     *\r\n     * @param addr the address to load from\r\n     * @return the word at that location, or 0 if that location has not been written to\r\n     */\r\n    fun loadWord(addr: Number): Int = (loadHalfWord(addr + 2) shl 16) or loadHalfWord(addr)\r\n\r\n    /**\r\n     * Loads a long from memory\r\n     *\r\n     * @param addr the address to load from\r\n     * @return the long at that location, or 0 if that location has not been written to\r\n     */\r\n    fun loadLong(addr: Number): Long = (loadWord(addr + 4).toLong() shl 32) or loadWord(addr).toLong()\r\n\r\n    /**\r\n     * Stores a byte in memory, truncating the given Int if necessary\r\n     *\r\n     * @param addr the address to write to\r\n     * @param value the value to write\r\n     */\r\n    fun storeByte(addr: Number, value: Number) { memory[addr.toLong()] = value.toByte() }\r\n\r\n    /**\r\n     * Stores a halfword in memory, truncating the given Int if necessary\r\n     *\r\n     * @param addr the address to write to\r\n     * @param value the value to write\r\n     */\r\n    fun storeHalfWord(addr: Number, value: Number) {\r\n        storeByte(addr, value)\r\n        storeByte(addr + 1, value shr 8)\r\n    }\r\n\r\n    /**\r\n     * Stores a word in memory\r\n     *\r\n     * @param addr the address to write to\r\n     * @param value the value to write\r\n     */\r\n    fun storeWord(addr: Number, value: Number) {\r\n        storeHalfWord(addr, value)\r\n        storeHalfWord(addr + 2, value shr 16)\r\n    }\r\n\r\n    /**\r\n     * Stores a word in memory\r\n     *\r\n     * @param addr the address to write to\r\n     * @param value the value to write\r\n     */\r\n    fun storeLong(addr: Number, value: Number) {\r\n        storeWord(addr, value)\r\n        storeWord(addr + 4, value shr 32)\r\n    }\r\n}","package venusbackend.simulator\r\n\r\n/* ktlint-disable no-wildcard-imports */\r\n\r\nimport venus.Renderer\r\nimport venus.vfs.VirtualFileSystem\r\nimport venusbackend.*\r\nimport venusbackend.linker.LinkedProgram\r\nimport venusbackend.riscv.*\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.riscv.insts.integer.base.i.ecall.Alloc\r\nimport venusbackend.simulator.diffs.*\r\nimport kotlin.math.max\r\n\r\n/* ktlint-enable no-wildcard-imports */\r\n\r\n/** Right now, this is a loose wrapper around SimulatorState\r\n    Eventually, it will support debugging. */\r\nclass Simulator(\r\n    val linkedProgram: LinkedProgram,\r\n    val VFS: VirtualFileSystem = VirtualFileSystem(\"dummy\"),\r\n    var settings: SimulatorSettings = SimulatorSettings(),\r\n    val state: SimulatorState = SimulatorState32(),\r\n    val simulatorID: Int = 0\r\n) {\r\n\r\n    private var cycles = 0\r\n    private val history = History()\r\n    private val preInstruction = ArrayList<Diff>()\r\n    private val postInstruction = ArrayList<Diff>()\r\n//    private val breakpoints: Array<Boolean>\r\n    private val breakpoints = HashSet<Int>()\r\n    var args = ArrayList<String>()\r\n    var ebreak = false\r\n    var stdout = \"\"\r\n    var filesHandler = FilesHandler(this)\r\n    val instOrderMapping = HashMap<Int, Int>()\r\n    val invInstOrderMapping = HashMap<Int, Int>()\r\n    var exitcode: Int? = null\r\n\r\n    val alloc: Alloc = Alloc(this)\r\n\r\n    init {\r\n        (state).getReg(1)\r\n        var i = 0\r\n        for (inst in linkedProgram.prog.insts) {\r\n            instOrderMapping[i] = state.getMaxPC().toInt()\r\n            invInstOrderMapping[state.getMaxPC().toInt()] = i\r\n            i++\r\n            var mcode = inst[InstructionField.ENTIRE]\r\n            for (j in 0 until inst.length) {\r\n                state.mem.storeByte(state.getMaxPC(), mcode and 0xFF)\r\n                mcode = mcode shr 8\r\n                state.incMaxPC(1)\r\n            }\r\n        }\r\n\r\n        var dataOffset = MemorySegments.STATIC_BEGIN\r\n        for (datum in linkedProgram.prog.dataSegment) {\r\n            state.mem.storeByte(dataOffset, datum.toInt())\r\n            dataOffset++\r\n        }\r\n\r\n        state.setHeapEnd(max(state.getHeapEnd().toInt(), dataOffset))\r\n\r\n        setPC(linkedProgram.startPC ?: MemorySegments.TEXT_BEGIN)\r\n        if (settings.setRegesOnInit) {\r\n            state.setReg(Registers.sp, MemorySegments.STACK_BEGIN)\r\n//            state.setReg(Registers.fp, MemorySegments.STACK_BEGIN)\r\n            state.setReg(Registers.gp, MemorySegments.STATIC_BEGIN)\r\n            if (linkedProgram.prog.isGlobalLabel(\"main\")) {\r\n                state.setReg(Registers.ra, state.getMaxPC())\r\n                settings.ecallOnlyExit = false // This is because this will not work with ecall exit only with this current hotfix\r\n                try {\r\n                    Renderer.updateRegister(Registers.ra, state.getMaxPC())\r\n                } catch (e: Exception) {}\r\n            }\r\n        }\r\n\r\n//        breakpoints = Array(linkedProgram.prog.insts.size, { false })\r\n    }\r\n\r\n    fun isDone(): Boolean {\r\n        return if (settings.ecallOnlyExit) {\r\n            this.exitcode != null\r\n        } else {\r\n            getPC() >= state.getMaxPC()\r\n        }\r\n    }\r\n\r\n    fun getCycles(): Int {\r\n        return cycles\r\n    }\r\n\r\n    fun getMaxPC(): Number {\r\n        return state.getMaxPC()\r\n    }\r\n\r\n    fun incMaxPC(amount: Number) {\r\n        state.incMaxPC(amount)\r\n    }\r\n\r\n    fun getInstAt(addr: Number): MachineCode {\r\n        val instnum = invInstOrderMapping[addr]!!.toInt()\r\n        return linkedProgram.prog.insts[instnum]\r\n    }\r\n\r\n    fun setMemory(mem: Memory) {\r\n        state.mem = mem\r\n    }\r\n\r\n    fun run() {\r\n        while (!isDone()) {\r\n            step()\r\n        }\r\n    }\r\n\r\n    fun runToBreakpoint() {\r\n        if (!isDone()) {\r\n            // We need to step past a breakpoint.\r\n            step()\r\n        }\r\n        while (!isDone() && !atBreakpoint()) {\r\n            step()\r\n        }\r\n    }\r\n\r\n    fun step(): List<Diff> {\r\n        if (settings.maxSteps >= 0 && cycles >= settings.maxSteps) {\r\n            throw ExceededAllowedCyclesError(\"Ran for more than the max allowed steps (${settings.maxSteps})!\")\r\n        }\r\n        this.branched = false\r\n        this.jumped = false\r\n        this.ebreak = false\r\n        this.ecallMsg = \"\"\r\n        cycles++\r\n        preInstruction.clear()\r\n        postInstruction.clear()\r\n        val mcode: MachineCode = getNextInstruction()\r\n        try {\r\n            when (state.registerWidth) {\r\n                16 -> { Instruction[mcode].impl16(mcode, this) }\r\n                32 -> { Instruction[mcode].impl32(mcode, this) }\r\n                64 -> { Instruction[mcode].impl64(mcode, this) }\r\n                128 -> { Instruction[mcode].impl128(mcode, this) }\r\n                else -> { throw SimulatorError(\"Unsupported register width!\") }\r\n            }\r\n        } catch (e: SimulatorError) {\r\n            if (e.infe == null) {\r\n                throw e\r\n            }\r\n            Renderer.displayError(\"\\n[ERROR]: Could not decode the instruction (0x\" + mcode.toString(16) + \") at pc='\" + toHex(getPC()) + \"'!\\n\" +\r\n                    \"Please make sure that you are not jumping to the middle of an instruction!\\n\")\r\n            throw e\r\n        }\r\n        history.add(preInstruction)\r\n        this.stdout += this.ecallMsg\r\n        if (isDone() && exitcode == null) {\r\n            exitcode = state.getReg(Registers.a0).toInt()\r\n        }\r\n        return postInstruction.toList()\r\n    }\r\n\r\n    fun undo(): List<Diff> {\r\n        exitcode = null\r\n        if (!canUndo()) return emptyList() /* TODO: error here? */\r\n        val diffs = history.pop()\r\n        for (diff in diffs) {\r\n            diff(state)\r\n        }\r\n        cycles--\r\n        return diffs\r\n    }\r\n\r\n    fun removeAllArgsFromMem() {\r\n        var sp = getReg(2)\r\n        while (sp < MemorySegments.STACK_BEGIN && settings.setRegesOnInit) {\r\n            this.state.mem.removeByte(sp)\r\n            sp++\r\n            setReg(Registers.sp, sp)\r\n        }\r\n    }\r\n\r\n    fun removeAllArgs() {\r\n        removeAllArgsFromMem()\r\n        this.args.removeAll(this.args)\r\n    }\r\n\r\n    fun removeArg(index: Int) {\r\n        if (index in 0 until this.args.size) {\r\n            this.args.removeAt(index)\r\n            this.removeAllArgsFromMem()\r\n            addArgsToMem()\r\n        }\r\n    }\r\n\r\n    fun addArg(arg: String) {\r\n        args.add(arg)\r\n        removeAllArgsFromMem()\r\n        addArgsToMem()\r\n    }\r\n\r\n    fun addArg(newargs: List<String>) {\r\n        args.addAll(newargs)\r\n        removeAllArgsFromMem()\r\n        addArgsToMem()\r\n    }\r\n\r\n    fun addArgsToMem() {\r\n        val registerSize = state.registerWidth / 8\r\n        val intSize = 4\r\n        if (!settings.setRegesOnInit) {\r\n            return\r\n        }\r\n        var spv = if (getReg(2) == MemorySegments.STACK_BEGIN) {\r\n            getReg(2)\r\n        } else {\r\n            getReg(11)\r\n        } - 1\r\n        var argv = ArrayList<Number>()\r\n        var tmpargs = arrayListOf(linkedProgram.prog.name)\r\n        tmpargs.addAll(args)\r\n        for (arg in tmpargs) {\r\n            spv = getReg(Registers.sp) - 1\r\n            /*Got to add the null terminator as well!*/\r\n            storeByte(spv, 0)\r\n            setRegNoUndo(Registers.sp, spv)\r\n            for (c in arg.reversed()) {\r\n                spv = getReg(Registers.sp) - 1\r\n                storeByte(spv, c.toInt())\r\n                setRegNoUndo(Registers.sp, spv)\r\n            }\r\n            argv.add(spv)\r\n        }\r\n        spv -= (spv % registerSize)\r\n        /**\r\n         * Next we need to create the argv array.\r\n         */\r\n        // First have to allocate a new space and load the null to the end of the array.\r\n        spv -= intSize\r\n        storeWord(spv, 0)\r\n        // Next, we need to add the different arg strings to our argv array.\r\n        for (arg in argv.reversed()) {\r\n            spv -= intSize\r\n            storeWord(spv, arg)\r\n        }\r\n        /**\r\n         * We need to store a0 (x10) to the argc and a1 (x11) to argv.\r\n         */\r\n        setRegNoUndo(Registers.a0, tmpargs.size)\r\n        setRegNoUndo(Registers.a1, spv)\r\n        setRegNoUndo(Registers.sp, spv)\r\n        try {\r\n            Renderer.updateRegister(Registers.sp, getReg(Registers.sp))\r\n            Renderer.updateRegister(Registers.a0, getReg(Registers.a0))\r\n            Renderer.updateRegister(Registers.a1, getReg(Registers.a1))\r\n            Renderer.updateMemory(Renderer.activeMemoryAddress)\r\n        } catch (e: Throwable) {}\r\n    }\r\n\r\n    var ecallMsg = \"\"\r\n    var branched = false\r\n    var jumped = false\r\n    fun reset(keep_args: Boolean = false) {\r\n        while (this.canUndo()) {\r\n            this.undo()\r\n        }\r\n        this.branched = false\r\n        this.jumped = false\r\n        this.ecallMsg = \"\"\r\n        this.stdout = \"\"\r\n        cycles = 0\r\n        exitcode = null\r\n        val args = ArrayList(this.args)\r\n        removeAllArgs()\r\n        if (keep_args) {\r\n            addArg(args)\r\n        }\r\n        state.reset()\r\n    }\r\n\r\n    fun trace(): Tracer {\r\n        return Tracer(this)\r\n    }\r\n\r\n    fun canUndo() = !history.isEmpty()\r\n\r\n    fun getReg(id: Int) = state.getReg(id)\r\n\r\n    fun setReg(id: Int, v: Number) {\r\n        preInstruction.add(RegisterDiff(id, getReg(id)))\r\n        state.setReg(id, v)\r\n        postInstruction.add(RegisterDiff(id, getReg(id)))\r\n    }\r\n\r\n    fun setRegNoUndo(id: Int, v: Number) {\r\n        state.setReg(id, v)\r\n    }\r\n\r\n    fun getFReg(id: Int) = state.getFReg(id)\r\n\r\n    fun setFReg(id: Int, v: Decimal) {\r\n        preInstruction.add(FRegisterDiff(id, state.getFReg(id)))\r\n        state.setFReg(id, v)\r\n        postInstruction.add(FRegisterDiff(id, state.getFReg(id)))\r\n    }\r\n\r\n    fun setFRegNoUndo(id: Int, v: Decimal) {\r\n        state.setFReg(id, v)\r\n    }\r\n\r\n    fun toggleBreakpointAt(idx: Int): Boolean {\r\n//        breakpoints[idx] = !breakpoints[idx]\r\n//        return breakpoints[idx]\r\n        if (breakpoints.contains(idx)) {\r\n            breakpoints.remove(idx)\r\n            return false\r\n        } else {\r\n            breakpoints.add(idx)\r\n            return true\r\n        }\r\n    }\r\n\r\n    /* TODO Make this more efficient while robust! */\r\n    fun atBreakpoint(): Boolean {\r\n        val location = (getPC() - MemorySegments.TEXT_BEGIN).toLong()\r\n        val inst = invInstOrderMapping[location.toInt()]\r\n        if (inst == null) {\r\n//            Renderer.displayWarning(\"\"\"Could not find an instruction mapped to the current address when checking for a breakpoint!\"\"\")\r\n            return ebreak\r\n        }\r\n//        return ebreak || breakpoints[inst]\r\n//        return ebreak || breakpoints.contains(location.toInt())\r\n        return ebreak xor breakpoints.contains(location.toInt() - 4)\r\n    }\r\n\r\n    fun getPC() = state.getPC()\r\n\r\n    fun setPC(newPC: Number) {\r\n        preInstruction.add(PCDiff(getPC()))\r\n        state.setPC(newPC)\r\n        postInstruction.add(PCDiff(getPC()))\r\n    }\r\n\r\n    fun incrementPC(inc: Number) {\r\n        preInstruction.add(PCDiff(getPC()))\r\n        state.incPC(inc)\r\n        postInstruction.add(PCDiff(getPC()))\r\n    }\r\n\r\n    fun isValidAccess(addr: Number, bytes: Int) {\r\n        if (!this.settings.allowAccessBtnStackHeap) {\r\n            val upperAddr = addr + bytes\r\n            val sp = state.getReg(Registers.sp)\r\n            val heap = state.getHeapEnd()\r\n            if ((addr > heap && addr < sp) ||\r\n                (upperAddr > heap && upperAddr < sp)) {\r\n                throw SimulatorError(\r\n                        \"Attempting to access uninitialized memory between the stack and heap. Attempting to access '$bytes' bytes at address '$addr'.\",\r\n                        handled = true)\r\n            }\r\n        }\r\n    }\r\n\r\n    fun loadByte(addr: Number): Int = state.mem.loadByte(addr)\r\n    fun loadBytewCache(addr: Number): Int {\r\n        if (this.settings.alignedAddress && addr % MemSize.BYTE.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not BYTE aligned!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.BYTE.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.BYTE)))\r\n        state.cache.read(Address(addr, MemSize.BYTE))\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.BYTE)))\r\n        return this.loadByte(addr)\r\n    }\r\n\r\n    fun loadHalfWord(addr: Number): Int = state.mem.loadHalfWord(addr)\r\n    fun loadHalfWordwCache(addr: Number): Int {\r\n        if (this.settings.alignedAddress && addr % MemSize.HALF.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not HALF WORD aligned!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.HALF.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.HALF)))\r\n        state.cache.read(Address(addr, MemSize.HALF))\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.HALF)))\r\n        return this.loadHalfWord(addr)\r\n    }\r\n\r\n    fun loadWord(addr: Number): Int = state.mem.loadWord(addr)\r\n    fun loadWordwCache(addr: Number): Int {\r\n        if (this.settings.alignedAddress && addr % MemSize.WORD.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not WORD aligned!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.WORD.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.WORD)))\r\n        state.cache.read(Address(addr, MemSize.WORD))\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.WORD)))\r\n        return this.loadWord(addr)\r\n    }\r\n\r\n    fun loadLong(addr: Number): Long = state.mem.loadLong(addr)\r\n    fun loadLongwCache(addr: Number): Long {\r\n        if (this.settings.alignedAddress && addr % MemSize.LONG.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not LONG aligned!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.LONG.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.LONG)))\r\n        state.cache.read(Address(addr, MemSize.LONG))\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.LONG)))\r\n        return this.loadLong(addr)\r\n    }\r\n\r\n    fun storeByte(addr: Number, value: Number) {\r\n        preInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        state.mem.storeByte(addr, value)\r\n        postInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        this.storeTextOverrideCheck(addr, value, MemSize.BYTE)\r\n    }\r\n    fun storeBytewCache(addr: Number, value: Number) {\r\n        if (this.settings.alignedAddress && addr % MemSize.BYTE.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not BYTE aligned!\")\r\n        }\r\n        // FIXME change the cast to maxpc to something more generic or make the iterator be generic.\r\n        if (!this.settings.mutableText && addr in (MemorySegments.TEXT_BEGIN + 1 - MemSize.BYTE.size)..state.getMaxPC().toInt()) {\r\n            throw StoreError(\"You are attempting to edit the text of the program though the program is set to immutable at address \" + Renderer.toHex(addr) + \"!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.BYTE.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.BYTE)))\r\n        state.cache.write(Address(addr, MemSize.BYTE))\r\n        this.storeByte(addr, value)\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.BYTE)))\r\n    }\r\n\r\n    fun storeHalfWord(addr: Number, value: Number) {\r\n        preInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        state.mem.storeHalfWord(addr, value)\r\n        postInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        this.storeTextOverrideCheck(addr, value, MemSize.HALF)\r\n    }\r\n    fun storeHalfWordwCache(addr: Number, value: Number) {\r\n        if (this.settings.alignedAddress && addr % MemSize.HALF.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not HALF WORD aligned!\")\r\n        }\r\n        if (!this.settings.mutableText && addr in (MemorySegments.TEXT_BEGIN + 1 - MemSize.HALF.size)..state.getMaxPC().toInt()) {\r\n            throw StoreError(\"You are attempting to edit the text of the program though the program is set to immutable at address \" + Renderer.toHex(addr) + \"!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.HALF.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.HALF)))\r\n        state.cache.write(Address(addr, MemSize.HALF))\r\n        this.storeHalfWord(addr, value)\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.HALF)))\r\n    }\r\n\r\n    fun storeWord(addr: Number, value: Number) {\r\n        preInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        state.mem.storeWord(addr, value)\r\n        postInstruction.add(MemoryDiff(addr, loadWord(addr)))\r\n        this.storeTextOverrideCheck(addr, value, MemSize.WORD)\r\n    }\r\n    fun storeWordwCache(addr: Number, value: Number) {\r\n        if (this.settings.alignedAddress && addr % MemSize.WORD.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not WORD aligned!\")\r\n        }\r\n        if (!this.settings.mutableText && addr in (MemorySegments.TEXT_BEGIN + 1 - MemSize.WORD.size)..state.getMaxPC().toInt()) {\r\n            throw StoreError(\"You are attempting to edit the text of the program though the program is set to immutable at address \" + Renderer.toHex(addr) + \"!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.WORD.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.WORD)))\r\n        state.cache.write(Address(addr, MemSize.WORD))\r\n        this.storeWord(addr, value)\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.WORD)))\r\n    }\r\n\r\n    fun storeLong(addr: Number, value: Number) {\r\n        preInstruction.add(MemoryDiff(addr, loadLong(addr)))\r\n        state.mem.storeLong(addr, value)\r\n        postInstruction.add(MemoryDiff(addr, loadLong(addr)))\r\n        this.storeTextOverrideCheck(addr, value, MemSize.LONG)\r\n    }\r\n    fun storeLongwCache(addr: Number, value: Number) {\r\n        if (this.settings.alignedAddress && addr % MemSize.LONG.size != 0) {\r\n            throw AlignmentError(\"Address: '\" + Renderer.toHex(addr) + \"' is not long aligned!\")\r\n        }\r\n        if (!this.settings.mutableText && addr in (MemorySegments.TEXT_BEGIN + 1 - MemSize.WORD.size)..state.getMaxPC().toInt()) {\r\n            throw StoreError(\"You are attempting to edit the text of the program though the program is set to immutable at address \" + Renderer.toHex(addr) + \"!\")\r\n        }\r\n        this.isValidAccess(addr, MemSize.LONG.size)\r\n        preInstruction.add(CacheDiff(Address(addr, MemSize.LONG)))\r\n        state.cache.write(Address(addr, MemSize.LONG))\r\n        this.storeLong(addr, value)\r\n        postInstruction.add(CacheDiff(Address(addr, MemSize.LONG)))\r\n    }\r\n\r\n    fun storeTextOverrideCheck(addr: Number, value: Number, size: MemSize) {\r\n        /*Here, we will check if we are writing to memory*/\r\n        if (addr in (MemorySegments.TEXT_BEGIN until state.getMaxPC().toInt()) || (addr + size.size - MemSize.BYTE.size) in (MemorySegments.TEXT_BEGIN until state.getMaxPC().toInt())) {\r\n            try {\r\n                val adjAddr = ((addr / MemSize.WORD.size) * MemSize.WORD.size)\r\n                val lowerAddr = adjAddr - MemorySegments.TEXT_BEGIN\r\n                var newInst = this.state.mem.loadWord(adjAddr)\r\n                preInstruction.add(Renderer.updateProgramListing(lowerAddr, newInst))\r\n                if ((lowerAddr + MemorySegments.TEXT_BEGIN) != addr && (lowerAddr + MemSize.WORD.size - MemSize.BYTE.size) < state.getMaxPC()) {\r\n                    var newInst2 = this.state.mem.loadWord(adjAddr + MemSize.WORD.size)\r\n                    preInstruction.add(Renderer.updateProgramListing((lowerAddr) + 4, newInst2))\r\n                }\r\n            } catch (e: Throwable) { /*This is to not error the tests.*/ }\r\n        }\r\n    }\r\n\r\n    fun getHeapEnd() = state.getHeapEnd()\r\n\r\n    fun addHeapSpace(bytes: Number) {\r\n        if (willHeapOverrideStack(bytes)) {\r\n            throw SimulatorError(\"The heap has grown into the stack.\")\r\n        }\r\n        preInstruction.add(HeapSpaceDiff(state.getHeapEnd()))\r\n        state.incHeapEnd(bytes)\r\n        postInstruction.add(HeapSpaceDiff(state.getHeapEnd()))\r\n    }\r\n\r\n    fun willHeapOverrideStack(bytes: Number): Boolean {\r\n        return (getHeapEnd() + bytes) >= getReg(Registers.sp)\r\n    }\r\n\r\n    private fun getInstructionLength(short0: Int): Int {\r\n        if ((short0 and 0b11) != 0b11) {\r\n            return 2\r\n        } else if ((short0 and 0b11111) != 0b11111) {\r\n            return 4\r\n        } else if ((short0 and 0b111111) == 0b011111) {\r\n            return 6\r\n        } else if ((short0 and 0b1111111) == 0b111111) {\r\n            return 8\r\n        } else {\r\n            throw SimulatorError(\"instruction lengths > 8 not supported\")\r\n        }\r\n    }\r\n\r\n    fun getNextInstruction(): MachineCode {\r\n        val pc = getPC()\r\n        var instruction: ULong = loadHalfWord(pc).toULong()\r\n        val length = getInstructionLength(instruction.toInt())\r\n        for (i in 1 until length / 2) {\r\n            val short = loadHalfWord(pc + 2).toULong()\r\n            instruction = (short shl 16 * i) or instruction\r\n        }\r\n        val intStruction = instruction.toInt()\r\n        val mcode = MachineCode(intStruction)\r\n        mcode.length = length\r\n        return mcode\r\n    }\r\n\r\n    fun memcpy(destaddr: Int, srcaddr: Int, size: Int): Int {\r\n        var dest = destaddr\r\n        var src = srcaddr\r\n        var s = size\r\n        while (s > 0) {\r\n            storeByte(dest, loadByte(src))\r\n            dest++\r\n            src++\r\n            s--\r\n        }\r\n        return destaddr\r\n    }\r\n\r\n    fun memset(destaddr: Int, item: Int, size: Int): Int {\r\n        var dest = destaddr\r\n        var s = size\r\n        while (s > 0) {\r\n            storeByte(dest, item)\r\n            dest++\r\n            s--\r\n        }\r\n        return destaddr\r\n    }\r\n\r\n//    fun dump(sim: Simulator): CoreDump {\r\n//        val d = HashMap<String, Any>()\r\n//        d.put(\"time\", Date.now().toString())\r\n//        val integer = HashMap<Int, Number>()\r\n//        val floating = HashMap<Int, Decimal>()\r\n//        for (i in 1 until 32) {\r\n//            integer[i] = sim.getReg(i)\r\n//            floating[i] = sim.getFReg(i)\r\n//        }\r\n//        val registers = HashMap<String, HashMap<Int, Number>>()\r\n//        d.put(\"registers\", registers)\r\n//        val memory = HashMap<String, Short>()\r\n//        d.put(\"memory\", memory)\r\n//        return d\r\n//    }\r\n}\r\n//\r\n// data class CoreDump(\r\n//        var time: String,\r\n//        var regisers: CoreDumpRegisters,\r\n//        var memory: HashMap<Int, Int>\r\n// )\r\n//\r\n// data class CoreDumpRegisters(\r\n//        var integer: CoreDumpRegister,\r\n//        var floating: CoreDumpRegister\r\n// )\r\n//\r\n// data class CoreDumpRegister(\r\n//        var id: String,\r\n//        var value: String\r\n// )","package venusbackend.simulator\r\n\r\nimport venusbackend.riscv.insts.InstructionNotFoundError\r\n\r\n/**\r\n * Thrown when errors occur during simulation.\r\n */\r\nopen class SimulatorError : Throwable {\r\n    open var infe: InstructionNotFoundError? = null\r\n    open var handled: Boolean? = null\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null, infe: InstructionNotFoundError? = null, handled: Boolean? = null) : super(msg) {\r\n        this.infe = infe\r\n        this.handled = handled\r\n    }\r\n}\r\n","package venusbackend.simulator\r\n\r\n/**\r\n * Created by thaum on 7/31/2018.\r\n */\r\ndata class SimulatorSettings(\r\n    var alignedAddress: Boolean = false,\r\n    var mutableText: Boolean = true,\r\n    var ecallOnlyExit: Boolean = false,\r\n    var setRegesOnInit: Boolean = true,\r\n    var maxSteps: Int = -1,\r\n    var ASLR: Boolean = false,\r\n    var NX_bit: Boolean = false,\r\n    var allowAccessBtnStackHeap: Boolean = false\r\n)","package venusbackend.simulator\r\n\r\nimport venusbackend.numbers.QuadWord\r\nimport venusbackend.numbers.toQuadWord\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.cache.CacheHandler\r\n\r\nclass SimulatorState128 : SimulatorState {\r\n    /*Register 32 is the special register.*/\r\n    private val regs128 = Array(33) { QuadWord() }\r\n    private val fregs = Array(33) { Decimal() }\r\n    private var pc: QuadWord = QuadWord()\r\n    private var maxpc: QuadWord = MemorySegments.TEXT_BEGIN.toQuadWord()\r\n    private var heapEnd = MemorySegments.HEAP_BEGIN.toQuadWord()\r\n\r\n    override val registerWidth = 128\r\n    override var mem = Memory()\r\n    override var cache = CacheHandler(1)\r\n    override fun setCacheHandler(ch: CacheHandler) {\r\n        cache = ch\r\n    }\r\n    override fun setPC(location: Number) {\r\n        this.pc = location.toQuadWord()\r\n    }\r\n    override fun getPC(): Number {\r\n        return this.pc\r\n    }\r\n    override fun incPC(amount: Number) {\r\n        this.pc += amount.toQuadWord()\r\n    }\r\n    override fun setMaxPC(location: Number) {\r\n        this.maxpc = location.toQuadWord()\r\n    }\r\n    override fun getMaxPC(): Number {\r\n        return this.maxpc\r\n    }\r\n    override fun incMaxPC(amount: Number) {\r\n        this.maxpc = (this.maxpc + amount.toQuadWord()).toQuadWord()\r\n    }\r\n    override fun getReg(i: Int) = regs128[i]\r\n    override fun setReg(i: Int, v: Number) { if (i != 0) regs128[i] = v.toQuadWord() }\r\n    override fun getFReg(i: Int) = fregs[i]\r\n    override fun setFReg(i: Int, v: Decimal) { fregs[i] = v }\r\n    override fun getHeapEnd(): Number {\r\n        return heapEnd\r\n    }\r\n\r\n    override fun setHeapEnd(i: Number) {\r\n        heapEnd = i.toQuadWord()\r\n    }\r\n\r\n    override fun incHeapEnd(amount: Number) {\r\n        heapEnd += amount.toQuadWord()\r\n    }\r\n\r\n    override fun reset() {\r\n        this.cache.reset()\r\n    }\r\n}\r\n","package venusbackend.simulator\r\n\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.cache.CacheHandler\r\n\r\nclass SimulatorState16 : SimulatorState {\r\n    /* Register 32 is the special register. */\r\n    private val regs16 = Array(33) { 0.toShort() }\r\n    private val fregs = Array(33) { Decimal() }\r\n    private var pc: Short = 0\r\n    private var maxpc: Short = MemorySegments.TEXT_BEGIN.toShort()\r\n    private var heapEnd = MemorySegments.HEAP_BEGIN.toShort()\r\n\r\n    override val registerWidth = 16\r\n    override var mem = Memory()\r\n    override var cache = CacheHandler(1)\r\n    override fun setCacheHandler(ch: CacheHandler) {\r\n        cache = ch\r\n    }\r\n    override fun setPC(location: Number) {\r\n        this.pc = location.toShort()\r\n    }\r\n    override fun getPC(): Number {\r\n        return this.pc\r\n    }\r\n    override fun incPC(amount: Number) {\r\n        this.pc = (this.pc + amount.toShort()).toShort()\r\n    }\r\n    override fun setMaxPC(location: Number) {\r\n        this.maxpc = location.toShort()\r\n    }\r\n    override fun getMaxPC(): Number {\r\n        return this.maxpc\r\n    }\r\n    override fun incMaxPC(amount: Number) {\r\n        this.maxpc = (this.maxpc + amount.toShort()).toShort()\r\n    }\r\n    override fun getReg(i: Int) = regs16[i]\r\n    override fun setReg(i: Int, v: Number) { if (i != 0) regs16[i] = v.toShort() }\r\n    override fun getFReg(i: Int) = fregs[i]\r\n    override fun setFReg(i: Int, v: Decimal) { fregs[i] = v }\r\n    override fun getHeapEnd(): Number {\r\n        return heapEnd\r\n    }\r\n\r\n    override fun setHeapEnd(i: Number) {\r\n        heapEnd = i.toShort()\r\n    }\r\n\r\n    override fun incHeapEnd(amount: Number) {\r\n        heapEnd = (heapEnd + amount.toShort()).toShort()\r\n    }\r\n\r\n    override fun reset() {\r\n        this.cache.reset()\r\n    }\r\n}\r\n","package venusbackend.simulator\r\n\r\nimport venusbackend.riscv.MemorySegments\r\nimport venusbackend.riscv.insts.floating.Decimal\r\nimport venusbackend.simulator.cache.CacheHandler\r\n\r\nclass SimulatorState32 : SimulatorState {\r\n    /* Register 32 is the special register. */\r\n    private val regs32 = Array(33) { 0 }\r\n    private val fregs = Array(33) { Decimal() }\r\n    private var pc: Int = 0\r\n    private var maxpc: Int = MemorySegments.TEXT_BEGIN\r\n    private var heapEnd = MemorySegments.HEAP_BEGIN\r\n\r\n    override val registerWidth = 32\r\n    override var mem = Memory()\r\n    override var cache = CacheHandler(1)\r\n    override fun setCacheHandler(ch: CacheHandler) {\r\n        cache = ch\r\n    }\r\n    override fun setPC(location: Number) {\r\n        this.pc = location.toInt()\r\n    }\r\n    override fun getPC(): Number {\r\n        return this.pc\r\n    }\r\n    override fun incPC(amount: Number) {\r\n        this.pc += amount.toInt()\r\n    }\r\n    override fun setMaxPC(location: Number) {\r\n        this.maxpc = location.toInt()\r\n    }\r\n    override fun getMaxPC(): Number {\r\n        return this.maxpc\r\n    }\r\n    override fun incMaxPC(amount: Number) {\r\n        this.maxpc = (this.maxpc + amount.toInt())\r\n    }\r\n    override fun getReg(i: Int) = regs32[i]\r\n    override fun setReg(i: Int, v: Number) { if (i != 0) regs32[i] = v.toInt() }\r\n    override fun getFReg(i: Int) = fregs[i]\r\n    override fun setFReg(i: Int, v: Decimal) { fregs[i] = v }\r\n    override fun getHeapEnd(): Number {\r\n        return heapEnd\r\n    }\r\n\r\n    override fun setHeapEnd(i: Number) {\r\n        heapEnd = i.toInt()\r\n    }\r\n\r\n    override fun incHeapEnd(amount: Number) {\r\n        heapEnd += amount.toInt()\r\n    }\r\n\r\n    override fun reset() {\r\n        this.cache.reset()\r\n    }\r\n}\r\n","package venusbackend.simulator\r\n\r\n/**\r\n * Thrown when errors occur when memory is not aligned.\r\n */\r\nclass StoreError : SimulatorError {\r\n    /**\r\n     * @param msg the message to error with\r\n     */\r\n    constructor(msg: String? = null) : super(msg)\r\n}\r\n","package venusbackend.simulator\r\n\r\nimport venusbackend.div\r\nimport venusbackend.riscv.InstructionField\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.insts.dsl.types.Instruction\r\nimport venusbackend.simulator.Tracer.Companion.wordAddressed\r\nimport kotlin.math.log2\r\nimport kotlin.math.pow\r\nimport kotlin.math.roundToInt\r\n\r\n/**\r\n * Created by Thaumic on 7/14/2018.\r\n */\r\n\r\nclass Trace(branched: Boolean, jumped: Boolean, ecallMsg: String, regs: Array<Number>, inst: MachineCode, line: Int, pc: Number, error: SimulatorError? = null) {\r\n    var branched = false\r\n    var jumped = false\r\n    var ecallMsg = \"\"\r\n    var regs = Array<Number>(0) { 0 }\r\n    var inst = MachineCode(0)\r\n    var line = 0\r\n    var pc: Number = 0\r\n    var prevTrace: Trace? = null\r\n    var error: SimulatorError? = null\r\n\r\n    init {\r\n        this.ecallMsg = ecallMsg\r\n        this.branched = branched\r\n        this.jumped = jumped\r\n        this.regs = regs\r\n        this.inst = inst\r\n        this.line = line\r\n        this.pc = pc\r\n        this.error = error\r\n    }\r\n\r\n    fun getString(format: String, base: Int): String {\r\n        if (this.error != null) {\r\n            return this.error.toString()\r\n        }\r\n        if (this.ecallMsg == \"exiting the simulator\") {\r\n            return \"exiting the simulator\\n\"\r\n        }\r\n        val code = try {\r\n            Instruction[this.inst].disasm(this.inst)\r\n        } catch (e: SimulatorError) {\r\n            \"Invalid Instruction\"\r\n        }\r\n        var f = format.replace(\"%output%\", this.ecallMsg)\r\n                    .replace(\"%inst%\", numToBase(base, this.inst.get(InstructionField.ENTIRE), this.inst.length * 8, true))\r\n                    .replace(\"%pc%\", numToBase(base, this.getPC(), 32, false))\r\n                    .replace(\"%line%\", numToBase(base, this.line, 16, false))\r\n                    .replace(\"%decode%\", code)\r\n        for (i in 0..(regs.size - 1)) {\r\n            f = f.replace(\"%\" + i.toString() + \"%\", numToBase(base, this.regs[i].toInt(), 32, true))\r\n            f = f.replace(\"%x\" + i.toString() + \"%\", numToBase(base, this.regs[i].toInt(), 32, true))\r\n        }\r\n        return f\r\n    }\r\n\r\n    fun getPC(): Number {\r\n        if (wordAddressed) {\r\n            return this.pc / 4\r\n        }\r\n        return this.pc\r\n    }\r\n\r\n    fun copy(): Trace {\r\n        /*@fixme This is not a pure copy since modifing internal things in the copy still can affect the main.*/\r\n        return Trace(branched, jumped, ecallMsg, regs.copyOf(), inst, line, pc)\r\n    }\r\n}\r\n/*\r\n* Takes in a base 10 integer and a base to convert it to and returns a string of what the number is.\r\n*/\r\nfun numToBase(curNumBase: Int, nu: Number, lengthNeeded: Int, signextend: Boolean): String {\r\n    val n = nu as Int // FIXME\r\n    val amount = ((2).toDouble()).pow(lengthNeeded.toDouble())\r\n    val length = getBaseLog(curNumBase.toDouble(), amount).roundToInt()\r\n    var num = if (signextend) {\r\n        (decimalToHexString(n).toLong(16)).toString(curNumBase)\r\n    } else {\r\n        n.toString(curNumBase)\r\n    }\r\n    if (length - num.length > 0) {\r\n        num = \"0\".repeat(length - num.length) + num\r\n    }\r\n    var snum = \"\"\r\n    if (curNumBase == 2) {\r\n        for (i in 0 until length) {\r\n            if (i % 4 == 0 && i != 0) {\r\n                snum += \" \"\r\n            }\r\n            snum += num[i]\r\n        }\r\n    } else {\r\n        snum = num\r\n    }\r\n    return snum\r\n}\r\n\r\nfun getBaseLog(x: Double, y: Double): Double {\r\n    return (log2(y) / log2(x))\r\n}\r\n\r\nfun decimalToHexString(number: Int): String {\r\n    var retval = number.toLong()\r\n    if (number < 0) {\r\n        retval = 0xFFFFFFFF + number + 1\r\n    }\r\n    val rv = retval.toString(16).toUpperCase()\r\n    return if (rv.length > 8) {\r\n        rv.substring(0 until 8)\r\n    } else {\r\n        rv\r\n    }\r\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ByteArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun ShortArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun IntArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun LongArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun FloatArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\n@library(\"arrayToString\")\npublic actual fun CharArray.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","package venusbackend.simulator\r\n\r\nimport venusbackend.compareTo\r\nimport venusbackend.minus\r\nimport venusbackend.plus\r\nimport venusbackend.riscv.MachineCode\r\nimport venusbackend.riscv.MemorySegments\r\n\r\n/**\r\n * Created by Thaumic on 7/14/2018.\r\n */\r\nclass Tracer(var sim: Simulator) {\r\n    var version = \"v2.0.1\"\r\n    var format = \"%output%%0%\\t%1%\\t%2%\\t%3%\\t%4%\\t%5%\\t%6%\\t%7%\\t%8%\\t%9%\\t%10%\\t%11%\\t%12%\\t%13%\\t%14%\\t%15%\\t%16%\\t%17%\\t%18%\\t%19%\\t%20%\\t%21%\\t%22%\\t%23%\\t%24%\\t%25%\\t%26%\\t%27%\\t%28%\\t%29%\\t%30%\\t%31%\\t%line%\\t%pc%\\t%inst%\\n\"\r\n    var amtReg = 32\r\n    var base = 2\r\n    var totCommands = -1\r\n    var instFirst = false\r\n    private var prevInst = MachineCode(0)\r\n    var maxSteps = 1000000\r\n    var tr = TraceEncapsulation()\r\n    var twoStage = false\r\n\r\n    companion object {\r\n        var wordAddressed = false\r\n    }\r\n\r\n    fun trace() {\r\n        traceStart()\r\n        var err: SimulatorError? = null\r\n        while (!sim.isDone()) {\r\n            try {\r\n                traceStep()\r\n            } catch (e: SimulatorError) {\r\n                err = e\r\n                break\r\n            }\r\n        }\r\n        traceEnd()\r\n        if (err != null) {\r\n            this.traceAddError(err)\r\n        }\r\n    }\r\n\r\n    fun traceAddError(err: SimulatorError) {\r\n        this.tr.trace.add(Trace(false, false, \"\", Array(0) { 0 }, MachineCode(0), 0, 0, error = err))\r\n    }\r\n\r\n    fun traceFullReset() {\r\n        this.tr.traced = false\r\n        this.tr.trace = ArrayList()\r\n        this.tr.prevTrace = null\r\n        this.tr.traceLine = 0\r\n        this.tr.str = \"\"\r\n        this.tr.stred = false\r\n        this.tr.stringIndex = 0\r\n    }\r\n\r\n    fun traceStart() {\r\n        traceFullReset()\r\n        sim.reset(keep_args = true)\r\n        if (this.twoStage) {\r\n            this.tr.trace.add(Trace(didBrach(), didJump(), getecallMsg(), getRegs(), if (!sim.isDone()) sim.getNextInstruction() else MachineCode(0), this.tr.traceLine, sim.getPC()))\r\n            this.tr.traceLine++\r\n        }\r\n        if (!this.instFirst && !sim.isDone()) {\r\n            prevInst = sim.getNextInstruction()\r\n            sim.step()\r\n        }\r\n    }\r\n\r\n    fun traceStep() {\r\n        if (sim.isDone()) {\r\n            return\r\n        }\r\n        if (this.tr.traceLine > this.maxSteps && this.maxSteps > 0) {\r\n            throw SimulatorError(\"The max number of steps (\" + this.maxSteps + \") in the tracer has been reached! You can increase this in the settings or disable it by setting it to 0 or less. This is the current safty for infinitely looping programs.\")\r\n        }\r\n        val currentTrace = getSingleTrace(this.tr.traceLine)\r\n        currentTrace.prevTrace = this.tr.prevTrace\r\n        this.tr.trace.add(currentTrace)\r\n        this.tr.prevTrace = currentTrace\r\n        sim.step()\r\n        this.tr.traceLine++\r\n    }\r\n\r\n    fun traceEnd() {\r\n        val currentTrace = getSingleTrace(this.tr.traceLine)\r\n        currentTrace.prevTrace = this.tr.prevTrace\r\n        this.tr.trace.add(currentTrace)\r\n        this.tr.traced = true\r\n        sim.reset(keep_args = true)\r\n        if (this.twoStage) {\r\n            var i = this.tr.trace.lastIndex\r\n            if (i < 0) {\r\n                return\r\n            }\r\n            var prevmc = MachineCode(0)\r\n            var prevpc = this.tr.trace[i].pc + prevmc.length\r\n            while (i > 0) {\r\n                /*FIXME Make this loop another call.*/\r\n                val cur = this.tr.trace[i]\r\n                val curmc = cur.inst\r\n                val curpc = cur.pc\r\n                cur.inst = prevmc\r\n                cur.pc = prevpc\r\n                prevmc = curmc\r\n                prevpc = curpc\r\n                i--\r\n            }\r\n        }\r\n    }\r\n\r\n    fun getSingleTrace(line: Int): Trace {\r\n        var mc = MachineCode(0)\r\n        if (!sim.isDone()) {\r\n            mc = sim.getNextInstruction()\r\n        }\r\n        if (!this.instFirst) {\r\n            val t = mc\r\n            mc = prevInst\r\n            prevInst = t\r\n        }\r\n        return Trace(didBrach(), didJump(), getecallMsg(), getRegs(), mc, line, sim.getPC())\r\n    }\r\n\r\n    fun getRegs(): Array<Number> {\r\n        val r = Array<Number>(amtReg) { 0 }\r\n        for (i in 0..(amtReg - 1)) {\r\n            r[i] = sim.getReg(i)\r\n        }\r\n        return r\r\n    }\r\n\r\n    fun didBrach(): Boolean {\r\n        return sim.branched\r\n    }\r\n    fun didJump(): Boolean {\r\n        return sim.jumped\r\n    }\r\n\r\n    fun getecallMsg(): String {\r\n        return sim.ecallMsg\r\n    }\r\n\r\n    fun getString(): String {\r\n        if (!this.tr.stred) {\r\n            throw SimulatorError(\"The trace string has not finished!\")\r\n        }\r\n        return this.tr.str\r\n    }\r\n\r\n    fun traceStringStart() {\r\n        if (!this.tr.traced) {\r\n            throw SimulatorError(\"You need to make the run the trace before you can get the trace string!\")\r\n        }\r\n        val tr = this.tr.trace\r\n        cleanFormat()\r\n        this.tr.reset()\r\n    }\r\n\r\n    fun traceStringStep(): Boolean {\r\n        val t = this.tr.getNextTrace()\r\n        if (twoStage && this.instFirst) {\r\n            if (this.tr.peak().branched) {\r\n                traceStringBranchHelper(t)\r\n            }\r\n            if (t.branched && this.instFirst && this.twoStage) {\r\n//                t.pc += 4\r\n            }\r\n            if (this.tr.peak().jumped) {\r\n                if (!this.twoStage) {\r\n                    t.regs = this.tr.peak().regs.copyOf()\r\n                }\r\n                t.prevTrace?.regs = t.regs.copyOf()\r\n                traceStringJumpHelper(t)\r\n                if (this.twoStage) {\r\n                    t.regs = this.tr.peak().regs.copyOf()\r\n                }\r\n            }\r\n        }\r\n        t.line = this.tr.stringIndex\r\n        val peaked = this.tr.peak()\r\n        if (twoStage && this.instFirst && (peaked.jumped || peaked.branched) && t.pc > sim.getMaxPC()) {\r\n            t.pc = t.pc.toInt() + 4\r\n        }\r\n        this.tr.str += t.getString(format, base)\r\n        this.tr.stringIndex++\r\n        if (twoStage && !this.instFirst) {\r\n            if (t.branched) {\r\n                traceStringBranchHelper(t)\r\n            }\r\n            if (t.jumped) {\r\n                /*FIXME There need to make it work w/o inst first and two stage.*/\r\n                t.regs = this.tr.peak().regs.copyOf()\r\n                t.prevTrace?.regs = t.regs.copyOf()\r\n                traceStringJumpHelper(t)\r\n            }\r\n        }\r\n        if (this.totCommands > 0 && this.tr.stringIndex >= this.totCommands) {\r\n            return false\r\n        }\r\n        return this.tr.hasNext()\r\n    }\r\n\r\n    fun traceStringBranchHelper(t: Trace) {\r\n        val pt = t.prevTrace\r\n        val flushed = pt?.copy() ?: this.getSingleTrace(-1)\r\n        var nextPC = flushed.pc + flushed.inst.length\r\n        flushed.pc = nextPC\r\n        nextPC -= MemorySegments.TEXT_BEGIN\r\n        flushed.inst = if (nextPC < this.sim.getMaxPC()) this.sim.getInstAt(nextPC) else MachineCode(0)\r\n        flushed.line = this.tr.stringIndex\r\n        if (this.instFirst && this.twoStage) {\r\n            flushed.regs = t.regs\r\n        }\r\n        this.tr.str += flushed.getString(format, base)\r\n        this.tr.stringIndex++\r\n    }\r\n    fun traceStringJumpHelper(t: Trace) {\r\n        val pt = t.prevTrace\r\n        val flushed = pt?.copy() ?: this.getSingleTrace(-1)\r\n        var nextPC = flushed.pc + flushed.inst.length\r\n        flushed.pc = nextPC\r\n        nextPC -= MemorySegments.TEXT_BEGIN\r\n        flushed.inst = if (nextPC < this.sim.getMaxPC()) this.sim.getInstAt(nextPC) else MachineCode(0)\r\n        flushed.line = this.tr.stringIndex\r\n        if (this.instFirst && this.twoStage) {\r\n//            flushed.regs = t.regs\r\n        }\r\n        this.tr.str += flushed.getString(format, base)\r\n        this.tr.stringIndex++\r\n    }\r\n\r\n    fun traceStringEnd() {\r\n        val tr = this.tr.trace\r\n        val t = tr[tr.size - 1]\r\n        while (this.tr.stringIndex < this.totCommands) {\r\n            t.inst = MachineCode(0)\r\n            t.line++\r\n            t.pc += t.inst.length\r\n            this.tr.str += t.getString(format, base)\r\n            this.tr.stringIndex++\r\n        }\r\n        try {\r\n            if (this.twoStage && this.instFirst && this.tr.trace[2].jumped) {\r\n            }\r\n        } catch (e: Throwable) {\r\n            println(\"Internal error in traceString\")\r\n            println(e)\r\n        }\r\n        this.tr.stred = true\r\n    }\r\n\r\n    fun traceString() {\r\n        traceStringStart()\r\n        while (tr.hasNext()) {\r\n            traceStringStep()\r\n        }\r\n        traceStringEnd()\r\n    }\r\n\r\n    private fun incPC(pc: Int): Int {\r\n        return pc + 4\r\n    }\r\n\r\n    private fun cleanFormat() {\r\n        this.format = this.format.replace(\"\\\\t\", \"\\t\").replace(\"\\\\n\", \"\\n\")\r\n    }\r\n\r\n    fun setWordAddressed(b: Boolean) {\r\n        wordAddressed = b\r\n    }\r\n}\r\nclass TraceEncapsulation {\r\n\r\n    lateinit var trace: ArrayList<Trace>\r\n    var traced = false\r\n    var prevTrace: Trace? = null\r\n    var traceLine = 0\r\n    var str: String = \"\"\r\n    var stred = false\r\n    var stringIndex = 0\r\n\r\n    private var curLoc = 0\r\n    fun getNextTrace(): Trace {\r\n        if (!hasNext()) {\r\n            throw IndexOutOfBoundsException(\"There are no more items to iterate over!\")\r\n        }\r\n        val t = trace[curLoc]\r\n        this.curLoc++\r\n        return t\r\n    }\r\n    fun peak(): Trace {\r\n        return trace[minOf(curLoc, trace.lastIndex)]\r\n    }\r\n    fun reset() {\r\n        curLoc = 0\r\n    }\r\n    fun hasNext(): Boolean {\r\n        return curLoc < trace.size\r\n    }\r\n}\r\n","package venusbackend\r\n\r\n/** a map from integers to the corresponding hex digits */\r\nprivate val hexMap = listOf('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n        'A', 'B', 'C', 'D', 'E', 'F')\r\n\r\n/**\r\n * Converts a value to a two's complement hex number.\r\n *\r\n * By two's complement, I mean that -1 becomes 0xFFFFFFFF not -0x1.\r\n *\r\n * @param value the value to convert\r\n * @return the hexadecimal string corresponding to that value\r\n */\r\nfun toHex(value: Int, num_nibbles: Int = 8, add_prefix: Boolean = true): String {\r\n    var remainder = value.toLong()\r\n    var suffix = \"\"\r\n\r\n    repeat(num_nibbles) {\r\n        val hexDigit = hexMap[(remainder and 15).toInt()]\r\n        suffix = hexDigit + suffix\r\n        remainder = remainder ushr 4\r\n    }\r\n\r\n    if (add_prefix) {\r\n        suffix = \"0x\" + suffix\r\n    }\r\n\r\n    return suffix\r\n}\r\n\r\nfun toHex(value: Number): String {\r\n    return toHex(value.toInt())\r\n}"],"names":[],"mappings":"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;K;;;SACA,Y;;;MAAA,4B;K;SAAA,kB;MAAA,8B;K;;;;;;;ECRS,gC;IAIT,+B;IAJU,4B;IAA4B,8B;IACtC,gD;IACA,0BAAwB,c;IACxB,6BAA2B,oB;IAUvB,6B;IAAA,UAAS,wC;I7DwLb,sBAAI,GAAJ,E6DxLyB,E7DwLzB,C;G;;S6DrMU,Y;MAAA,2B;K;SAAA,iB;MAAA,4B;K;;;SAA4B,Y;MAAA,4B;K;SAAA,kB;MAAA,8B;K;;;SACtC,Y;MAAA,0B;K;;;SACA,Y;MAAA,8B;K;SAAA,oB;MAAA,kC;K;;;SACA,Y;MAAA,iC;K;SAAA,uB;MAAA,wC;K;;EACA,6B;IAAA,iC;IACI,gBAAe,W;G;gDACf,iC;IAEiB,IAAc,I;IAD3B,WAAW,YAAQ,aAAc,MAAtB,EAA6B,MAA7B,C;IACX,IAAK,SAAQ,QAAc,OAAd,aAAc,SAAd,kCAAR,C;IACL,OAAO,I;EACX,C;;;;;;;EANJ,yC;IAAA,wC;MAAA,uB;;IAAA,iC;G;+BAWA,Y;IACW,Q;IAAP,OAAO,uCAAS,wCAAT,mC;EACX,C;8BACA,a;IACI,6B;IAAA,UAAS,wC;I7DkLb,sBAAI,GAAJ,E6DlLyB,C7DkLzB,C;E6DjLA,C;gCAEA,Y;IAKkB,Q;IAJd,SAAS,mB;IACT,WAAW,IAAK,M;IAChB,iBAAiB,IAAK,Y;IACtB,UAAU,IAAK,KAAK,W;IACpB,cAAc,eAAA,IAAK,SAAL,WAAc,wCAAd,mC;IACd,OAAO,E;EACX,C;;;;;;EC3BgB,iC;IAqChB,iC;IArCiB,gB;IAAkB,8B;IACnC,kD;IACA,uBAAqB,S;IACrB,0BAAwB,c;IACxB,6BAA2B,oB;IAEvB,6B;IAAA,YAAiB,W;I9D6LrB,sB8D7La,I9D6Lb,EAAS,KAAT,C;I8D5LI,a9D4LJ,a8D5La,G9D4Lb,E8D5LoB,I9D4LpB,C;G;;S8DnMmC,Y;MAAA,4B;K;SAAA,kB;MAAA,8B;K;;;SACnC,Y;MAAA,0B;K;;;SACA,Y;MAAA,2B;K;SAAA,iB;MAAA,4B;K;;;SACA,Y;MAAA,8B;K;SAAA,oB;MAAA,kC;K;;;SACA,Y;MAAA,iC;K;SAAA,uB;MAAA,wC;K;;wCAKA,gB;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AAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,0C;IAAA,6B;IAAA,kC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EAEA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;;;;;EA3DJ,mC;IAAA,4hE;G;;EAAA,wC;IAAA,a;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,S;QAAA,uC;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,W;QAAA,yC;MAAA,U;QAAA,wC;MAAA,W;QAAA,yC;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,U;QAAA,wC;MAAA,a;QAAA,2C;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,U;QAAA,wC;MAAA,Y;QAAA,0C;MAAA,Y;QAAA,0C;MAAA,U;QAAA,wC;MAAA,U;QAAA,wC;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,W;QAAA,yC;MAAA,Y;QAAA,0C;MAAA,a;QAAA,2C;MAAA,a;QAAA,2C;MAAA,Y;QAAA,0C;MAAA,a;QAAA,2C;MAAA,a;QAAA,2C;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,W;QAAA,yC;MAAA,QAAA,4E;;G;;;;;ICII,YAAiB,I;;6CAejB,Y;IACI,IAAI,iBAAJ,C;MAA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AU,CAAnC,qB;;;MAEqB,SAAd,WAAL,SAAK,CAAc,YAAS,WAAN,KAAM,CAAT,C;;IATzB,a;EAWJ,C;ECzKa,uB;IACT,YAAW,C;IACX,eAAc,C;G;;;;;;ECoBlB,4B;IACI,wC;IAII,IAAI,CAAC,+CAAL,C;MACI,I;MACA,K;MACA,I;MACA,K;MACA,M;MACA,K;MACA,M;MACA,M;MACA,K;MACA,K;MACA,M;MACA,I;MACA,E;MACA,G;MACA,E;MACA,E;MACA,G;MACA,E;MAEA,G;MACA,I;MACA,K;MACA,I;MACA,K;MACA,I;MACA,K;MACA,I;MACA,K;MACA,I;MACA,K;MACA,I;MACA,K;MACA,I;MACA,G;MACA,I;MACA,G;MACA,I;MACA,G;MACA,I;MACA,G;MACA,I;MACA,G;MACA,I;MACA,G;MACA,E;MACA,E;MACA,E;MACA,E;MACA,G;MACA,G;MACA,I;MACA,G;MACA,I;MACA,G;MACA,K;MACA,G;MACA,G;MACA,O;MACA,O;MACA,O;MACA,Q;MACA,O;MACA,Q;MACA,M;MACA,Q;MACA,O;MACA,G;MACA,G;MACA,K;MACA,I;MAEA,G;MACA,I;MACA,M;MACA,K;MAEA,K;MACA,I;MAGA,G;MACA,K;MACA,O;MACA,M;MACA,O;MACA,M;MACA,O;MACA,I;MACA,I;MACA,I;MACA,M;MACA,K;MACA,K;MACA,M;MACA,K;MACA,K;MACA,K;MACA,O;MACA,O;MACA,M;MACA,O;MACA,O;MACA,M;MACA,K;MACA,G;MACA,G;MACA,K;MACA,O;MACA,M;MACA,O;MACA,M;MACA,O;MACA,K;MACA,I;MACA,I;MACA,I;MACA,M;MACA,K;MACA,K;MACA,M;MACA,K;MACA,K;MACA,K;MACA,O;MACA,O;MACA,M;MACA,O;MACA,O;MACA,M;MACA,K;MACA,G;MACA,M;MACA,M;MACA,K;MACA,I;MACA,G;MACA,I;MACA,K;MACA,I;MACA,I;MACA,O;MACA,G;MACA,kDAAS,I;;G;EAnJjB,sC;IAAA,0C;IACI,cAAa,K;G;;;;;;;EADjB,kD;IAAA,iD;MAAA,gC;;IAAA,0C;G;;;;;;ECtBuB,iD;IAD3B,e;IAC4B,Y;IAAa,Y;IADzC,iB;IAAA,uB;G;EAAA,uC;IAAA,0C;K;IAEI,qEAAO,CAAP,EAAU,EAAV,C;IACA,iEAAK,CAAL,EAAQ,EAAR,C;IACA,qEAAO,CAAP,EAAU,CAAV,C;IACA,+DAAI,CAAJ,EAAO,CAAP,C;IACA,6DAAG,CAAH,EAAM,EAAN,C;IACA,iEAAK,CAAL,EAAQ,CAAR,C;IACA,iEAAK,CAAL,EAAQ,CAAR,C;IACA,qEAAO,EAAP,EAAW,EAAX,C;IACA,uEAAQ,EAAR,EAAY,EAAZ,C;IACA,qEAAO,EAAP,EAAW,EAAX,C;IACA,wEAAQ,CAAR,EAAW,CAAX,C;IACA,oEAAM,CAAN,EAAS,CAAT,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,oEAAM,EAAN,EAAU,EAAV,C;IACA,kEAAK,CAAL,EAAQ,EAAR,C;IACA,gEAAI,CAAJ,EAAO,EAAP,C;IACA,gEAAI,EAAJ,EAAQ,EAAR,C;IACA,gEAAI,EAAJ,EAAQ,EAAR,C;IACA,gEAAI,EAAJ,EAAQ,EAAR,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,8DAAG,EAAH,EAAO,EAAP,C;IACA,8DAAG,EAAH,EAAO,EAAP,C;IACA,4EAAU,CAAV,EAAa,CAAb,C;IACA,wEAAQ,EAAR,EAAY,EAAZ,C;IACA,0EAAS,EAAT,EAAa,EAAb,C;IACA,wEAAQ,CAAR,EAAW,EAAX,C;IACA,0EAAS,EAAT,EAAa,EAAb,C;IACA,0EAAS,CAAT,EAAY,CAAZ,C;IACA,wEAAQ,CAAR,EAAW,EAAX,C;IACA,0EAAS,EAAT,EAAa,EAAb,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,0EAAS,CAAT,EAAY,EAAZ,C;IACA,4EAAU,EAAV,EAAc,EAAd,C;IACA,4EAAU,EAAV,EAAc,EAAd,C;IACA,0EAAS,EAAT,EAAa,EAAb,C;IACA,0EAAS,EAAT,EAAa,EAAb,C;IACA,sEAAO,EAAP,EAAW,EAAX,C;IACA,oEAAM,EAAN,EAAU,EAAV,C;G;;EAvCA,+C;IAAA,6B;IAAA,uC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,gD;IAAA,6B;IAAA,wC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,gD;IAAA,6B;IAAA,wC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;EACA,6C;IAAA,6B;IAAA,qC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,4C;IAAA,6B;IAAA,oC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,2C;IAAA,6B;IAAA,mC;G;;EACA,kD;IAAA,6B;IAAA,0C;G;;EACA,gD;IAAA,6B;IAAA,wC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,gD;IAAA,6B;IAAA,wC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,gD;IAAA,6B;IAAA,wC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,kD;IAAA,6B;IAAA,0C;G;;EACA,kD;IAAA,6B;IAAA,0C;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,iD;IAAA,6B;IAAA,yC;G;;EACA,+C;IAAA,6B;IAAA,uC;G;;EACA,8C;IAAA,6B;IAAA,sC;G;;;;;;EAzCJ,mC;IAAA,qhD;G;;EAAA,wC;IAAA,a;MAAA,c;QAAA,4C;MAAA,Y;QAAA,0C;MAAA,c;QAAA,4C;MAAA,W;QAAA,yC;MAAA,U;QAAA,w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eAAe,6BAAQ,oBAAkB,QAA1B,E;MACN,YAAW,Q;MAApB,WnaJ2D,oBmaIlD,QnaJkD,CAAL,GAAkB,K;MmaKxE,cAAY,+BAAe,CAAf,C;;IAGhB,IAAI,UAAJ,C;MACI,WAAS,OAAO,Q;;IAGpB,OAAO,Q;EACX,C;EAEA,wB;IACI,OAAO,MAAY,YAAN,KAAM,CAAZ,C;EACX,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;S/ZvBA,iB;;K;;;;;;SCLA,iB;;K;;;;;;SCAA,iB;;K;;;;;;SCCA,iB;;K;;;;;;SCEA,iB;;K;;;;;;;SCDA,iB;;K;;;;;;SCDA,iB;;K;;;;;;SCOA,iB;;K;;;;;;SCRA,iB;;K;;;;;;SCAA,iB;;K;;;;;;SCAA,iB;;K;;;;;;SCAA,iB;;K;;;;;;SCAA,iB;;K;;;;;;SCYA,iB;;K;;;;;;SCXA,iB;;K;;;;;;SCDA,iB;;K;;;;;;SCCA,iB;;K;;;;;;SCGA,iB;;K;;;;;;SCGA,iB;;K;;;;;;;;SESA,iB;;K;;;;;;SCdA,iB;;K;;;;;;SCGA,iB;;K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ShDDA,iB;;K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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"}